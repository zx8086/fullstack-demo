import {
  filter,
  fromAsyncIterable,
  fromPromise,
  fromValue,
  lazy,
  make,
  makeSubject,
  map,
  merge,
  mergeMap,
  onEnd,
  onPush,
  onStart,
  publish,
  share,
  subscribe,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  toPromise
} from "./chunk-HY6KVJEY.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError = class extends Error {
  constructor(e2, r, i3, n2, a2, t2, o2) {
    super(e2);
    this.name = "GraphQLError";
    this.message = e2;
    if (a2) {
      this.path = a2;
    }
    if (r) {
      this.nodes = Array.isArray(r) ? r : [r];
    }
    if (i3) {
      this.source = i3;
    }
    if (n2) {
      this.positions = n2;
    }
    if (t2) {
      this.originalError = t2;
    }
    var l3 = o2;
    if (!l3 && t2) {
      var u3 = t2.extensions;
      if (u3 && "object" == typeof u3) {
        l3 = u3;
      }
    }
    this.extensions = l3 || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i;
var n;
function error(e2) {
  return new GraphQLError(`Syntax Error: Unexpected token at ${n} in ${e2}`);
}
function advance(e2) {
  e2.lastIndex = n;
  if (e2.test(i)) {
    return i.slice(n, n = e2.lastIndex);
  }
}
var a = / +(?=[^\s])/y;
function blockString(e2) {
  var r = e2.split("\n");
  var i3 = "";
  var n2 = 0;
  var t2 = 0;
  var o2 = r.length - 1;
  for (var l3 = 0; l3 < r.length; l3++) {
    a.lastIndex = 0;
    if (a.test(r[l3])) {
      if (l3 && (!n2 || a.lastIndex < n2)) {
        n2 = a.lastIndex;
      }
      t2 = t2 || l3;
      o2 = l3;
    }
  }
  for (var u3 = t2; u3 <= o2; u3++) {
    if (u3 !== t2) {
      i3 += "\n";
    }
    i3 += r[u3].slice(n2).replace(/\\"""/g, '"""');
  }
  return i3;
}
function ignored() {
  for (var e2 = 0 | i.charCodeAt(n++); 9 === e2 || 10 === e2 || 13 === e2 || 32 === e2 || 35 === e2 || 44 === e2 || 65279 === e2; e2 = 0 | i.charCodeAt(n++)) {
    if (35 === e2) {
      while (10 !== (e2 = i.charCodeAt(n++)) && 13 !== e2) {
      }
    }
  }
  n--;
}
var t = /[_A-Za-z]\w*/y;
function name() {
  var e2;
  if (e2 = advance(t)) {
    return {
      kind: "Name",
      value: e2
    };
  }
}
var o = /(?:null|true|false)/y;
var l = /\$[_A-Za-z]\w*/y;
var u = /-?\d+/y;
var v = /(?:\.\d+)?[eE][+-]?\d+|\.\d+/y;
var d = /\\/g;
var s = /"""(?:"""|(?:[\s\S]*?[^\\])""")/y;
var c = /"(?:"|[^\r\n]*?[^\\]")/y;
function value(e2) {
  var r;
  var a2;
  if (a2 = advance(o)) {
    r = "null" === a2 ? {
      kind: "NullValue"
    } : {
      kind: "BooleanValue",
      value: "true" === a2
    };
  } else if (!e2 && (a2 = advance(l))) {
    r = {
      kind: "Variable",
      name: {
        kind: "Name",
        value: a2.slice(1)
      }
    };
  } else if (a2 = advance(u)) {
    var f3 = a2;
    if (a2 = advance(v)) {
      r = {
        kind: "FloatValue",
        value: f3 + a2
      };
    } else {
      r = {
        kind: "IntValue",
        value: f3
      };
    }
  } else if (a2 = advance(t)) {
    r = {
      kind: "EnumValue",
      value: a2
    };
  } else if (a2 = advance(s)) {
    r = {
      kind: "StringValue",
      value: blockString(a2.slice(3, -3)),
      block: true
    };
  } else if (a2 = advance(c)) {
    r = {
      kind: "StringValue",
      value: d.test(a2) ? JSON.parse(a2) : a2.slice(1, -1),
      block: false
    };
  } else if (r = function list(e3) {
    var r2;
    if (91 === i.charCodeAt(n)) {
      n++;
      ignored();
      var a3 = [];
      while (r2 = value(e3)) {
        a3.push(r2);
      }
      if (93 !== i.charCodeAt(n++)) {
        throw error("ListValue");
      }
      ignored();
      return {
        kind: "ListValue",
        values: a3
      };
    }
  }(e2) || function object(e3) {
    if (123 === i.charCodeAt(n)) {
      n++;
      ignored();
      var r2 = [];
      var a3;
      while (a3 = name()) {
        ignored();
        if (58 !== i.charCodeAt(n++)) {
          throw error("ObjectField");
        }
        ignored();
        var t2 = value(e3);
        if (!t2) {
          throw error("ObjectField");
        }
        r2.push({
          kind: "ObjectField",
          name: a3,
          value: t2
        });
      }
      if (125 !== i.charCodeAt(n++)) {
        throw error("ObjectValue");
      }
      ignored();
      return {
        kind: "ObjectValue",
        fields: r2
      };
    }
  }(e2)) {
    return r;
  }
  ignored();
  return r;
}
function arguments_(e2) {
  var r = [];
  ignored();
  if (40 === i.charCodeAt(n)) {
    n++;
    ignored();
    var a2;
    while (a2 = name()) {
      ignored();
      if (58 !== i.charCodeAt(n++)) {
        throw error("Argument");
      }
      ignored();
      var t2 = value(e2);
      if (!t2) {
        throw error("Argument");
      }
      r.push({
        kind: "Argument",
        name: a2,
        value: t2
      });
    }
    if (!r.length || 41 !== i.charCodeAt(n++)) {
      throw error("Argument");
    }
    ignored();
  }
  return r;
}
function directives(e2) {
  var r = [];
  ignored();
  while (64 === i.charCodeAt(n)) {
    n++;
    var a2 = name();
    if (!a2) {
      throw error("Directive");
    }
    ignored();
    r.push({
      kind: "Directive",
      name: a2,
      arguments: arguments_(e2)
    });
  }
  return r;
}
function field() {
  var e2 = name();
  if (e2) {
    ignored();
    var r;
    if (58 === i.charCodeAt(n)) {
      n++;
      ignored();
      r = e2;
      if (!(e2 = name())) {
        throw error("Field");
      }
      ignored();
    }
    return {
      kind: "Field",
      alias: r,
      name: e2,
      arguments: arguments_(false),
      directives: directives(false),
      selectionSet: selectionSet()
    };
  }
}
function type() {
  var e2;
  ignored();
  if (91 === i.charCodeAt(n)) {
    n++;
    ignored();
    var r = type();
    if (!r || 93 !== i.charCodeAt(n++)) {
      throw error("ListType");
    }
    e2 = {
      kind: "ListType",
      type: r
    };
  } else if (e2 = name()) {
    e2 = {
      kind: "NamedType",
      name: e2
    };
  } else {
    throw error("NamedType");
  }
  ignored();
  if (33 === i.charCodeAt(n)) {
    n++;
    ignored();
    return {
      kind: "NonNullType",
      type: e2
    };
  } else {
    return e2;
  }
}
var f = /on/y;
function typeCondition() {
  if (advance(f)) {
    ignored();
    var e2 = name();
    if (!e2) {
      throw error("NamedType");
    }
    ignored();
    return {
      kind: "NamedType",
      name: e2
    };
  }
}
var p = /\.\.\./y;
function fragmentSpread() {
  if (advance(p)) {
    ignored();
    var e2 = n;
    var r;
    if ((r = name()) && "on" !== r.value) {
      return {
        kind: "FragmentSpread",
        name: r,
        directives: directives(false)
      };
    } else {
      n = e2;
      var i3 = typeCondition();
      var a2 = directives(false);
      var t2 = selectionSet();
      if (!t2) {
        throw error("InlineFragment");
      }
      return {
        kind: "InlineFragment",
        typeCondition: i3,
        directives: a2,
        selectionSet: t2
      };
    }
  }
}
function selectionSet() {
  var e2;
  ignored();
  if (123 === i.charCodeAt(n)) {
    n++;
    ignored();
    var r = [];
    while (e2 = fragmentSpread() || field()) {
      r.push(e2);
    }
    if (!r.length || 125 !== i.charCodeAt(n++)) {
      throw error("SelectionSet");
    }
    ignored();
    return {
      kind: "SelectionSet",
      selections: r
    };
  }
}
var m = /fragment/y;
function fragmentDefinition() {
  if (advance(m)) {
    ignored();
    var e2 = name();
    if (!e2) {
      throw error("FragmentDefinition");
    }
    ignored();
    var r = typeCondition();
    if (!r) {
      throw error("FragmentDefinition");
    }
    var i3 = directives(false);
    var n2 = selectionSet();
    if (!n2) {
      throw error("FragmentDefinition");
    }
    return {
      kind: "FragmentDefinition",
      name: e2,
      typeCondition: r,
      directives: i3,
      selectionSet: n2
    };
  }
}
var g = /(?:query|mutation|subscription)/y;
function operationDefinition() {
  var e2;
  var r;
  var a2 = [];
  var t2 = [];
  if (e2 = advance(g)) {
    ignored();
    r = name();
    a2 = function variableDefinitions() {
      var e3;
      var r2 = [];
      ignored();
      if (40 === i.charCodeAt(n)) {
        n++;
        ignored();
        while (e3 = advance(l)) {
          ignored();
          if (58 !== i.charCodeAt(n++)) {
            throw error("VariableDefinition");
          }
          var a3 = type();
          var t3 = void 0;
          if (61 === i.charCodeAt(n)) {
            n++;
            ignored();
            if (!(t3 = value(true))) {
              throw error("VariableDefinition");
            }
          }
          ignored();
          r2.push({
            kind: "VariableDefinition",
            variable: {
              kind: "Variable",
              name: {
                kind: "Name",
                value: e3.slice(1)
              }
            },
            type: a3,
            defaultValue: t3,
            directives: directives(true)
          });
        }
        if (41 !== i.charCodeAt(n++)) {
          throw error("VariableDefinition");
        }
        ignored();
      }
      return r2;
    }();
    t2 = directives(false);
  }
  var o2 = selectionSet();
  if (o2) {
    return {
      kind: "OperationDefinition",
      operation: e2 || "query",
      name: r,
      variableDefinitions: a2,
      directives: t2,
      selectionSet: o2
    };
  }
}
function parse(e2, r) {
  i = "string" == typeof e2.body ? e2.body : e2;
  n = 0;
  return function document() {
    var e3;
    ignored();
    var r2 = [];
    while (e3 = fragmentDefinition() || operationDefinition()) {
      r2.push(e3);
    }
    return {
      kind: "Document",
      definitions: r2
    };
  }();
}
function printString(e2) {
  return JSON.stringify(e2);
}
function printBlockString(e2) {
  return '"""\n' + e2.replace(/"""/g, '\\"""') + '\n"""';
}
var hasItems = (e2) => !(!e2 || !e2.length);
var y = {
  OperationDefinition(e2) {
    if ("query" === e2.operation && !e2.name && !hasItems(e2.variableDefinitions) && !hasItems(e2.directives)) {
      return y.SelectionSet(e2.selectionSet);
    }
    var r = e2.operation;
    if (e2.name) {
      r += " " + e2.name.value;
    }
    if (hasItems(e2.variableDefinitions)) {
      if (!e2.name) {
        r += " ";
      }
      r += "(" + e2.variableDefinitions.map(y.VariableDefinition).join(", ") + ")";
    }
    if (hasItems(e2.directives)) {
      r += " " + e2.directives.map(y.Directive).join(" ");
    }
    return r + " " + y.SelectionSet(e2.selectionSet);
  },
  VariableDefinition(e2) {
    var r = y.Variable(e2.variable) + ": " + print(e2.type);
    if (e2.defaultValue) {
      r += " = " + print(e2.defaultValue);
    }
    if (hasItems(e2.directives)) {
      r += " " + e2.directives.map(y.Directive).join(" ");
    }
    return r;
  },
  Field(e2) {
    var r = (e2.alias ? e2.alias.value + ": " : "") + e2.name.value;
    if (hasItems(e2.arguments)) {
      var i3 = e2.arguments.map(y.Argument);
      var n2 = r + "(" + i3.join(", ") + ")";
      r = n2.length > 80 ? r + "(\n  " + i3.join("\n").replace(/\n/g, "\n  ") + "\n)" : n2;
    }
    if (hasItems(e2.directives)) {
      r += " " + e2.directives.map(y.Directive).join(" ");
    }
    return e2.selectionSet ? r + " " + y.SelectionSet(e2.selectionSet) : r;
  },
  StringValue: (e2) => e2.block ? printBlockString(e2.value) : printString(e2.value),
  BooleanValue: (e2) => "" + e2.value,
  NullValue: (e2) => "null",
  IntValue: (e2) => e2.value,
  FloatValue: (e2) => e2.value,
  EnumValue: (e2) => e2.value,
  Name: (e2) => e2.value,
  Variable: (e2) => "$" + e2.name.value,
  ListValue: (e2) => "[" + e2.values.map(print).join(", ") + "]",
  ObjectValue: (e2) => "{" + e2.fields.map(y.ObjectField).join(", ") + "}",
  ObjectField: (e2) => e2.name.value + ": " + print(e2.value),
  Document: (e2) => hasItems(e2.definitions) ? e2.definitions.map(print).join("\n\n") : "",
  SelectionSet: (e2) => "{\n  " + e2.selections.map(print).join("\n").replace(/\n/g, "\n  ") + "\n}",
  Argument: (e2) => e2.name.value + ": " + print(e2.value),
  FragmentSpread(e2) {
    var r = "..." + e2.name.value;
    if (hasItems(e2.directives)) {
      r += " " + e2.directives.map(y.Directive).join(" ");
    }
    return r;
  },
  InlineFragment(e2) {
    var r = "...";
    if (e2.typeCondition) {
      r += " on " + e2.typeCondition.name.value;
    }
    if (hasItems(e2.directives)) {
      r += " " + e2.directives.map(y.Directive).join(" ");
    }
    return r + " " + print(e2.selectionSet);
  },
  FragmentDefinition(e2) {
    var r = "fragment " + e2.name.value;
    r += " on " + e2.typeCondition.name.value;
    if (hasItems(e2.directives)) {
      r += " " + e2.directives.map(y.Directive).join(" ");
    }
    return r + " " + print(e2.selectionSet);
  },
  Directive(e2) {
    var r = "@" + e2.name.value;
    if (hasItems(e2.arguments)) {
      r += "(" + e2.arguments.map(y.Argument).join(", ") + ")";
    }
    return r;
  },
  NamedType: (e2) => e2.name.value,
  ListType: (e2) => "[" + print(e2.type) + "]",
  NonNullType: (e2) => print(e2.type) + "!"
};
function print(e2) {
  return y[e2.kind] ? y[e2.kind](e2) : "";
}

// node_modules/@urql/core/dist/urql-core-chunk.mjs
var rehydrateGraphQlError = (e2) => {
  if (e2 && e2.message && (e2.extensions || "GraphQLError" === e2.name)) {
    return e2;
  } else if ("object" == typeof e2 && e2.message) {
    return new GraphQLError(e2.message, e2.nodes, e2.source, e2.positions, e2.path, e2, e2.extensions || {});
  } else {
    return new GraphQLError(e2);
  }
};
var CombinedError = class extends Error {
  constructor(r) {
    var e2 = (r.graphQLErrors || []).map(rehydrateGraphQlError);
    var t2 = ((r2, e3) => {
      var t3 = "";
      if (r2) {
        return `[Network] ${r2.message}`;
      }
      if (e3) {
        for (var a2 of e3) {
          if (t3) {
            t3 += "\n";
          }
          t3 += `[GraphQL] ${a2.message}`;
        }
      }
      return t3;
    })(r.networkError, e2);
    super(t2);
    this.name = "CombinedError";
    this.message = t2;
    this.graphQLErrors = e2;
    this.networkError = r.networkError;
    this.response = r.response;
  }
  toString() {
    return this.message;
  }
};
var phash = (r, e2) => {
  var t2 = 0 | (e2 || 5381);
  for (var a2 = 0, o2 = 0 | r.length; a2 < o2; a2++) {
    t2 = (t2 << 5) + t2 + r.charCodeAt(a2);
  }
  return t2;
};
var i2 = /* @__PURE__ */ new Set();
var f2 = /* @__PURE__ */ new WeakMap();
var stringify = (r) => {
  if (null === r || i2.has(r)) {
    return "null";
  } else if ("object" != typeof r) {
    return JSON.stringify(r) || "";
  } else if (r.toJSON) {
    return stringify(r.toJSON());
  } else if (Array.isArray(r)) {
    var e2 = "[";
    for (var t2 of r) {
      if (e2.length > 1) {
        e2 += ",";
      }
      e2 += stringify(t2) || "null";
    }
    return e2 += "]";
  } else if (v2 !== NoopConstructor && r instanceof v2 || l2 !== NoopConstructor && r instanceof l2) {
    return "null";
  }
  var a2 = Object.keys(r).sort();
  if (!a2.length && r.constructor && r.constructor !== Object) {
    var o2 = f2.get(r) || Math.random().toString(36).slice(2);
    f2.set(r, o2);
    return stringify({
      __key: o2
    });
  }
  i2.add(r);
  var n2 = "{";
  for (var s2 of a2) {
    var c3 = stringify(r[s2]);
    if (c3) {
      if (n2.length > 1) {
        n2 += ",";
      }
      n2 += stringify(s2) + ":" + c3;
    }
  }
  i2.delete(r);
  return n2 += "}";
};
var extract = (r, e2, t2) => {
  if (null == t2 || "object" != typeof t2 || t2.toJSON || i2.has(t2)) {
  } else if (Array.isArray(t2)) {
    for (var a2 = 0, o2 = t2.length; a2 < o2; a2++) {
      extract(r, `${e2}.${a2}`, t2[a2]);
    }
  } else if (t2 instanceof v2 || t2 instanceof l2) {
    r.set(e2, t2);
  } else {
    i2.add(t2);
    for (var n2 of Object.keys(t2)) {
      extract(r, `${e2}.${n2}`, t2[n2]);
    }
  }
};
var stringifyVariables = (r) => {
  i2.clear();
  return stringify(r);
};
var NoopConstructor = class {
};
var v2 = "undefined" != typeof File ? File : NoopConstructor;
var l2 = "undefined" != typeof Blob ? Blob : NoopConstructor;
var c2 = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var d2 = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;
var replaceOutsideStrings = (r, e2) => e2 % 2 == 0 ? r.replace(d2, "\n") : r;
var sanitizeDocument = (r) => r.split(c2).map(replaceOutsideStrings).join("").trim();
var p2 = /* @__PURE__ */ new Map();
var u2 = /* @__PURE__ */ new Map();
var stringifyDocument = (r) => {
  var t2;
  if ("string" == typeof r) {
    t2 = sanitizeDocument(r);
  } else if (r.loc && u2.get(r.__key) === r) {
    t2 = r.loc.source.body;
  } else {
    t2 = p2.get(r) || sanitizeDocument(print(r));
    p2.set(r, t2);
  }
  if ("string" != typeof r && !r.loc) {
    r.loc = {
      start: 0,
      end: t2.length,
      source: {
        body: t2,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return t2;
};
var hashDocument = (r) => {
  var e2 = phash(stringifyDocument(r));
  if (r.definitions) {
    var t2 = getOperationName(r);
    if (t2) {
      e2 = phash(`
# ${t2}`, e2);
    }
  }
  return e2;
};
var keyDocument = (r) => {
  var e2;
  var a2;
  if ("string" == typeof r) {
    e2 = hashDocument(r);
    a2 = u2.get(e2) || parse(r, {
      noLocation: true
    });
  } else {
    e2 = r.__key || hashDocument(r);
    a2 = u2.get(e2) || r;
  }
  if (!a2.loc) {
    stringifyDocument(a2);
  }
  a2.__key = e2;
  u2.set(e2, a2);
  return a2;
};
var createRequest = (r, e2, t2) => {
  var a2 = e2 || {};
  var o2 = keyDocument(r);
  var n2 = stringifyVariables(a2);
  var s2 = o2.__key;
  if ("{}" !== n2) {
    s2 = phash(n2, s2);
  }
  return {
    key: s2,
    query: o2,
    variables: a2,
    extensions: t2
  };
};
var getOperationName = (r) => {
  for (var e2 of r.definitions) {
    if (e2.kind === e.OPERATION_DEFINITION) {
      return e2.name ? e2.name.value : void 0;
    }
  }
};
var getOperationType = (r) => {
  for (var e2 of r.definitions) {
    if (e2.kind === e.OPERATION_DEFINITION) {
      return e2.operation;
    }
  }
};
var makeResult = (r, e2, t2) => {
  if (!("data" in e2 || "errors" in e2 && Array.isArray(e2.errors))) {
    throw new Error("No Content");
  }
  var a2 = "subscription" === r.kind;
  return {
    operation: r,
    data: e2.data,
    error: Array.isArray(e2.errors) ? new CombinedError({
      graphQLErrors: e2.errors,
      response: t2
    }) : void 0,
    extensions: e2.extensions ? {
      ...e2.extensions
    } : void 0,
    hasNext: null == e2.hasNext ? a2 : e2.hasNext,
    stale: false
  };
};
var deepMerge = (r, e2) => {
  if ("object" == typeof r && null != r) {
    if (!r.constructor || r.constructor === Object || Array.isArray(r)) {
      r = Array.isArray(r) ? [...r] : {
        ...r
      };
      for (var t2 of Object.keys(e2)) {
        r[t2] = deepMerge(r[t2], e2[t2]);
      }
      return r;
    }
  }
  return e2;
};
var mergeResultPatch = (r, e2, t2, a2) => {
  var o2 = r.error ? r.error.graphQLErrors : [];
  var n2 = !!r.extensions || !!e2.extensions;
  var s2 = {
    ...r.extensions,
    ...e2.extensions
  };
  var i3 = e2.incremental;
  if ("path" in e2) {
    i3 = [e2];
  }
  var f3 = {
    data: r.data
  };
  if (i3) {
    var _loop = function(r2) {
      if (Array.isArray(r2.errors)) {
        o2.push(...r2.errors);
      }
      if (r2.extensions) {
        Object.assign(s2, r2.extensions);
        n2 = true;
      }
      var e3 = "data";
      var t3 = f3;
      var i4 = [];
      if (r2.path) {
        i4 = r2.path;
      } else if (a2) {
        var v4 = a2.find((e4) => e4.id === r2.id);
        if (r2.subPath) {
          i4 = [...v4.path, ...r2.subPath];
        } else {
          i4 = v4.path;
        }
      }
      for (var l3 = 0, c3 = i4.length; l3 < c3; e3 = i4[l3++]) {
        t3 = t3[e3] = Array.isArray(t3[e3]) ? [...t3[e3]] : {
          ...t3[e3]
        };
      }
      if (r2.items) {
        var d3 = +e3 >= 0 ? e3 : 0;
        for (var p3 = 0, u3 = r2.items.length; p3 < u3; p3++) {
          t3[d3 + p3] = deepMerge(t3[d3 + p3], r2.items[p3]);
        }
      } else if (void 0 !== r2.data) {
        t3[e3] = deepMerge(t3[e3], r2.data);
      }
    };
    for (var v3 of i3) {
      _loop(v3);
    }
  } else {
    f3.data = e2.data || r.data;
    o2 = e2.errors || o2;
  }
  return {
    operation: r.operation,
    data: f3.data,
    error: o2.length ? new CombinedError({
      graphQLErrors: o2,
      response: t2
    }) : void 0,
    extensions: n2 ? s2 : void 0,
    hasNext: null != e2.hasNext ? e2.hasNext : r.hasNext,
    stale: false
  };
};
var makeErrorResult = (r, e2, t2) => ({
  operation: r,
  data: void 0,
  error: new CombinedError({
    networkError: e2,
    response: t2
  }),
  extensions: void 0,
  hasNext: false,
  stale: false
});
function makeFetchBody(r) {
  return {
    query: r.extensions && r.extensions.persistedQuery && !r.extensions.persistedQuery.miss ? void 0 : stringifyDocument(r.query),
    operationName: getOperationName(r.query),
    variables: r.variables || void 0,
    extensions: r.extensions
  };
}
var makeFetchURL = (r, e2) => {
  var t2 = "query" === r.kind && r.context.preferGetMethod;
  if (!t2 || !e2) {
    return r.context.url;
  }
  var a2 = new URL(r.context.url);
  for (var o2 in e2) {
    var n2 = e2[o2];
    if (n2) {
      a2.searchParams.set(o2, "object" == typeof n2 ? stringifyVariables(n2) : n2);
    }
  }
  var s2 = a2.toString();
  if (s2.length > 2047 && "force" !== t2) {
    r.context.preferGetMethod = false;
    return r.context.url;
  }
  return s2;
};
var serializeBody = (r, e2) => {
  if (e2 && !("query" === r.kind && !!r.context.preferGetMethod)) {
    var t2 = stringifyVariables(e2);
    var a2 = ((r2) => {
      var e3 = /* @__PURE__ */ new Map();
      if (v2 !== NoopConstructor || l2 !== NoopConstructor) {
        i2.clear();
        extract(e3, "variables", r2);
      }
      return e3;
    })(e2.variables);
    if (a2.size) {
      var o2 = new FormData();
      o2.append("operations", t2);
      o2.append("map", stringifyVariables({
        ...[...a2.keys()].map((r2) => [r2])
      }));
      var n2 = 0;
      for (var s2 of a2.values()) {
        o2.append("" + n2++, s2);
      }
      return o2;
    }
    return t2;
  }
};
var makeFetchOptions = (r, e2) => {
  var t2 = {
    accept: "subscription" === r.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a2 = ("function" == typeof r.context.fetchOptions ? r.context.fetchOptions() : r.context.fetchOptions) || {};
  if (a2.headers) {
    for (var o2 in a2.headers) {
      t2[o2.toLowerCase()] = a2.headers[o2];
    }
  }
  var n2 = serializeBody(r, e2);
  if ("string" == typeof n2 && !t2["content-type"]) {
    t2["content-type"] = "application/json";
  }
  return {
    ...a2,
    method: n2 ? "POST" : "GET",
    body: n2,
    headers: t2
  };
};
var h = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
var y2 = /boundary="?([^=";]+)"?/i;
var x = /data: ?([^\n]+)/;
var toString = (r) => "Buffer" === r.constructor.name ? r.toString() : h.decode(r);
async function* streamBody(r) {
  if (r.body[Symbol.asyncIterator]) {
    for await (var e2 of r.body) {
      yield toString(e2);
    }
  } else {
    var t2 = r.body.getReader();
    var a2;
    try {
      while (!(a2 = await t2.read()).done) {
        yield toString(a2.value);
      }
    } finally {
      t2.cancel();
    }
  }
}
async function* split(r, e2) {
  var t2 = "";
  var a2;
  for await (var o2 of r) {
    t2 += o2;
    while ((a2 = t2.indexOf(e2)) > -1) {
      yield t2.slice(0, a2);
      t2 = t2.slice(a2 + e2.length);
    }
  }
}
async function* fetchOperation(r, e2, t2) {
  var a2 = true;
  var o2 = null;
  var n2;
  try {
    yield await Promise.resolve();
    var s2 = (n2 = await (r.context.fetch || fetch)(e2, t2)).headers.get("Content-Type") || "";
    var i3;
    if (/multipart\/mixed/i.test(s2)) {
      i3 = async function* parseMultipartMixed(r2, e3) {
        var t3 = r2.match(y2);
        var a3 = "--" + (t3 ? t3[1] : "-");
        var o3 = true;
        var n3;
        for await (var s3 of split(streamBody(e3), "\r\n" + a3)) {
          if (o3) {
            o3 = false;
            var i4 = s3.indexOf(a3);
            if (i4 > -1) {
              s3 = s3.slice(i4 + a3.length);
            } else {
              continue;
            }
          }
          try {
            yield n3 = JSON.parse(s3.slice(s3.indexOf("\r\n\r\n") + 4));
          } catch (r3) {
            if (!n3) {
              throw r3;
            }
          }
          if (n3 && false === n3.hasNext) {
            break;
          }
        }
        if (n3 && false !== n3.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(s2, n2);
    } else if (/text\/event-stream/i.test(s2)) {
      i3 = async function* parseEventStream(r2) {
        var e3;
        for await (var t3 of split(streamBody(r2), "\n\n")) {
          var a3 = t3.match(x);
          if (a3) {
            var o3 = a3[1];
            try {
              yield e3 = JSON.parse(o3);
            } catch (r3) {
              if (!e3) {
                throw r3;
              }
            }
            if (e3 && false === e3.hasNext) {
              break;
            }
          }
        }
        if (e3 && false !== e3.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(n2);
    } else if (!/text\//i.test(s2)) {
      i3 = async function* parseJSON(r2) {
        yield JSON.parse(await r2.text());
      }(n2);
    } else {
      throw new Error(await n2.text());
    }
    var f3;
    for await (var v3 of i3) {
      if (v3.pending && !o2) {
        f3 = v3.pending;
      } else if (v3.pending) {
        f3 = [...f3, ...v3.pending];
      }
      o2 = o2 ? mergeResultPatch(o2, v3, n2, f3) : makeResult(r, v3, n2);
      a2 = false;
      yield o2;
      a2 = true;
    }
    if (!o2) {
      yield o2 = makeResult(r, {}, n2);
    }
  } catch (e3) {
    if (!a2) {
      throw e3;
    }
    yield makeErrorResult(r, n2 && (n2.status < 200 || n2.status >= 300) && n2.statusText ? new Error(n2.statusText) : e3, n2);
  }
}
function makeFetchSource(r, e2, t2) {
  var a2;
  if ("undefined" != typeof AbortController) {
    t2.signal = (a2 = new AbortController()).signal;
  }
  return onEnd(() => {
    if (a2) {
      a2.abort();
    }
  })(filter((r2) => !!r2)(fromAsyncIterable(fetchOperation(r, e2, t2))));
}

// node_modules/@urql/core/dist/urql-core.mjs
var collectTypes = (e2, r) => {
  if (Array.isArray(e2)) {
    for (var t2 of e2) {
      collectTypes(t2, r);
    }
  } else if ("object" == typeof e2 && null !== e2) {
    for (var n2 in e2) {
      if ("__typename" === n2 && "string" == typeof e2[n2]) {
        r.add(e2[n2]);
      } else {
        collectTypes(e2[n2], r);
      }
    }
  }
  return r;
};
var formatNode = (r) => {
  if ("definitions" in r) {
    var t2 = [];
    for (var n2 of r.definitions) {
      var a2 = formatNode(n2);
      t2.push(a2);
    }
    return {
      ...r,
      definitions: t2
    };
  }
  if ("directives" in r && r.directives && r.directives.length) {
    var o2 = [];
    var i3 = {};
    for (var s2 of r.directives) {
      var c3 = s2.name.value;
      if ("_" !== c3[0]) {
        o2.push(s2);
      } else {
        c3 = c3.slice(1);
      }
      i3[c3] = s2;
    }
    r = {
      ...r,
      directives: o2,
      _directives: i3
    };
  }
  if ("selectionSet" in r) {
    var u3 = [];
    var p3 = r.kind === e.OPERATION_DEFINITION;
    if (r.selectionSet) {
      for (var d3 of r.selectionSet.selections || []) {
        p3 = p3 || d3.kind === e.FIELD && "__typename" === d3.name.value && !d3.alias;
        var v3 = formatNode(d3);
        u3.push(v3);
      }
      if (!p3) {
        u3.push({
          kind: e.FIELD,
          name: {
            kind: e.NAME,
            value: "__typename"
          },
          _generated: true
        });
      }
      return {
        ...r,
        selectionSet: {
          ...r.selectionSet,
          selections: u3
        }
      };
    }
  }
  return r;
};
var I = /* @__PURE__ */ new Map();
var formatDocument = (e2) => {
  var t2 = keyDocument(e2);
  var n2 = I.get(t2.__key);
  if (!n2) {
    I.set(t2.__key, n2 = formatNode(t2));
    Object.defineProperty(n2, "__key", {
      value: t2.__key,
      enumerable: false
    });
  }
  return n2;
};
var maskTypename = (e2, r) => {
  if (!e2 || "object" != typeof e2) {
    return e2;
  } else if (Array.isArray(e2)) {
    return e2.map((e3) => maskTypename(e3));
  } else if (e2 && "object" == typeof e2 && (r || "__typename" in e2)) {
    var t2 = {};
    for (var n2 in e2) {
      if ("__typename" === n2) {
        Object.defineProperty(t2, "__typename", {
          enumerable: false,
          value: e2.__typename
        });
      } else {
        t2[n2] = maskTypename(e2[n2]);
      }
    }
    return t2;
  } else {
    return e2;
  }
};
function withPromise(e2) {
  var source$ = (r) => e2(r);
  source$.toPromise = () => toPromise(take(1)(filter((e3) => !e3.stale && !e3.hasNext)(source$)));
  source$.then = (e3, r) => source$.toPromise().then(e3, r);
  source$.subscribe = (e3) => subscribe(e3)(source$);
  return source$;
}
function makeOperation(e2, r, t2) {
  return {
    ...r,
    kind: e2,
    context: r.context ? {
      ...r.context,
      ...t2
    } : t2 || r.context
  };
}
var addMetadata = (e2, r) => makeOperation(e2.kind, e2, {
  meta: {
    ...e2.context.meta,
    ...r
  }
});
var noop = () => {
};
function gql(n2) {
  var a2 = /* @__PURE__ */ new Map();
  var o2 = [];
  var i3 = [];
  var s2 = Array.isArray(n2) ? n2[0] : n2 || "";
  for (var c3 = 1; c3 < arguments.length; c3++) {
    var u3 = arguments[c3];
    if (u3 && u3.definitions) {
      i3.push(u3);
    } else {
      s2 += u3;
    }
    s2 += arguments[0][c3];
  }
  i3.unshift(keyDocument(s2));
  for (var p3 of i3) {
    for (var d3 of p3.definitions) {
      if (d3.kind === e.FRAGMENT_DEFINITION) {
        var v3 = d3.name.value;
        var f3 = stringifyDocument(d3);
        if (!a2.has(v3)) {
          a2.set(v3, f3);
          o2.push(d3);
        } else if (a2.get(v3) !== f3) {
          console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + v3 + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
        }
      } else {
        o2.push(d3);
      }
    }
  }
  return keyDocument({
    kind: e.DOCUMENT,
    definitions: o2
  });
}
var shouldSkip = ({ kind: e2 }) => "mutation" !== e2 && "query" !== e2;
var mapTypeNames = (e2) => {
  var r = formatDocument(e2.query);
  if (r !== e2.query) {
    var t2 = makeOperation(e2.kind, e2);
    t2.query = r;
    return t2;
  } else {
    return e2;
  }
};
var cacheExchange = ({ forward: e2, client: r, dispatchDebug: t2 }) => {
  var n2 = /* @__PURE__ */ new Map();
  var a2 = /* @__PURE__ */ new Map();
  var isOperationCached = (e3) => "query" === e3.kind && "network-only" !== e3.context.requestPolicy && ("cache-only" === e3.context.requestPolicy || n2.has(e3.key));
  return (o2) => {
    var i3 = map((e3) => {
      var a3 = n2.get(e3.key);
      t2({
        operation: e3,
        ...a3 ? {
          type: "cacheHit",
          message: "The result was successfully retried from the cache"
        } : {
          type: "cacheMiss",
          message: "The result could not be retrieved from the cache"
        },
        source: "cacheExchange"
      });
      var o3 = a3;
      if (true) {
        o3 = {
          ...o3,
          operation: true ? addMetadata(e3, {
            cacheOutcome: a3 ? "hit" : "miss"
          }) : e3
        };
      }
      if ("cache-and-network" === e3.context.requestPolicy) {
        o3.stale = true;
        reexecuteOperation(r, e3);
      }
      return o3;
    })(filter((e3) => !shouldSkip(e3) && isOperationCached(e3))(o2));
    var s2 = onPush((e3) => {
      var { operation: o3 } = e3;
      if (!o3) {
        return;
      }
      var i4 = o3.context.additionalTypenames || [];
      if ("subscription" !== e3.operation.kind) {
        i4 = ((e4) => [...collectTypes(e4, /* @__PURE__ */ new Set())])(e3.data).concat(i4);
      }
      if ("mutation" === e3.operation.kind || "subscription" === e3.operation.kind) {
        var s3 = /* @__PURE__ */ new Set();
        t2({
          type: "cacheInvalidation",
          message: `The following typenames have been invalidated: ${i4}`,
          operation: o3,
          data: {
            typenames: i4,
            response: e3
          },
          source: "cacheExchange"
        });
        for (var c3 = 0; c3 < i4.length; c3++) {
          var u3 = i4[c3];
          var p3 = a2.get(u3);
          if (!p3) {
            a2.set(u3, p3 = /* @__PURE__ */ new Set());
          }
          for (var d3 of p3.values()) {
            s3.add(d3);
          }
          p3.clear();
        }
        for (var v3 of s3.values()) {
          if (n2.has(v3)) {
            o3 = n2.get(v3).operation;
            n2.delete(v3);
            reexecuteOperation(r, o3);
          }
        }
      } else if ("query" === o3.kind && e3.data) {
        n2.set(o3.key, e3);
        for (var f3 = 0; f3 < i4.length; f3++) {
          var l3 = i4[f3];
          var h2 = a2.get(l3);
          if (!h2) {
            a2.set(l3, h2 = /* @__PURE__ */ new Set());
          }
          h2.add(o3.key);
        }
      }
    })(e2(filter((e3) => "query" !== e3.kind || "cache-only" !== e3.context.requestPolicy)(map((e3) => true ? addMetadata(e3, {
      cacheOutcome: "miss"
    }) : e3)(merge([map(mapTypeNames)(filter((e3) => !shouldSkip(e3) && !isOperationCached(e3))(o2)), filter((e3) => shouldSkip(e3))(o2)])))));
    return merge([i3, s2]);
  };
};
var reexecuteOperation = (e2, r) => e2.reexecuteOperation(makeOperation(r.kind, r, {
  requestPolicy: "network-only"
}));
var T = /* @__PURE__ */ new Set();
var ssrExchange = (e2 = {}) => {
  var r = !!e2.staleWhileRevalidate;
  var t2 = !!e2.includeExtensions;
  var a2 = {};
  var o2 = [];
  var invalidate = (e3) => {
    o2.push(e3.operation.key);
    if (1 === o2.length) {
      Promise.resolve().then(() => {
        var e4;
        while (e4 = o2.shift()) {
          a2[e4] = null;
        }
      });
    }
  };
  var ssr = ({ client: o3, forward: i3 }) => (s2) => {
    var c3 = e2 && "boolean" == typeof e2.isClient ? !!e2.isClient : !o3.suspense;
    var u3 = i3(map(mapTypeNames)(filter((e3) => "teardown" === e3.kind || !a2[e3.key] || !!a2[e3.key].hasNext || "network-only" === e3.context.requestPolicy)(s2)));
    var p3 = map((e3) => {
      var i4 = ((e4, r2, t3) => ({
        operation: e4,
        data: r2.data ? JSON.parse(r2.data) : void 0,
        extensions: t3 && r2.extensions ? JSON.parse(r2.extensions) : void 0,
        error: r2.error ? new CombinedError({
          networkError: r2.error.networkError ? new Error(r2.error.networkError) : void 0,
          graphQLErrors: r2.error.graphQLErrors
        }) : void 0,
        stale: false,
        hasNext: !!r2.hasNext
      }))(e3, a2[e3.key], t2);
      if (r && !T.has(e3.key)) {
        i4.stale = true;
        T.add(e3.key);
        reexecuteOperation(o3, e3);
      }
      return {
        ...i4,
        operation: true ? addMetadata(e3, {
          cacheOutcome: "hit"
        }) : e3
      };
    })(filter((e3) => "teardown" !== e3.kind && !!a2[e3.key] && "network-only" !== e3.context.requestPolicy)(s2));
    if (!c3) {
      u3 = onPush((e3) => {
        var { operation: r2 } = e3;
        if ("mutation" !== r2.kind) {
          var n2 = ((e4, r3) => {
            var t3 = {
              data: JSON.stringify(e4.data),
              hasNext: e4.hasNext
            };
            if (void 0 !== e4.data) {
              t3.data = JSON.stringify(e4.data);
            }
            if (r3 && void 0 !== e4.extensions) {
              t3.extensions = JSON.stringify(e4.extensions);
            }
            if (e4.error) {
              t3.error = {
                graphQLErrors: e4.error.graphQLErrors.map((e5) => {
                  if (!e5.path && !e5.extensions) {
                    return e5.message;
                  }
                  return {
                    message: e5.message,
                    path: e5.path,
                    extensions: e5.extensions
                  };
                })
              };
              if (e4.error.networkError) {
                t3.error.networkError = "" + e4.error.networkError;
              }
            }
            return t3;
          })(e3, t2);
          a2[r2.key] = n2;
        }
      })(u3);
    } else {
      p3 = onPush(invalidate)(p3);
    }
    return merge([u3, p3]);
  };
  ssr.restoreData = (e3) => {
    for (var r2 in e3) {
      if (null !== a2[r2]) {
        a2[r2] = e3[r2];
      }
    }
  };
  ssr.extractData = () => {
    var e3 = {};
    for (var r2 in a2) {
      if (null != a2[r2]) {
        e3[r2] = a2[r2];
      }
    }
    return e3;
  };
  if (e2 && e2.initialState) {
    ssr.restoreData(e2.initialState);
  }
  return ssr;
};
var subscriptionExchange = ({ forwardSubscription: e2, enableAllOperations: r, isSubscriptionOperation: t2 }) => ({ client: n2, forward: i3 }) => {
  var u3 = t2 || ((e3) => "subscription" === e3.kind || !!r && ("query" === e3.kind || "mutation" === e3.kind));
  return (r2) => {
    var t3 = mergeMap((t4) => {
      var { key: i4 } = t4;
      var u4 = filter((e3) => "teardown" === e3.kind && e3.key === i4)(r2);
      return takeUntil(u4)(((r3) => {
        var t5 = e2(makeFetchBody(r3), r3);
        return make((e3) => {
          var a2 = false;
          var i5;
          var u5;
          function nextResult(t6) {
            e3.next(u5 = u5 ? mergeResultPatch(u5, t6) : makeResult(r3, t6));
          }
          Promise.resolve().then(() => {
            if (a2) {
              return;
            }
            i5 = t5.subscribe({
              next: nextResult,
              error(t6) {
                if (Array.isArray(t6)) {
                  nextResult({
                    errors: t6
                  });
                } else {
                  e3.next(makeErrorResult(r3, t6));
                }
                e3.complete();
              },
              complete() {
                if (!a2) {
                  a2 = true;
                  if ("subscription" === r3.kind) {
                    n2.reexecuteOperation(makeOperation("teardown", r3, r3.context));
                  }
                  if (u5 && u5.hasNext) {
                    nextResult({
                      hasNext: false
                    });
                  }
                  e3.complete();
                }
              }
            });
          });
          return () => {
            a2 = true;
            if (i5) {
              i5.unsubscribe();
            }
          };
        });
      })(t4));
    })(filter((e3) => "teardown" !== e3.kind && u3(e3))(r2));
    var p3 = i3(filter((e3) => "teardown" === e3.kind || !u3(e3))(r2));
    return merge([t3, p3]);
  };
};
var debugExchange = ({ forward: e2 }) => {
  if (false) {
    return (r) => e2(r);
  } else {
    return (r) => onPush((e3) => console.log("[Exchange debug]: Completed operation: ", e3))(e2(onPush((e3) => console.log("[Exchange debug]: Incoming operation: ", e3))(r)));
  }
};
var dedupExchange = ({ forward: e2 }) => (r) => e2(r);
var fetchExchange = ({ forward: e2, dispatchDebug: r }) => (t2) => {
  var n2 = mergeMap((e3) => {
    var n3 = makeFetchBody(e3);
    var o3 = makeFetchURL(e3, n3);
    var i3 = makeFetchOptions(e3, n3);
    r({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e3,
      data: {
        url: o3,
        fetchOptions: i3
      },
      source: "fetchExchange"
    });
    var s2 = takeUntil(filter((r2) => "teardown" === r2.kind && r2.key === e3.key)(t2))(makeFetchSource(e3, o3, i3));
    if (true) {
      return onPush((t3) => {
        var n4 = !t3.data ? t3.error : void 0;
        r({
          type: n4 ? "fetchError" : "fetchSuccess",
          message: `A ${n4 ? "failed" : "successful"} fetch response has been returned.`,
          operation: e3,
          data: {
            url: o3,
            fetchOptions: i3,
            value: n4 || t3
          },
          source: "fetchExchange"
        });
      })(s2);
    }
    return s2;
  })(filter((e3) => "teardown" !== e3.kind && ("subscription" !== e3.kind || !!e3.context.fetchSubscriptions))(t2));
  var o2 = e2(filter((e3) => "teardown" === e3.kind || "subscription" === e3.kind && !e3.context.fetchSubscriptions)(t2));
  return merge([n2, o2]);
};
var composeExchanges = (e2) => ({ client: r, forward: t2, dispatchDebug: n2 }) => e2.reduceRight((e3, t3) => {
  var a2 = false;
  return t3({
    client: r,
    forward(r2) {
      if (true) {
        if (a2) {
          throw new Error("forward() must only be called once in each Exchange.");
        }
        a2 = true;
      }
      return share(e3(share(r2)));
    },
    dispatchDebug(e4) {
      n2({
        timestamp: Date.now(),
        source: t3.name,
        ...e4
      });
    }
  });
}, t2);
var mapExchange = ({ onOperation: e2, onResult: r, onError: t2 }) => ({ forward: n2 }) => (a2) => mergeMap((e3) => {
  if (t2 && e3.error) {
    t2(e3.error, e3.operation);
  }
  var n3 = r && r(e3) || e3;
  return "then" in n3 ? fromPromise(n3) : fromValue(n3);
})(n2(mergeMap((r2) => {
  var t3 = e2 && e2(r2) || r2;
  return "then" in t3 ? fromPromise(t3) : fromValue(t3);
})(a2)));
var fallbackExchange = ({ dispatchDebug: e2 }) => (r) => {
  if (true) {
    r = onPush((r2) => {
      if ("teardown" !== r2.kind && true) {
        var t2 = `No exchange has handled operations of kind "${r2.kind}". Check whether you've added an exchange responsible for these operations.`;
        e2({
          type: "fallbackCatch",
          message: t2,
          operation: r2,
          source: "fallbackExchange"
        });
        console.warn(t2);
      }
    })(r);
  }
  return filter((e3) => false)(r);
};
var C = function Client(e2) {
  if (!e2.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = 0;
  var t2 = /* @__PURE__ */ new Map();
  var n2 = /* @__PURE__ */ new Map();
  var a2 = /* @__PURE__ */ new Set();
  var o2 = [];
  var i3 = {
    url: e2.url,
    fetchSubscriptions: e2.fetchSubscriptions,
    fetchOptions: e2.fetchOptions,
    fetch: e2.fetch,
    preferGetMethod: e2.preferGetMethod,
    requestPolicy: e2.requestPolicy || "cache-first"
  };
  var s2 = makeSubject();
  function nextOperation(e3) {
    if ("mutation" === e3.kind || "teardown" === e3.kind || !a2.has(e3.key)) {
      if ("teardown" === e3.kind) {
        a2.delete(e3.key);
      } else if ("mutation" !== e3.kind) {
        a2.add(e3.key);
      }
      s2.next(e3);
    }
  }
  var c3 = false;
  function dispatchOperation(e3) {
    if (e3) {
      nextOperation(e3);
    }
    if (!c3) {
      c3 = true;
      while (c3 && (e3 = o2.shift())) {
        nextOperation(e3);
      }
      c3 = false;
    }
  }
  var makeResultSource = (r2) => {
    var i4 = takeUntil(filter((e3) => "teardown" === e3.kind && e3.key === r2.key)(s2.source))(filter((e3) => e3.operation.kind === r2.kind && e3.operation.key === r2.key && (!e3.operation.context._instance || e3.operation.context._instance === r2.context._instance))(O));
    if (e2.maskTypename) {
      i4 = map((e3) => ({
        ...e3,
        data: maskTypename(e3.data, true)
      }))(i4);
    }
    if ("query" !== r2.kind) {
      i4 = takeWhile((e3) => !!e3.hasNext, true)(i4);
    } else {
      i4 = switchMap((e3) => {
        var t3 = fromValue(e3);
        return e3.stale || e3.hasNext ? t3 : merge([t3, map(() => {
          e3.stale = true;
          return e3;
        })(take(1)(filter((e4) => e4.key === r2.key)(s2.source)))]);
      })(i4);
    }
    if ("mutation" !== r2.kind) {
      i4 = onEnd(() => {
        a2.delete(r2.key);
        t2.delete(r2.key);
        n2.delete(r2.key);
        c3 = false;
        for (var e3 = o2.length - 1; e3 >= 0; e3--) {
          if (o2[e3].key === r2.key) {
            o2.splice(e3, 1);
          }
        }
        nextOperation(makeOperation("teardown", r2, r2.context));
      })(onPush((e3) => {
        if (e3.stale) {
          for (var n3 of o2) {
            if (n3.key === e3.operation.key) {
              a2.delete(n3.key);
              break;
            }
          }
        } else if (!e3.hasNext) {
          a2.delete(r2.key);
        }
        t2.set(r2.key, e3);
      })(i4));
    } else {
      i4 = onStart(() => {
        nextOperation(r2);
      })(i4);
    }
    return share(i4);
  };
  var u3 = this instanceof Client ? this : Object.create(Client.prototype);
  var p3 = Object.assign(u3, {
    suspense: !!e2.suspense,
    operations$: s2.source,
    reexecuteOperation(e3) {
      if ("teardown" === e3.kind) {
        dispatchOperation(e3);
      } else if ("mutation" === e3.kind || n2.has(e3.key)) {
        var r2 = false;
        for (var t3 = 0; t3 < o2.length; t3++) {
          r2 = r2 || o2[t3].key === e3.key;
        }
        if (!r2) {
          a2.delete(e3.key);
        }
        o2.push(e3);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e3, t3, n3) {
      if (!n3) {
        n3 = {};
      }
      var a3;
      if ("teardown" !== e3 && (a3 = getOperationType(t3.query)) !== e3) {
        throw new Error(`Expected operation of type "${e3}" but found "${a3}"`);
      }
      return makeOperation(e3, t3, {
        _instance: "mutation" === e3 ? r = r + 1 | 0 : void 0,
        ...i3,
        ...n3,
        requestPolicy: n3.requestPolicy || i3.requestPolicy,
        suspense: n3.suspense || false !== n3.suspense && p3.suspense
      });
    },
    executeRequestOperation(e3) {
      if ("mutation" === e3.kind) {
        return withPromise(makeResultSource(e3));
      }
      return withPromise(lazy(() => {
        var r2 = n2.get(e3.key);
        if (!r2) {
          n2.set(e3.key, r2 = makeResultSource(e3));
        }
        r2 = onStart(() => {
          dispatchOperation(e3);
        })(r2);
        var a3 = t2.get(e3.key);
        if ("query" === e3.kind && a3 && (a3.stale || a3.hasNext)) {
          return switchMap(fromValue)(merge([r2, filter((r3) => r3 === t2.get(e3.key))(fromValue(a3))]));
        } else {
          return r2;
        }
      }));
    },
    executeQuery(e3, r2) {
      var t3 = p3.createRequestOperation("query", e3, r2);
      return p3.executeRequestOperation(t3);
    },
    executeSubscription(e3, r2) {
      var t3 = p3.createRequestOperation("subscription", e3, r2);
      return p3.executeRequestOperation(t3);
    },
    executeMutation(e3, r2) {
      var t3 = p3.createRequestOperation("mutation", e3, r2);
      return p3.executeRequestOperation(t3);
    },
    readQuery(e3, r2, t3) {
      var n3 = null;
      subscribe((e4) => {
        n3 = e4;
      })(p3.query(e3, r2, t3)).unsubscribe();
      return n3;
    },
    query: (e3, r2, t3) => p3.executeQuery(createRequest(e3, r2), t3),
    subscription: (e3, r2, t3) => p3.executeSubscription(createRequest(e3, r2), t3),
    mutation: (e3, r2, t3) => p3.executeMutation(createRequest(e3, r2), t3)
  });
  var d3 = noop;
  if (true) {
    var { next: l3, source: x2 } = makeSubject();
    p3.subscribeToDebugTarget = (e3) => subscribe(e3)(x2);
    d3 = l3;
  }
  var g2 = composeExchanges(e2.exchanges);
  var O = share(g2({
    client: p3,
    dispatchDebug: d3,
    forward: fallbackExchange({
      dispatchDebug: d3
    })
  })(s2.source));
  publish(O);
  return p3;
};
var j = C;
export {
  C as Client,
  CombinedError,
  cacheExchange,
  composeExchanges,
  j as createClient,
  createRequest,
  debugExchange,
  dedupExchange,
  mapExchange as errorExchange,
  fetchExchange,
  formatDocument,
  gql,
  makeErrorResult,
  makeOperation,
  makeResult,
  mapExchange,
  maskTypename,
  mergeResultPatch,
  ssrExchange,
  stringifyDocument,
  stringifyVariables,
  subscriptionExchange
};
//# sourceMappingURL=@urql_core.js.map
