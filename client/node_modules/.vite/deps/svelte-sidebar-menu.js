import "./chunk-WQQVIIUG.js";
import {
  blur,
  fade,
  fly,
  slide
} from "./chunk-3DWSXXVD.js";
import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-KWPW4BHN.js";
import "./chunk-VFRMSNTO.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-2DLG6624.js";
import "./chunk-CUKRBFMN.js";
import "./chunk-2B2CG5KL.js";

// node_modules/svelte-sidebar-menu/sidebarStore.js
var sidebarOpen = writable(false);
var sidebarIsInert = writable(true);
var sidebarStayOpen = writable(false);

// node_modules/svelte-sidebar-menu/Aside.svelte
var file = "node_modules/svelte-sidebar-menu/Aside.svelte";
function add_css(target) {
  append_styles(target, "svelte-ox6pxq", ".close.svelte-ox6pxq.svelte-ox6pxq{left:-100%}.open.svelte-ox6pxq.svelte-ox6pxq{left:0}[inert].svelte-ox6pxq.svelte-ox6pxq{pointer-events:none;cursor:default}[inert].svelte-ox6pxq.svelte-ox6pxq,[inert].svelte-ox6pxq .svelte-ox6pxq{opacity:0.5;pointer-events:none;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXNpZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1DQyxrQ0FBTyxDQUNOLElBQUksQ0FBRSxLQUNQLENBQ0EsaUNBQU0sQ0FDTCxJQUFJLENBQUUsQ0FDUCxDQUNBLENBQUMsS0FBSyw2QkFBRSxDQUNQLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLE1BQU0sQ0FBRSxPQUNULENBRUEsQ0FBQyxLQUFLLDZCQUFDLENBQ1AsQ0FBQyxLQUFLLGVBQUMsQ0FBQyxjQUFFLENBQ1QsT0FBTyxDQUFFLEdBQUcsQ0FDWixjQUFjLENBQUUsSUFBSSxDQUNwQixNQUFNLENBQUUsT0FBTyxDQUNmLG1CQUFtQixDQUFFLElBQUksQ0FDdEIsZ0JBQWdCLENBQUUsSUFBSSxDQUNyQixlQUFlLENBQUUsSUFBSSxDQUNqQixXQUFXLENBQUUsSUFDdEIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQXNpZGUuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let aside;
  let aside_class_value;
  let aside_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true, "aria-hidden": true });
      var aside_nodes = children(aside);
      if (default_slot)
        default_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "class", aside_class_value = /*asideClass*/
      ctx[1] + " " + /*$$props*/
      (ctx[6].class ? (
        /*$$props*/
        ctx[6].class
      ) : "") + " svelte-ox6pxq");
      attr_dev(
        aside,
        "aria-hidden",
        /*ariaHidden*/
        ctx[4]
      );
      aside.inert = /*inert*/
      ctx[2];
      add_location(aside, file, 24, 1, 760);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (default_slot) {
        default_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*asideClass, $$props*/
      66 && aside_class_value !== (aside_class_value = /*asideClass*/
      ctx[1] + " " + /*$$props*/
      (ctx[6].class ? (
        /*$$props*/
        ctx[6].class
      ) : "") + " svelte-ox6pxq")) {
        attr_dev(aside, "class", aside_class_value);
      }
      if (!current || dirty & /*inert*/
      4) {
        prop_dev(
          aside,
          "inert",
          /*inert*/
          ctx[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!aside_transition)
            aside_transition = create_bidirectional_transition(
              aside,
              /*multiple*/
              ctx[5],
              /*transitionParams*/
              ctx[0],
              true
            );
          aside_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!aside_transition)
          aside_transition = create_bidirectional_transition(
            aside,
            /*multiple*/
            ctx[5],
            /*transitionParams*/
            ctx[0],
            false
          );
        aside_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && aside_transition)
        aside_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:0) {#if $sidebarOpen}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$sidebarOpen*/
    ctx[3] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$sidebarOpen*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$sidebarOpen*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $sidebarIsInert;
  let $sidebarOpen;
  validate_store(sidebarIsInert, "sidebarIsInert");
  component_subscribe($$self, sidebarIsInert, ($$value) => $$invalidate(8, $sidebarIsInert = $$value));
  validate_store(sidebarOpen, "sidebarOpen");
  component_subscribe($$self, sidebarOpen, ($$value) => $$invalidate(3, $sidebarOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Aside", slots, ["default"]);
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  let { asideClass = "absolute w-auto h-screen bg-gray-200 border-r-2 shadow-lg" } = $$props;
  let inert = null;
  let ariaHidden;
  function multiple(node, params) {
    switch (transitionType) {
      case "slide":
        return slide(node, params);
      case "blur":
        return blur(node, params);
      case "fly":
        return fly(node, params);
      case "fade":
        return fade(node, params);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("transitionParams" in $$new_props)
      $$invalidate(0, transitionParams = $$new_props.transitionParams);
    if ("transitionType" in $$new_props)
      $$invalidate(7, transitionType = $$new_props.transitionType);
    if ("asideClass" in $$new_props)
      $$invalidate(1, asideClass = $$new_props.asideClass);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    fly,
    slide,
    blur,
    fade,
    transitionParams,
    transitionType,
    asideClass,
    inert,
    ariaHidden,
    multiple,
    $sidebarIsInert,
    $sidebarOpen
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("transitionParams" in $$props)
      $$invalidate(0, transitionParams = $$new_props.transitionParams);
    if ("transitionType" in $$props)
      $$invalidate(7, transitionType = $$new_props.transitionType);
    if ("asideClass" in $$props)
      $$invalidate(1, asideClass = $$new_props.asideClass);
    if ("inert" in $$props)
      $$invalidate(2, inert = $$new_props.inert);
    if ("ariaHidden" in $$props)
      $$invalidate(4, ariaHidden = $$new_props.ariaHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$sidebarIsInert*/
    256) {
      $:
        $$invalidate(2, inert = $sidebarIsInert ? "inert" : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    transitionParams,
    asideClass,
    inert,
    $sidebarOpen,
    ariaHidden,
    multiple,
    $$props,
    transitionType,
    $sidebarIsInert,
    $$scope,
    slots
  ];
}
var Aside = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        transitionParams: 0,
        transitionType: 7,
        asideClass: 1
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Aside",
      options,
      id: create_fragment.name
    });
  }
  get transitionParams() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionParams(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionType() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionType(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideClass() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideClass(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Aside_default = Aside;

// node_modules/svelte-sidebar-menu/Nav.svelte
var file2 = "node_modules/svelte-sidebar-menu/Nav.svelte";
function create_fragment2(ctx) {
  let nav;
  let div;
  let nav_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      nav = element("nav");
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*navDivClass*/
        ctx[1]
      );
      add_location(div, file2, 5, 1, 158);
      attr_dev(nav, "class", nav_class_value = /*navClass*/
      ctx[0] + " " + /*$$props*/
      (ctx[2].class ? (
        /*$$props*/
        ctx[2].class
      ) : ""));
      add_location(nav, file2, 4, 0, 95);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*navDivClass*/
      2) {
        attr_dev(
          div,
          "class",
          /*navDivClass*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*navClass, $$props*/
      5 && nav_class_value !== (nav_class_value = /*navClass*/
      ctx2[0] + " " + /*$$props*/
      (ctx2[2].class ? (
        /*$$props*/
        ctx2[2].class
      ) : ""))) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav", slots, ["default"]);
  let { navClass = "py-8 px-4 text-lg" } = $$props;
  let { navDivClass = "pb-8" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("navClass" in $$new_props)
      $$invalidate(0, navClass = $$new_props.navClass);
    if ("navDivClass" in $$new_props)
      $$invalidate(1, navDivClass = $$new_props.navDivClass);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ navClass, navDivClass });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    if ("navClass" in $$props)
      $$invalidate(0, navClass = $$new_props.navClass);
    if ("navDivClass" in $$props)
      $$invalidate(1, navDivClass = $$new_props.navDivClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [navClass, navDivClass, $$props, $$scope, slots];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { navClass: 0, navDivClass: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment2.name
    });
  }
  get navClass() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navDivClass() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navDivClass(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// node_modules/svelte-sidebar-menu/inert.min.js
!function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t() : "function" == typeof define && define.amd ? define("inert", t) : t();
}(0, function() {
  "use strict";
  var u = function() {
    function i(e, t) {
      for (var n = 0; n < t.length; n++) {
        var i2 = t[n];
        i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e, i2.key, i2);
      }
    }
    return function(e, t, n) {
      return t && i(e.prototype, t), n && i(e, n), e;
    };
  }();
  function h(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  !function() {
    if ("undefined" != typeof window) {
      var o = Array.prototype.slice, r = Element.prototype.matches || Element.prototype.msMatchesSelector, i = [
        "a[href]",
        "area[href]",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
        "button:not([disabled])",
        "details",
        "summary",
        "iframe",
        "object",
        "embed",
        "[contenteditable]"
      ].join(","), s = function() {
        function n(e2, t2) {
          h(this, n), this._inertManager = t2, this._rootElement = e2, this._managedNodes = /* @__PURE__ */ new Set(), this._rootElement.hasAttribute("aria-hidden") ? this._savedAriaHidden = this._rootElement.getAttribute("aria-hidden") : this._savedAriaHidden = null, this._rootElement.setAttribute("aria-hidden", "true"), this._makeSubtreeUnfocusable(this._rootElement), this._observer = new MutationObserver(this._onMutation.bind(this)), this._observer.observe(this._rootElement, {
            attributes: true,
            childList: true,
            subtree: true
          });
        }
        return u(n, [
          {
            key: "destructor",
            value: function() {
              this._observer.disconnect(), this._rootElement && (null !== this._savedAriaHidden ? this._rootElement.setAttribute("aria-hidden", this._savedAriaHidden) : this._rootElement.removeAttribute("aria-hidden")), this._managedNodes.forEach(function(e2) {
                this._unmanageNode(e2.node);
              }, this), this._observer = null, this._rootElement = null, this._managedNodes = null, this._inertManager = null;
            }
          },
          {
            key: "_makeSubtreeUnfocusable",
            value: function(e2) {
              var t2 = this;
              l(e2, function(e3) {
                return t2._visitNode(e3);
              });
              var n2 = document.activeElement;
              if (!document.body.contains(e2)) {
                for (var i2 = e2, o2 = void 0; i2; ) {
                  if (i2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    o2 = i2;
                    break;
                  }
                  i2 = i2.parentNode;
                }
                o2 && (n2 = o2.activeElement);
              }
              e2.contains(n2) && (n2.blur(), n2 === document.activeElement && document.body.focus());
            }
          },
          {
            key: "_visitNode",
            value: function(e2) {
              if (e2.nodeType === Node.ELEMENT_NODE) {
                var t2 = e2;
                t2 !== this._rootElement && t2.hasAttribute("inert") && this._adoptInertRoot(t2), (r.call(t2, i) || t2.hasAttribute("tabindex")) && this._manageNode(t2);
              }
            }
          },
          {
            key: "_manageNode",
            value: function(e2) {
              var t2 = this._inertManager.register(e2, this);
              this._managedNodes.add(t2);
            }
          },
          {
            key: "_unmanageNode",
            value: function(e2) {
              var t2 = this._inertManager.deregister(e2, this);
              t2 && this._managedNodes.delete(t2);
            }
          },
          {
            key: "_unmanageSubtree",
            value: function(e2) {
              var t2 = this;
              l(e2, function(e3) {
                return t2._unmanageNode(e3);
              });
            }
          },
          {
            key: "_adoptInertRoot",
            value: function(e2) {
              var t2 = this._inertManager.getInertRoot(e2);
              t2 || (this._inertManager.setInert(e2, true), t2 = this._inertManager.getInertRoot(e2)), t2.managedNodes.forEach(function(e3) {
                this._manageNode(e3.node);
              }, this);
            }
          },
          {
            key: "_onMutation",
            value: function(e2, t2) {
              e2.forEach(function(e3) {
                var t3 = e3.target;
                if ("childList" === e3.type)
                  o.call(e3.addedNodes).forEach(function(e4) {
                    this._makeSubtreeUnfocusable(e4);
                  }, this), o.call(e3.removedNodes).forEach(function(e4) {
                    this._unmanageSubtree(e4);
                  }, this);
                else if ("attributes" === e3.type) {
                  if ("tabindex" === e3.attributeName)
                    this._manageNode(t3);
                  else if (t3 !== this._rootElement && "inert" === e3.attributeName && t3.hasAttribute("inert")) {
                    this._adoptInertRoot(t3);
                    var n2 = this._inertManager.getInertRoot(t3);
                    this._managedNodes.forEach(function(e4) {
                      t3.contains(e4.node) && n2._manageNode(e4.node);
                    });
                  }
                }
              }, this);
            }
          },
          {
            key: "managedNodes",
            get: function() {
              return new Set(this._managedNodes);
            }
          },
          {
            key: "hasSavedAriaHidden",
            get: function() {
              return null !== this._savedAriaHidden;
            }
          },
          {
            key: "savedAriaHidden",
            set: function(e2) {
              this._savedAriaHidden = e2;
            },
            get: function() {
              return this._savedAriaHidden;
            }
          }
        ]), n;
      }(), a = function() {
        function n(e2, t2) {
          h(this, n), this._node = e2, this._overrodeFocusMethod = false, this._inertRoots = /* @__PURE__ */ new Set([t2]), this._savedTabIndex = null, this._destroyed = false, this.ensureUntabbable();
        }
        return u(n, [
          {
            key: "destructor",
            value: function() {
              if (this._throwIfDestroyed(), this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                var e2 = this._node;
                null !== this._savedTabIndex ? e2.setAttribute("tabindex", this._savedTabIndex) : e2.removeAttribute("tabindex"), this._overrodeFocusMethod && delete e2.focus;
              }
              this._node = null, this._inertRoots = null, this._destroyed = true;
            }
          },
          {
            key: "_throwIfDestroyed",
            value: function() {
              if (this.destroyed)
                throw new Error("Trying to access destroyed InertNode");
            }
          },
          {
            key: "ensureUntabbable",
            value: function() {
              if (this.node.nodeType === Node.ELEMENT_NODE) {
                var e2 = this.node;
                if (r.call(e2, i)) {
                  if (-1 === e2.tabIndex && this.hasSavedTabIndex)
                    return;
                  e2.hasAttribute("tabindex") && (this._savedTabIndex = e2.tabIndex), e2.setAttribute("tabindex", "-1"), e2.nodeType === Node.ELEMENT_NODE && (e2.focus = function() {
                  }, this._overrodeFocusMethod = true);
                } else
                  e2.hasAttribute("tabindex") && (this._savedTabIndex = e2.tabIndex, e2.removeAttribute("tabindex"));
              }
            }
          },
          {
            key: "addInertRoot",
            value: function(e2) {
              this._throwIfDestroyed(), this._inertRoots.add(e2);
            }
          },
          {
            key: "removeInertRoot",
            value: function(e2) {
              this._throwIfDestroyed(), this._inertRoots.delete(e2), 0 === this._inertRoots.size && this.destructor();
            }
          },
          {
            key: "destroyed",
            get: function() {
              return this._destroyed;
            }
          },
          {
            key: "hasSavedTabIndex",
            get: function() {
              return null !== this._savedTabIndex;
            }
          },
          {
            key: "node",
            get: function() {
              return this._throwIfDestroyed(), this._node;
            }
          },
          {
            key: "savedTabIndex",
            set: function(e2) {
              this._throwIfDestroyed(), this._savedTabIndex = e2;
            },
            get: function() {
              return this._throwIfDestroyed(), this._savedTabIndex;
            }
          }
        ]), n;
      }(), e = function() {
        function t2(e2) {
          if (h(this, t2), !e2)
            throw new Error("Missing required argument; InertManager needs to wrap a document.");
          this._document = e2, this._managedNodes = /* @__PURE__ */ new Map(), this._inertRoots = /* @__PURE__ */ new Map(), this._observer = new MutationObserver(this._watchForInert.bind(this)), d(e2.head || e2.body || e2.documentElement), "loading" === e2.readyState ? e2.addEventListener("DOMContentLoaded", this._onDocumentLoaded.bind(this)) : this._onDocumentLoaded();
        }
        return u(t2, [
          {
            key: "setInert",
            value: function(e2, t3) {
              if (t3) {
                if (this._inertRoots.has(e2))
                  return;
                var n = new s(e2, this);
                if (e2.setAttribute("inert", ""), this._inertRoots.set(e2, n), !this._document.body.contains(e2))
                  for (var i2 = e2.parentNode; i2; )
                    11 === i2.nodeType && d(i2), i2 = i2.parentNode;
              } else {
                if (!this._inertRoots.has(e2))
                  return;
                this._inertRoots.get(e2).destructor(), this._inertRoots.delete(e2), e2.removeAttribute("inert");
              }
            }
          },
          {
            key: "getInertRoot",
            value: function(e2) {
              return this._inertRoots.get(e2);
            }
          },
          {
            key: "register",
            value: function(e2, t3) {
              var n = this._managedNodes.get(e2);
              return void 0 !== n ? n.addInertRoot(t3) : n = new a(e2, t3), this._managedNodes.set(e2, n), n;
            }
          },
          {
            key: "deregister",
            value: function(e2, t3) {
              var n = this._managedNodes.get(e2);
              return n ? (n.removeInertRoot(t3), n.destroyed && this._managedNodes.delete(e2), n) : null;
            }
          },
          {
            key: "_onDocumentLoaded",
            value: function() {
              o.call(this._document.querySelectorAll("[inert]")).forEach(function(e2) {
                this.setInert(e2, true);
              }, this), this._observer.observe(this._document.body || this._document.documentElement, {
                attributes: true,
                subtree: true,
                childList: true
              });
            }
          },
          {
            key: "_watchForInert",
            value: function(e2, t3) {
              var i2 = this;
              e2.forEach(function(e3) {
                switch (e3.type) {
                  case "childList":
                    o.call(e3.addedNodes).forEach(function(e4) {
                      if (e4.nodeType === Node.ELEMENT_NODE) {
                        var t5 = o.call(e4.querySelectorAll("[inert]"));
                        r.call(e4, "[inert]") && t5.unshift(e4), t5.forEach(function(e5) {
                          this.setInert(e5, true);
                        }, i2);
                      }
                    }, i2);
                    break;
                  case "attributes":
                    if ("inert" !== e3.attributeName)
                      return;
                    var t4 = e3.target, n = t4.hasAttribute("inert");
                    i2.setInert(t4, n);
                }
              }, this);
            }
          }
        ]), t2;
      }();
      if (!Element.prototype.hasOwnProperty("inert")) {
        var t = new e(document);
        Object.defineProperty(Element.prototype, "inert", {
          enumerable: true,
          get: function() {
            return this.hasAttribute("inert");
          },
          set: function(e2) {
            t.setInert(this, e2);
          }
        });
      }
    }
    function l(e2, t2, n) {
      if (e2.nodeType == Node.ELEMENT_NODE) {
        var i2 = e2;
        t2 && t2(i2);
        var o2 = i2.shadowRoot;
        if (o2)
          return void l(o2, t2, o2);
        if ("content" == i2.localName) {
          for (var r2 = i2, s2 = r2.getDistributedNodes ? r2.getDistributedNodes() : [], a2 = 0; a2 < s2.length; a2++)
            l(s2[a2], t2, n);
          return;
        }
        if ("slot" == i2.localName) {
          for (var d2 = i2, u2 = d2.assignedNodes ? d2.assignedNodes({ flatten: true }) : [], h2 = 0; h2 < u2.length; h2++)
            l(u2[h2], t2, n);
          return;
        }
      }
      for (var c = e2.firstChild; null != c; )
        l(c, t2, n), c = c.nextSibling;
    }
    function d(e2) {
      if (!e2.querySelector("style#inert-style, link#inert-style")) {
        var t2 = document.createElement("style");
        t2.setAttribute("id", "inert-style"), t2.textContent = "\n[inert] {\n  pointer-events: none;\n  cursor: default;\n}\n\n[inert], [inert] * {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n", e2.appendChild(t2);
      }
    }
  }();
});

// node_modules/svelte-sidebar-menu/components/Hamburger.svelte
var file3 = "node_modules/svelte-sidebar-menu/components/Hamburger.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1prbcdr", "svg.svelte-1prbcdr.svelte-1prbcdr{min-height:24px;transition:transform 0.3s ease-in-out}svg.svelte-1prbcdr line.svelte-1prbcdr{stroke:currentColor;stroke-width:3;transition:transform 0.3s ease-in-out}button.svelte-1prbcdr.svelte-1prbcdr{z-index:20}.open.svelte-1prbcdr svg.svelte-1prbcdr{transform:scale(0.7)}.open.svelte-1prbcdr #top.svelte-1prbcdr{transform:translate(6px, 0px) rotate(45deg)}.open.svelte-1prbcdr #middle.svelte-1prbcdr{opacity:0}.open.svelte-1prbcdr #bottom.svelte-1prbcdr{transform:translate(-12px, 9px) rotate(-45deg)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGFtYnVyZ2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEwQkMsaUNBQUksQ0FDSCxVQUFVLENBQUUsSUFBSSxDQUNoQixVQUFVLENBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUM1QixDQUVBLGtCQUFHLENBQUMsbUJBQUssQ0FDUixNQUFNLENBQUUsWUFBWSxDQUNwQixZQUFZLENBQUUsQ0FBQyxDQUNmLFVBQVUsQ0FBRSxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQzVCLENBRUEsb0NBQU8sQ0FDTixPQUFPLENBQUUsRUFDVixDQUVBLG9CQUFLLENBQUMsa0JBQUksQ0FDVCxTQUFTLENBQUUsTUFBTSxHQUFHLENBQ3JCLENBRUEsb0JBQUssQ0FBQyxtQkFBSyxDQUNWLFNBQVMsQ0FBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUM1QyxDQUVBLG9CQUFLLENBQUMsc0JBQVEsQ0FDYixPQUFPLENBQUUsQ0FDVixDQUVBLG9CQUFLLENBQUMsc0JBQVEsQ0FDYixTQUFTLENBQUUsVUFBVSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FDL0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSGFtYnVyZ2VyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let button;
  let svg;
  let line0;
  let line1;
  let line2;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        id: true,
        class: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", { width: true, height: true, class: true });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "id", "top");
      attr_dev(line0, "x1", "0");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "32");
      attr_dev(line0, "y2", "2");
      attr_dev(line0, "class", "svelte-1prbcdr");
      add_location(line0, file3, 19, 2, 555);
      attr_dev(line1, "id", "middle");
      attr_dev(line1, "x1", "0");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "24");
      attr_dev(line1, "y2", "12");
      attr_dev(line1, "class", "svelte-1prbcdr");
      add_location(line1, file3, 20, 2, 604);
      attr_dev(line2, "id", "bottom");
      attr_dev(line2, "x1", "0");
      attr_dev(line2, "y1", "22");
      attr_dev(line2, "x2", "32");
      attr_dev(line2, "y2", "22");
      attr_dev(line2, "class", "svelte-1prbcdr");
      add_location(line2, file3, 21, 2, 658);
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "24");
      attr_dev(svg, "class", "svelte-1prbcdr");
      add_location(svg, file3, 18, 1, 524);
      attr_dev(button, "id", "hamburgerBtn");
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*hamburgerClass*/
        ctx[0]
      ) + " svelte-1prbcdr");
      attr_dev(button, "aria-label", "Sidebar");
      toggle_class(
        button,
        "open",
        /*$sidebarOpen*/
        ctx[1]
      );
      add_location(button, file3, 11, 0, 398);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*toggleSide*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*hamburgerClass*/
      1 && button_class_value !== (button_class_value = null_to_empty(
        /*hamburgerClass*/
        ctx2[0]
      ) + " svelte-1prbcdr")) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*hamburgerClass, $sidebarOpen*/
      3) {
        toggle_class(
          button,
          "open",
          /*$sidebarOpen*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $sidebarOpen;
  validate_store(sidebarOpen, "sidebarOpen");
  component_subscribe($$self, sidebarOpen, ($$value) => $$invalidate(1, $sidebarOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hamburger", slots, []);
  const toggleSide = () => {
    sidebarOpen.update((n) => n = !n);
    sidebarIsInert.update((n) => n = !n);
  };
  let { hamburgerClass = "" } = $$props;
  const writable_props = ["hamburgerClass"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Hamburger> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("hamburgerClass" in $$props2)
      $$invalidate(0, hamburgerClass = $$props2.hamburgerClass);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    toggleSide,
    hamburgerClass,
    $sidebarOpen
  });
  $$self.$inject_state = ($$props2) => {
    if ("hamburgerClass" in $$props2)
      $$invalidate(0, hamburgerClass = $$props2.hamburgerClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [hamburgerClass, $sidebarOpen, toggleSide];
}
var Hamburger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { hamburgerClass: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hamburger",
      options,
      id: create_fragment3.name
    });
  }
  get hamburgerClass() {
    throw new Error("<Hamburger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Hamburger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hamburger_default = Hamburger;

// node_modules/svelte-sidebar-menu/Navbar.svelte
var file4 = "node_modules/svelte-sidebar-menu/Navbar.svelte";
function create_fragment4(ctx) {
  let header;
  let nav;
  let hamburger;
  let t0;
  let div;
  let a;
  let img;
  let img_src_value;
  let t1;
  let span;
  let t2;
  let t3;
  let header_class_value;
  let current;
  hamburger = new Hamburger_default({
    props: {
      hamburgerClass: (
        /*hamburgerClass*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      header = element("header");
      nav = element("nav");
      create_component(hamburger.$$.fragment);
      t0 = space();
      div = element("div");
      a = element("a");
      img = element("img");
      t1 = space();
      span = element("span");
      t2 = text(
        /*siteName*/
        ctx[7]
      );
      t3 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      nav = claim_element(header_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      claim_component(hamburger.$$.fragment, nav_nodes);
      t0 = claim_space(nav_nodes);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      img = claim_element(a_nodes, "IMG", { src: true, alt: true, class: true });
      t1 = claim_space(a_nodes);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(
        span_nodes,
        /*siteName*/
        ctx[7]
      );
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nav_nodes);
      if (default_slot)
        default_slot.l(nav_nodes);
      nav_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*logo*/
      ctx[3]))
        attr_dev(img, "src", img_src_value);
      attr_dev(
        img,
        "alt",
        /*alt*/
        ctx[0]
      );
      attr_dev(
        img,
        "class",
        /*logoClass*/
        ctx[4]
      );
      add_location(img, file4, 17, 4, 744);
      attr_dev(
        span,
        "class",
        /*spanClass*/
        ctx[8]
      );
      add_location(span, file4, 18, 4, 791);
      attr_dev(a, "href", "/");
      attr_dev(a, "class", "flex");
      add_location(a, file4, 16, 3, 714);
      attr_dev(
        div,
        "class",
        /*siteClass*/
        ctx[6]
      );
      add_location(div, file4, 15, 2, 687);
      attr_dev(
        nav,
        "class",
        /*navClass*/
        ctx[5]
      );
      add_location(nav, file4, 13, 1, 629);
      attr_dev(header, "class", header_class_value = /*headerClass*/
      ctx[2] + " " + /*$$props*/
      (ctx[9].class ? (
        /*$$props*/
        ctx[9].class
      ) : ""));
      add_location(header, file4, 12, 0, 560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      append_hydration_dev(header, nav);
      mount_component(hamburger, nav, null);
      append_hydration_dev(nav, t0);
      append_hydration_dev(nav, div);
      append_hydration_dev(div, a);
      append_hydration_dev(a, img);
      append_hydration_dev(a, t1);
      append_hydration_dev(a, span);
      append_hydration_dev(span, t2);
      append_hydration_dev(nav, t3);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hamburger_changes = {};
      if (dirty & /*hamburgerClass*/
      2)
        hamburger_changes.hamburgerClass = /*hamburgerClass*/
        ctx2[1];
      hamburger.$set(hamburger_changes);
      if (!current || dirty & /*logo*/
      8 && !src_url_equal(img.src, img_src_value = /*logo*/
      ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
      if (!current || dirty & /*alt*/
      1) {
        attr_dev(
          img,
          "alt",
          /*alt*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*logoClass*/
      16) {
        attr_dev(
          img,
          "class",
          /*logoClass*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*siteName*/
      128)
        set_data_dev(
          t2,
          /*siteName*/
          ctx2[7]
        );
      if (!current || dirty & /*spanClass*/
      256) {
        attr_dev(
          span,
          "class",
          /*spanClass*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*siteClass*/
      64) {
        attr_dev(
          div,
          "class",
          /*siteClass*/
          ctx2[6]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*navClass*/
      32) {
        attr_dev(
          nav,
          "class",
          /*navClass*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*headerClass, $$props*/
      516 && header_class_value !== (header_class_value = /*headerClass*/
      ctx2[2] + " " + /*$$props*/
      (ctx2[9].class ? (
        /*$$props*/
        ctx2[9].class
      ) : ""))) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hamburger.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hamburger.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      destroy_component(hamburger);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["default"]);
  let { alt = "" } = $$props;
  let { hamburgerClass = "text-gray-500 hover:text-gray-700 cursor-pointer mr-4 border-none focus:outline-none" } = $$props;
  let { headerClass = "bg-gray-200 pt-4 px-10 items-center text-gray-600" } = $$props;
  let { logo = "" } = $$props;
  let { logoClass = "" } = $$props;
  let { navClass = "flex relative" } = $$props;
  let { siteClass = "w-1/4 h-12 text-lg pt-1 pl-12" } = $$props;
  let { siteName = "Demo" } = $$props;
  let { spanClass = "pl-2 self-center text-lg font-semibold text-gray-900 whitespace-nowrap" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("hamburgerClass" in $$new_props)
      $$invalidate(1, hamburgerClass = $$new_props.hamburgerClass);
    if ("headerClass" in $$new_props)
      $$invalidate(2, headerClass = $$new_props.headerClass);
    if ("logo" in $$new_props)
      $$invalidate(3, logo = $$new_props.logo);
    if ("logoClass" in $$new_props)
      $$invalidate(4, logoClass = $$new_props.logoClass);
    if ("navClass" in $$new_props)
      $$invalidate(5, navClass = $$new_props.navClass);
    if ("siteClass" in $$new_props)
      $$invalidate(6, siteClass = $$new_props.siteClass);
    if ("siteName" in $$new_props)
      $$invalidate(7, siteName = $$new_props.siteName);
    if ("spanClass" in $$new_props)
      $$invalidate(8, spanClass = $$new_props.spanClass);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Hamburger: Hamburger_default,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("hamburgerClass" in $$props)
      $$invalidate(1, hamburgerClass = $$new_props.hamburgerClass);
    if ("headerClass" in $$props)
      $$invalidate(2, headerClass = $$new_props.headerClass);
    if ("logo" in $$props)
      $$invalidate(3, logo = $$new_props.logo);
    if ("logoClass" in $$props)
      $$invalidate(4, logoClass = $$new_props.logoClass);
    if ("navClass" in $$props)
      $$invalidate(5, navClass = $$new_props.navClass);
    if ("siteClass" in $$props)
      $$invalidate(6, siteClass = $$new_props.siteClass);
    if ("siteName" in $$props)
      $$invalidate(7, siteName = $$new_props.siteName);
    if ("spanClass" in $$props)
      $$invalidate(8, spanClass = $$new_props.spanClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass,
    $$props,
    $$scope,
    slots
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      alt: 0,
      hamburgerClass: 1,
      headerClass: 2,
      logo: 3,
      logoClass: 4,
      navClass: 5,
      siteClass: 6,
      siteName: 7,
      spanClass: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment4.name
    });
  }
  get alt() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hamburgerClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logoClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logoClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spanClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spanClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/svelte-sidebar-menu/Responsive.svelte
function create_fragment5(ctx) {
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[2]
  );
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*onwindowresize*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Responsive", slots, []);
  let { breakPoint = 1024 } = $$props;
  let width;
  onMount(() => {
    if (width >= breakPoint) {
      sidebarStayOpen.update((n) => n = true);
      sidebarOpen.update((n) => n = true);
      sidebarIsInert.update((n) => n = false);
    } else {
      sidebarStayOpen.update((n) => n = false);
      sidebarOpen.update((n) => n = false);
      sidebarIsInert.update((n) => n = true);
    }
  });
  const writable_props = ["breakPoint"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Responsive> was created with unknown prop '${key}'`);
  });
  function onwindowresize() {
    $$invalidate(0, width = window.innerWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("breakPoint" in $$props2)
      $$invalidate(1, breakPoint = $$props2.breakPoint);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    onMount,
    breakPoint,
    width
  });
  $$self.$inject_state = ($$props2) => {
    if ("breakPoint" in $$props2)
      $$invalidate(1, breakPoint = $$props2.breakPoint);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*width, breakPoint*/
    3) {
      $:
        if (width >= breakPoint) {
          sidebarStayOpen.update((n) => n = true);
          sidebarOpen.update((n) => n = true);
          sidebarIsInert.update((n) => n = false);
        } else {
          sidebarStayOpen.update((n) => n = false);
          sidebarOpen.update((n) => n = false);
          sidebarIsInert.update((n) => n = true);
        }
    }
  };
  return [width, breakPoint, onwindowresize];
}
var Responsive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { breakPoint: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Responsive",
      options,
      id: create_fragment5.name
    });
  }
  get breakPoint() {
    throw new Error("<Responsive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set breakPoint(value) {
    throw new Error("<Responsive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Responsive_default = Responsive;

// node_modules/svelte-sidebar-menu/Sidebar.svelte
var file5 = "node_modules/svelte-sidebar-menu/Sidebar.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1df2u6a", ".close.svelte-1df2u6a.svelte-1df2u6a{left:-100%}.open.svelte-1df2u6a.svelte-1df2u6a{left:0}[inert].svelte-1df2u6a.svelte-1df2u6a{pointer-events:none;cursor:default}[inert].svelte-1df2u6a.svelte-1df2u6a,[inert].svelte-1df2u6a .svelte-1df2u6a{opacity:0.5;pointer-events:none;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZWJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMEdDLG9DQUFPLENBQ04sSUFBSSxDQUFFLEtBQ1AsQ0FDQSxtQ0FBTSxDQUNMLElBQUksQ0FBRSxDQUNQLENBRUEsQ0FBQyxLQUFLLCtCQUFFLENBQ1AsY0FBYyxDQUFFLElBQUksQ0FDcEIsTUFBTSxDQUFFLE9BQ1QsQ0FFQSxDQUFDLEtBQUssK0JBQUMsQ0FDUCxDQUFDLEtBQUssZ0JBQUMsQ0FBQyxlQUFFLENBQ1QsT0FBTyxDQUFFLEdBQUcsQ0FDWixjQUFjLENBQUUsSUFBSSxDQUNwQixNQUFNLENBQUUsT0FBTyxDQUNmLG1CQUFtQixDQUFFLElBQUksQ0FDdEIsZ0JBQWdCLENBQUUsSUFBSSxDQUNyQixlQUFlLENBQUUsSUFBSSxDQUNqQixXQUFXLENBQUUsSUFDdEIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2lkZWJhci5zdmVsdGUiXX0= */");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i].href;
  child_ctx[24] = list[i].name;
  child_ctx[25] = list[i].rel;
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i].href;
  child_ctx[24] = list[i].name;
  child_ctx[25] = list[i].rel;
  return child_ctx;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(57:1) <Navbar   {alt}   {hamburgerClass}   {headerClass}   {logo}   {logoClass}   navClass={navBarClass}   {siteClass}   {siteName}   {spanClass}  >",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let aside;
  let nav;
  let div;
  let div_class_value;
  let nav_class_value;
  let aside_class_value;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*lists*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      aside = element("aside");
      nav = element("nav");
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true, "aria-hidden": true });
      var aside_nodes = children(aside);
      nav = claim_element(aside_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(
        /*navDivClass*/
        ctx[12]
      ) + " svelte-1df2u6a");
      add_location(div, file5, 95, 4, 2542);
      attr_dev(nav, "class", nav_class_value = null_to_empty(
        /*navClass*/
        ctx[10]
      ) + " svelte-1df2u6a");
      add_location(nav, file5, 94, 3, 2515);
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*asideClass*/
        ctx[11]
      ) + " svelte-1df2u6a");
      attr_dev(
        aside,
        "aria-hidden",
        /*ariaHidden*/
        ctx[18]
      );
      aside.inert = /*inert*/
      ctx[16];
      toggle_class(
        aside,
        "open",
        /*sidebarStatus*/
        ctx[17]
      );
      toggle_class(aside, "close", !/*sidebarStatus*/
      ctx[17]);
      add_location(aside, file5, 87, 2, 2378);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, nav);
      append_hydration_dev(nav, div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*lists, sideBarListClass*/
      8193) {
        each_value_1 = ensure_array_like_dev(
          /*lists*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*navDivClass*/
      4096 && div_class_value !== (div_class_value = null_to_empty(
        /*navDivClass*/
        ctx2[12]
      ) + " svelte-1df2u6a")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*navClass*/
      1024 && nav_class_value !== (nav_class_value = null_to_empty(
        /*navClass*/
        ctx2[10]
      ) + " svelte-1df2u6a")) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (!current || dirty & /*asideClass*/
      2048 && aside_class_value !== (aside_class_value = null_to_empty(
        /*asideClass*/
        ctx2[11]
      ) + " svelte-1df2u6a")) {
        attr_dev(aside, "class", aside_class_value);
      }
      if (!current || dirty & /*ariaHidden*/
      262144) {
        attr_dev(
          aside,
          "aria-hidden",
          /*ariaHidden*/
          ctx2[18]
        );
      }
      if (!current || dirty & /*inert*/
      65536) {
        prop_dev(
          aside,
          "inert",
          /*inert*/
          ctx2[16]
        );
      }
      if (!current || dirty & /*asideClass, sidebarStatus*/
      133120) {
        toggle_class(
          aside,
          "open",
          /*sidebarStatus*/
          ctx2[17]
        );
      }
      if (!current || dirty & /*asideClass, sidebarStatus*/
      133120) {
        toggle_class(aside, "close", !/*sidebarStatus*/
        ctx2[17]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(87:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*sidebarStatus*/
    ctx[17] && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*sidebarStatus*/
        ctx2[17]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*sidebarStatus*/
          131072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(70:1) {#if transitionType}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let sidebarlist;
  let current;
  sidebarlist = new SidebarList_default({
    props: {
      href: (
        /*href*/
        ctx[23]
      ),
      name: (
        /*name*/
        ctx[24]
      ),
      rel: (
        /*rel*/
        ctx[25]
      ),
      sideBarListClass: (
        /*sideBarListClass*/
        ctx[13]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sidebarlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sidebarlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sidebarlist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sidebarlist_changes = {};
      if (dirty & /*lists*/
      1)
        sidebarlist_changes.href = /*href*/
        ctx2[23];
      if (dirty & /*lists*/
      1)
        sidebarlist_changes.name = /*name*/
        ctx2[24];
      if (dirty & /*lists*/
      1)
        sidebarlist_changes.rel = /*rel*/
        ctx2[25];
      if (dirty & /*sideBarListClass*/
      8192)
        sidebarlist_changes.sideBarListClass = /*sideBarListClass*/
        ctx2[13];
      sidebarlist.$set(sidebarlist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sidebarlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(97:5) {#each lists as { href, name, rel }}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let aside;
  let nav;
  let div;
  let div_class_value;
  let nav_class_value;
  let aside_class_value;
  let aside_transition;
  let current;
  let each_value = ensure_array_like_dev(
    /*lists*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      aside = element("aside");
      nav = element("nav");
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true, "aria-hidden": true });
      var aside_nodes = children(aside);
      nav = claim_element(aside_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(
        /*navDivClass*/
        ctx[12]
      ) + " svelte-1df2u6a");
      add_location(div, file5, 78, 5, 2179);
      attr_dev(nav, "class", nav_class_value = null_to_empty(
        /*navClass*/
        ctx[10]
      ) + " svelte-1df2u6a");
      add_location(nav, file5, 77, 4, 2151);
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*asideClass*/
        ctx[11]
      ) + " svelte-1df2u6a");
      attr_dev(
        aside,
        "aria-hidden",
        /*ariaHidden*/
        ctx[18]
      );
      aside.inert = /*inert*/
      ctx[16];
      add_location(aside, file5, 71, 3, 2028);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, nav);
      append_hydration_dev(nav, div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*lists, sideBarListClass*/
      8193) {
        each_value = ensure_array_like_dev(
          /*lists*/
          ctx[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*navDivClass*/
      4096 && div_class_value !== (div_class_value = null_to_empty(
        /*navDivClass*/
        ctx[12]
      ) + " svelte-1df2u6a")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*navClass*/
      1024 && nav_class_value !== (nav_class_value = null_to_empty(
        /*navClass*/
        ctx[10]
      ) + " svelte-1df2u6a")) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (!current || dirty & /*asideClass*/
      2048 && aside_class_value !== (aside_class_value = null_to_empty(
        /*asideClass*/
        ctx[11]
      ) + " svelte-1df2u6a")) {
        attr_dev(aside, "class", aside_class_value);
      }
      if (!current || dirty & /*ariaHidden*/
      262144) {
        attr_dev(
          aside,
          "aria-hidden",
          /*ariaHidden*/
          ctx[18]
        );
      }
      if (!current || dirty & /*inert*/
      65536) {
        prop_dev(
          aside,
          "inert",
          /*inert*/
          ctx[16]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!aside_transition)
            aside_transition = create_bidirectional_transition(
              aside,
              /*multiple*/
              ctx[19],
              /*transitionParams*/
              ctx[14],
              true
            );
          aside_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (local) {
        if (!aside_transition)
          aside_transition = create_bidirectional_transition(
            aside,
            /*multiple*/
            ctx[19],
            /*transitionParams*/
            ctx[14],
            false
          );
        aside_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      destroy_each(each_blocks, detaching);
      if (detaching && aside_transition)
        aside_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(71:2) {#if sidebarStatus}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let sidebarlist;
  let current;
  sidebarlist = new SidebarList_default({
    props: {
      href: (
        /*href*/
        ctx[23]
      ),
      name: (
        /*name*/
        ctx[24]
      ),
      rel: (
        /*rel*/
        ctx[25]
      ),
      sideBarListClass: (
        /*sideBarListClass*/
        ctx[13]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sidebarlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sidebarlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sidebarlist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sidebarlist_changes = {};
      if (dirty & /*lists*/
      1)
        sidebarlist_changes.href = /*href*/
        ctx2[23];
      if (dirty & /*lists*/
      1)
        sidebarlist_changes.name = /*name*/
        ctx2[24];
      if (dirty & /*lists*/
      1)
        sidebarlist_changes.rel = /*rel*/
        ctx2[25];
      if (dirty & /*sideBarListClass*/
      8192)
        sidebarlist_changes.sideBarListClass = /*sideBarListClass*/
        ctx2[13];
      sidebarlist.$set(sidebarlist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sidebarlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(80:6) {#each lists as { href, name, rel }}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let navbar;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  navbar = new Navbar_default({
    props: {
      alt: (
        /*alt*/
        ctx[1]
      ),
      hamburgerClass: (
        /*hamburgerClass*/
        ctx[2]
      ),
      headerClass: (
        /*headerClass*/
        ctx[3]
      ),
      logo: (
        /*logo*/
        ctx[4]
      ),
      logoClass: (
        /*logoClass*/
        ctx[5]
      ),
      navClass: (
        /*navBarClass*/
        ctx[6]
      ),
      siteClass: (
        /*siteClass*/
        ctx[8]
      ),
      siteName: (
        /*siteName*/
        ctx[7]
      ),
      spanClass: (
        /*spanClass*/
        ctx[9]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*transitionType*/
      ctx2[15]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      create_component(navbar.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(navbar.$$.fragment, nodes);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(navbar, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & /*alt*/
      2)
        navbar_changes.alt = /*alt*/
        ctx2[1];
      if (dirty & /*hamburgerClass*/
      4)
        navbar_changes.hamburgerClass = /*hamburgerClass*/
        ctx2[2];
      if (dirty & /*headerClass*/
      8)
        navbar_changes.headerClass = /*headerClass*/
        ctx2[3];
      if (dirty & /*logo*/
      16)
        navbar_changes.logo = /*logo*/
        ctx2[4];
      if (dirty & /*logoClass*/
      32)
        navbar_changes.logoClass = /*logoClass*/
        ctx2[5];
      if (dirty & /*navBarClass*/
      64)
        navbar_changes.navClass = /*navBarClass*/
        ctx2[6];
      if (dirty & /*siteClass*/
      256)
        navbar_changes.siteClass = /*siteClass*/
        ctx2[8];
      if (dirty & /*siteName*/
      128)
        navbar_changes.siteName = /*siteName*/
        ctx2[7];
      if (dirty & /*spanClass*/
      512)
        navbar_changes.spanClass = /*spanClass*/
        ctx2[9];
      if (dirty & /*$$scope*/
      4194304) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(navbar, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(56:0) <OutsideClick>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let outsideclick;
  let current;
  outsideclick = new OutsideClick_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(outsideclick.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(outsideclick.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(outsideclick, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const outsideclick_changes = {};
      if (dirty & /*$$scope, asideClass, ariaHidden, inert, transitionParams, navClass, navDivClass, lists, sideBarListClass, sidebarStatus, transitionType, alt, hamburgerClass, headerClass, logo, logoClass, navBarClass, siteClass, siteName, spanClass*/
      4718591) {
        outsideclick_changes.$$scope = { dirty, ctx: ctx2 };
      }
      outsideclick.$set(outsideclick_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(outsideclick.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(outsideclick.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(outsideclick, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $sidebarIsInert;
  validate_store(sidebarIsInert, "sidebarIsInert");
  component_subscribe($$self, sidebarIsInert, ($$value) => $$invalidate(20, $sidebarIsInert = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sidebar", slots, ["default"]);
  let { lists } = $$props;
  let { alt = "" } = $$props;
  let { hamburgerClass = "" } = $$props;
  let { headerClass = "bg-gray-200 pt-4 px-10 items-center text-gray-600" } = $$props;
  let { logo = "" } = $$props;
  let { logoClass = "" } = $$props;
  let { navBarClass = "flex relative" } = $$props;
  let { siteName = "Demo" } = $$props;
  let { siteClass = "w-1/4 h-12 text-lg pt-1 pl-12" } = $$props;
  let { spanClass = "pl-2 self-center text-lg font-semibold text-gray-900 whitespace-nowrap" } = $$props;
  let { navClass = "py-8 px-4 text-lg" } = $$props;
  let { asideClass = "absolute w-auto h-screen bg-white border-r-2 shadow-lg z-50" } = $$props;
  let { navDivClass = "pb-10" } = $$props;
  let { sideBarListClass = "border-b border-gray-400 mb-2 px-4" } = $$props;
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  function multiple(node, params) {
    switch (transitionType) {
      case "slide":
        return slide(node, params);
      case "blur":
        return blur(node, params);
      case "fly":
        return fly(node, params);
      case "fade":
        return fade(node, params);
    }
  }
  let inert = null;
  let sidebarStatus;
  let ariaHidden;
  sidebarOpen.subscribe((value) => {
    if (value === true) {
      $$invalidate(17, sidebarStatus = true);
      $$invalidate(18, ariaHidden = false);
    } else {
      $$invalidate(17, sidebarStatus = false);
      $$invalidate(18, ariaHidden = true);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (lists === void 0 && !("lists" in $$props || $$self.$$.bound[$$self.$$.props["lists"]])) {
      console.warn("<Sidebar> was created without expected prop 'lists'");
    }
  });
  const writable_props = [
    "lists",
    "alt",
    "hamburgerClass",
    "headerClass",
    "logo",
    "logoClass",
    "navBarClass",
    "siteName",
    "siteClass",
    "spanClass",
    "navClass",
    "asideClass",
    "navDivClass",
    "sideBarListClass",
    "transitionParams",
    "transitionType"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Sidebar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lists" in $$props2)
      $$invalidate(0, lists = $$props2.lists);
    if ("alt" in $$props2)
      $$invalidate(1, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(2, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(3, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(4, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(5, logoClass = $$props2.logoClass);
    if ("navBarClass" in $$props2)
      $$invalidate(6, navBarClass = $$props2.navBarClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("siteClass" in $$props2)
      $$invalidate(8, siteClass = $$props2.siteClass);
    if ("spanClass" in $$props2)
      $$invalidate(9, spanClass = $$props2.spanClass);
    if ("navClass" in $$props2)
      $$invalidate(10, navClass = $$props2.navClass);
    if ("asideClass" in $$props2)
      $$invalidate(11, asideClass = $$props2.asideClass);
    if ("navDivClass" in $$props2)
      $$invalidate(12, navDivClass = $$props2.navDivClass);
    if ("sideBarListClass" in $$props2)
      $$invalidate(13, sideBarListClass = $$props2.sideBarListClass);
    if ("transitionParams" in $$props2)
      $$invalidate(14, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(15, transitionType = $$props2.transitionType);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    fly,
    slide,
    blur,
    fade,
    SidebarList: SidebarList_default,
    Navbar: Navbar_default,
    OutsideClick: OutsideClick_default,
    lists,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navBarClass,
    siteName,
    siteClass,
    spanClass,
    navClass,
    asideClass,
    navDivClass,
    sideBarListClass,
    transitionParams,
    transitionType,
    multiple,
    inert,
    sidebarStatus,
    ariaHidden,
    $sidebarIsInert
  });
  $$self.$inject_state = ($$props2) => {
    if ("lists" in $$props2)
      $$invalidate(0, lists = $$props2.lists);
    if ("alt" in $$props2)
      $$invalidate(1, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(2, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(3, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(4, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(5, logoClass = $$props2.logoClass);
    if ("navBarClass" in $$props2)
      $$invalidate(6, navBarClass = $$props2.navBarClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("siteClass" in $$props2)
      $$invalidate(8, siteClass = $$props2.siteClass);
    if ("spanClass" in $$props2)
      $$invalidate(9, spanClass = $$props2.spanClass);
    if ("navClass" in $$props2)
      $$invalidate(10, navClass = $$props2.navClass);
    if ("asideClass" in $$props2)
      $$invalidate(11, asideClass = $$props2.asideClass);
    if ("navDivClass" in $$props2)
      $$invalidate(12, navDivClass = $$props2.navDivClass);
    if ("sideBarListClass" in $$props2)
      $$invalidate(13, sideBarListClass = $$props2.sideBarListClass);
    if ("transitionParams" in $$props2)
      $$invalidate(14, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(15, transitionType = $$props2.transitionType);
    if ("inert" in $$props2)
      $$invalidate(16, inert = $$props2.inert);
    if ("sidebarStatus" in $$props2)
      $$invalidate(17, sidebarStatus = $$props2.sidebarStatus);
    if ("ariaHidden" in $$props2)
      $$invalidate(18, ariaHidden = $$props2.ariaHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$sidebarIsInert*/
    1048576) {
      $:
        $$invalidate(16, inert = $sidebarIsInert ? "inert" : null);
    }
  };
  return [
    lists,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navBarClass,
    siteName,
    siteClass,
    spanClass,
    navClass,
    asideClass,
    navDivClass,
    sideBarListClass,
    transitionParams,
    transitionType,
    inert,
    sidebarStatus,
    ariaHidden,
    multiple,
    $sidebarIsInert,
    slots,
    $$scope
  ];
}
var Sidebar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        lists: 0,
        alt: 1,
        hamburgerClass: 2,
        headerClass: 3,
        logo: 4,
        logoClass: 5,
        navBarClass: 6,
        siteName: 7,
        siteClass: 8,
        spanClass: 9,
        navClass: 10,
        asideClass: 11,
        navDivClass: 12,
        sideBarListClass: 13,
        transitionParams: 14,
        transitionType: 15
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sidebar",
      options,
      id: create_fragment6.name
    });
  }
  get lists() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lists(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hamburgerClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logoClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logoClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navBarClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navBarClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spanClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spanClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navDivClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navDivClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideBarListClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideBarListClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionParams() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionParams(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionType() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionType(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sidebar_default = Sidebar;

// node_modules/svelte-sidebar-menu/SidebarList.svelte
var file6 = "node_modules/svelte-sidebar-menu/SidebarList.svelte";
function create_else_block2(ctx) {
  let div;
  let a;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      t = text(
        /*name*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { class: true, href: true, rel: true });
      var a_nodes = children(a);
      t = claim_text(
        a_nodes,
        /*name*/
        ctx[1]
      );
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "block");
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[0]
      );
      attr_dev(
        a,
        "rel",
        /*rel*/
        ctx[2]
      );
      add_location(a, file6, 20, 2, 664);
      attr_dev(div, "class", div_class_value = /*sideBarListClass*/
      ctx[3] + " " + /*$$props*/
      (ctx[6].class ? (
        /*$$props*/
        ctx[6].class
      ) : ""));
      add_location(div, file6, 19, 1, 592);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, t);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*toggleSide*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*name*/
      2)
        set_data_dev(
          t,
          /*name*/
          ctx2[1]
        );
      if (dirty & /*href*/
      1) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[0]
        );
      }
      if (dirty & /*rel*/
      4) {
        attr_dev(
          a,
          "rel",
          /*rel*/
          ctx2[2]
        );
      }
      if (dirty & /*sideBarListClass, $$props*/
      72 && div_class_value !== (div_class_value = /*sideBarListClass*/
      ctx2[3] + " " + /*$$props*/
      (ctx2[6].class ? (
        /*$$props*/
        ctx2[6].class
      ) : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let a;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      t = text(
        /*name*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { class: true, href: true, rel: true });
      var a_nodes = children(a);
      t = claim_text(
        a_nodes,
        /*name*/
        ctx[1]
      );
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "block");
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[0]
      );
      attr_dev(
        a,
        "rel",
        /*rel*/
        ctx[2]
      );
      add_location(a, file6, 16, 2, 534);
      attr_dev(div, "class", div_class_value = /*sideBarListClass*/
      ctx[3] + " " + /*$$props*/
      (ctx[6].class ? (
        /*$$props*/
        ctx[6].class
      ) : ""));
      add_location(div, file6, 15, 1, 462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*name*/
      2)
        set_data_dev(
          t,
          /*name*/
          ctx2[1]
        );
      if (dirty & /*href*/
      1) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[0]
        );
      }
      if (dirty & /*rel*/
      4) {
        attr_dev(
          a,
          "rel",
          /*rel*/
          ctx2[2]
        );
      }
      if (dirty & /*sideBarListClass, $$props*/
      72 && div_class_value !== (div_class_value = /*sideBarListClass*/
      ctx2[3] + " " + /*$$props*/
      (ctx2[6].class ? (
        /*$$props*/
        ctx2[6].class
      ) : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(15:0) {#if $sidebarStayOpen === true}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$sidebarStayOpen*/
      ctx2[4] === true
    )
      return create_if_block3;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $sidebarStayOpen;
  validate_store(sidebarStayOpen, "sidebarStayOpen");
  component_subscribe($$self, sidebarStayOpen, ($$value) => $$invalidate(4, $sidebarStayOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SidebarList", slots, []);
  let { href } = $$props;
  let { name } = $$props;
  let { rel = null } = $$props;
  let { sideBarListClass = "border-b border-gray-400 mb-2 px-4" } = $$props;
  function toggleSide() {
    if (!sidebarStayOpen) {
      sidebarOpen.update((n) => n = !n);
      sidebarIsInert.update((n) => n = !n);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (href === void 0 && !("href" in $$props || $$self.$$.bound[$$self.$$.props["href"]])) {
      console.warn("<SidebarList> was created without expected prop 'href'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<SidebarList> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("rel" in $$new_props)
      $$invalidate(2, rel = $$new_props.rel);
    if ("sideBarListClass" in $$new_props)
      $$invalidate(3, sideBarListClass = $$new_props.sideBarListClass);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    href,
    name,
    rel,
    sideBarListClass,
    toggleSide,
    $sidebarStayOpen
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("rel" in $$props)
      $$invalidate(2, rel = $$new_props.rel);
    if ("sideBarListClass" in $$props)
      $$invalidate(3, sideBarListClass = $$new_props.sideBarListClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [href, name, rel, sideBarListClass, $sidebarStayOpen, toggleSide, $$props];
}
var SidebarList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      href: 0,
      name: 1,
      rel: 2,
      sideBarListClass: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SidebarList",
      options,
      id: create_fragment7.name
    });
  }
  get href() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rel() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rel(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideBarListClass() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideBarListClass(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SidebarList_default = SidebarList;

// node_modules/svelte-sidebar-menu/TopMenu.svelte
import { page } from "$app/stores";

// node_modules/svelte-sidebar-menu/Dropdown.svelte
var file7 = "node_modules/svelte-sidebar-menu/Dropdown.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i].href;
  child_ctx[4] = list[i].name;
  child_ctx[12] = list[i].rel;
  child_ctx[13] = list[i].id;
  return child_ctx;
}
function create_if_block4(ctx) {
  let div;
  let mounted;
  let dispose;
  const block_1 = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "fixed w-full h-full inset-0");
      add_location(div, file7, 20, 1, 781);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*closeDropdown*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block4.name,
    type: "if",
    source: "(20:0) {#if hidden === false}",
    ctx
  });
  return block_1;
}
function create_each_block2(ctx) {
  let li;
  let a;
  let t0_value = (
    /*name*/
    ctx[4] + ""
  );
  let t0;
  let a_href_value;
  let a_id_value;
  let a_rel_value;
  let t1;
  const block_1 = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        href: true,
        id: true,
        rel: true,
        class: true
      });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*href*/
      ctx[11]);
      attr_dev(a, "id", a_id_value = /*id*/
      ctx[13]);
      attr_dev(a, "rel", a_rel_value = /*rel*/
      ctx[12]);
      attr_dev(
        a,
        "class",
        /*activeChildLi*/
        ctx[2]
      );
      add_location(a, file7, 47, 5, 1534);
      add_location(li, file7, 46, 4, 1524);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(li, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*child*/
      1 && t0_value !== (t0_value = /*name*/
      ctx2[4] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*child*/
      1 && a_href_value !== (a_href_value = /*href*/
      ctx2[11])) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*child*/
      1 && a_id_value !== (a_id_value = /*id*/
      ctx2[13])) {
        attr_dev(a, "id", a_id_value);
      }
      if (dirty & /*child*/
      1 && a_rel_value !== (a_rel_value = /*rel*/
      ctx2[12])) {
        attr_dev(a, "rel", a_rel_value);
      }
      if (dirty & /*activeChildLi*/
      4) {
        attr_dev(
          a,
          "class",
          /*activeChildLi*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block2.name,
    type: "each",
    source: "(46:3) {#each child as { href, name, rel, id }}",
    ctx
  });
  return block_1;
}
function create_fragment8(ctx) {
  let t0;
  let li;
  let button;
  let t1;
  let t2;
  let svg;
  let path;
  let t3;
  let div;
  let ul;
  let div_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*hidden*/
    ctx[5] === false && create_if_block4(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*child*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block_1 = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      li = element("li");
      button = element("button");
      t1 = text(
        /*name*/
        ctx[4]
      );
      t2 = space();
      svg = svg_element("svg");
      path = svg_element("path");
      t3 = space();
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t0 = claim_space(nodes);
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t1 = claim_text(
        button_nodes,
        /*name*/
        ctx[4]
      );
      t2 = claim_space(button_nodes);
      svg = claim_svg_element(button_nodes, "svg", {
        class: true,
        fill: true,
        viewBox: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(li_nodes);
      div = claim_element(li_nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true, "aria-label": true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file7, 30, 4, 1052);
      attr_dev(svg, "class", "ml-1 w-4 h-4");
      attr_dev(svg, "fill", "currentColor");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file7, 25, 2, 935);
      attr_dev(
        button,
        "class",
        /*dropdownLi*/
        ctx[3]
      );
      add_location(button, file7, 23, 1, 862);
      attr_dev(ul, "class", "py-1");
      attr_dev(ul, "aria-label", "dropdown-button");
      add_location(ul, file7, 44, 2, 1429);
      attr_dev(div, "class", div_class_value = /*activeDropdownDiv*/
      ctx[1] + " " + /*$$props*/
      (ctx[9].class ? (
        /*$$props*/
        ctx[9].class
      ) : ""));
      set_style(div, "position", "absolute");
      set_style(div, "margin", "0px");
      toggle_class(
        div,
        "hidden",
        /*hidden*/
        ctx[5]
      );
      toggle_class(
        div,
        "block",
        /*block*/
        ctx[6]
      );
      add_location(div, file7, 38, 1, 1280);
      add_location(li, file7, 22, 0, 856);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      append_hydration_dev(li, t3);
      append_hydration_dev(li, div);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[10],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*hidden*/
        ctx2[5] === false
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*name*/
      16)
        set_data_dev(
          t1,
          /*name*/
          ctx2[4]
        );
      if (dirty & /*dropdownLi*/
      8) {
        attr_dev(
          button,
          "class",
          /*dropdownLi*/
          ctx2[3]
        );
      }
      if (dirty & /*child, activeChildLi*/
      5) {
        each_value = ensure_array_like_dev(
          /*child*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*activeDropdownDiv, $$props*/
      514 && div_class_value !== (div_class_value = /*activeDropdownDiv*/
      ctx2[1] + " " + /*$$props*/
      (ctx2[9].class ? (
        /*$$props*/
        ctx2[9].class
      ) : ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*activeDropdownDiv, $$props, hidden*/
      546) {
        toggle_class(
          div,
          "hidden",
          /*hidden*/
          ctx2[5]
        );
      }
      if (dirty & /*activeDropdownDiv, $$props, block*/
      578) {
        toggle_class(
          div,
          "block",
          /*block*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(li);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, []);
  let { name = "" } = $$props;
  let { child } = $$props;
  let { activeDropdownDiv = "z-10 w-44 text-lg list-none bg-white rounded divide-y divide-gray-100 shadow" } = $$props;
  let { activeChildLi = "block py-2 px-4 text-base text-gray-700 hover:bg-gray-100" } = $$props;
  let { dropdownLi = "flex justify-between items-center py-2 pr-4 pl-3 w-full text-base font-medium text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:w-auto" } = $$props;
  let hidden = true;
  let block = false;
  const handleDropdown = () => {
    $$invalidate(5, hidden = !hidden);
    $$invalidate(6, block = !block);
  };
  const closeDropdown = () => {
    $$invalidate(5, hidden = true);
    $$invalidate(6, block = false);
  };
  $$self.$$.on_mount.push(function() {
    if (child === void 0 && !("child" in $$props || $$self.$$.bound[$$self.$$.props["child"]])) {
      console.warn("<Dropdown> was created without expected prop 'child'");
    }
  });
  const click_handler = () => handleDropdown();
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("child" in $$new_props)
      $$invalidate(0, child = $$new_props.child);
    if ("activeDropdownDiv" in $$new_props)
      $$invalidate(1, activeDropdownDiv = $$new_props.activeDropdownDiv);
    if ("activeChildLi" in $$new_props)
      $$invalidate(2, activeChildLi = $$new_props.activeChildLi);
    if ("dropdownLi" in $$new_props)
      $$invalidate(3, dropdownLi = $$new_props.dropdownLi);
  };
  $$self.$capture_state = () => ({
    name,
    child,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    hidden,
    block,
    handleDropdown,
    closeDropdown
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
    if ("child" in $$props)
      $$invalidate(0, child = $$new_props.child);
    if ("activeDropdownDiv" in $$props)
      $$invalidate(1, activeDropdownDiv = $$new_props.activeDropdownDiv);
    if ("activeChildLi" in $$props)
      $$invalidate(2, activeChildLi = $$new_props.activeChildLi);
    if ("dropdownLi" in $$props)
      $$invalidate(3, dropdownLi = $$new_props.dropdownLi);
    if ("hidden" in $$props)
      $$invalidate(5, hidden = $$new_props.hidden);
    if ("block" in $$props)
      $$invalidate(6, block = $$new_props.block);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    child,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    name,
    hidden,
    block,
    handleDropdown,
    closeDropdown,
    $$props,
    click_handler
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      name: 4,
      child: 0,
      activeDropdownDiv: 1,
      activeChildLi: 2,
      dropdownLi: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment8.name
    });
  }
  get name() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get child() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set child(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeDropdownDiv() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeDropdownDiv(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeChildLi() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeChildLi(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownLi() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownLi(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/svelte-sidebar-menu/TopMenu.svelte
var file8 = "node_modules/svelte-sidebar-menu/TopMenu.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i].id;
  child_ctx[14] = list[i].name;
  child_ctx[15] = list[i].href;
  child_ctx[16] = list[i].rel;
  child_ctx[17] = list[i].child;
  return child_ctx;
}
function create_else_block3(ctx) {
  let li;
  let a;
  let t0_value = (
    /*name*/
    ctx[14] + ""
  );
  let t0;
  let a_href_value;
  let a_rel_value;
  let t1;
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", { href: true, rel: true, class: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*href*/
      ctx[15]);
      attr_dev(a, "rel", a_rel_value = /*rel*/
      ctx[16]);
      attr_dev(
        a,
        "class",
        /*childLi*/
        ctx[2]
      );
      toggle_class(
        a,
        "active",
        /*$page*/
        ctx[11].url.pathname === /*href*/
        ctx[15]
      );
      add_location(a, file8, 53, 6, 2578);
      attr_dev(
        li,
        "class",
        /*topli*/
        ctx[6]
      );
      add_location(li, file8, 52, 5, 2553);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(li, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*topMenus*/
      16 && t0_value !== (t0_value = /*name*/
      ctx2[14] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*topMenus*/
      16 && a_href_value !== (a_href_value = /*href*/
      ctx2[15])) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*topMenus*/
      16 && a_rel_value !== (a_rel_value = /*rel*/
      ctx2[16])) {
        attr_dev(a, "rel", a_rel_value);
      }
      if (dirty & /*childLi*/
      4) {
        attr_dev(
          a,
          "class",
          /*childLi*/
          ctx2[2]
        );
      }
      if (dirty & /*childLi, $page, topMenus*/
      2068) {
        toggle_class(
          a,
          "active",
          /*$page*/
          ctx2[11].url.pathname === /*href*/
          ctx2[15]
        );
      }
      if (dirty & /*topli*/
      64) {
        attr_dev(
          li,
          "class",
          /*topli*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(52:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let dropdown;
  let current;
  dropdown = new Dropdown_default({
    props: {
      name: (
        /*name*/
        ctx[14]
      ),
      child: (
        /*child*/
        ctx[17]
      ),
      activeChildLi: (
        /*activeChildLi*/
        ctx[8]
      ),
      activeDropdownDiv: (
        /*activeDropdownDiv*/
        ctx[7]
      ),
      dropdownLi: (
        /*dropdownLi*/
        ctx[9]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dropdown.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dropdown.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty & /*topMenus*/
      16)
        dropdown_changes.name = /*name*/
        ctx2[14];
      if (dirty & /*topMenus*/
      16)
        dropdown_changes.child = /*child*/
        ctx2[17];
      if (dirty & /*activeChildLi*/
      256)
        dropdown_changes.activeChildLi = /*activeChildLi*/
        ctx2[8];
      if (dirty & /*activeDropdownDiv*/
      128)
        dropdown_changes.activeDropdownDiv = /*activeDropdownDiv*/
        ctx2[7];
      if (dirty & /*dropdownLi*/
      512)
        dropdown_changes.dropdownLi = /*dropdownLi*/
        ctx2[9];
      dropdown.$set(dropdown_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(50:4) {#if child}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*child*/
      ctx2[17]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(49:3) {#each topMenus as { id, name, href, rel, child }}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div1;
  let button;
  let span;
  let textContent = "Open main menu";
  let t1;
  let svg0;
  let path0;
  let t2;
  let svg1;
  let path1;
  let t3;
  let div0;
  let ul;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*topMenus*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div1 = element("div");
      button = element("button");
      span = element("span");
      span.textContent = textContent;
      t1 = space();
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t2 = space();
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t3 = space();
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", {
        "data-collapse-toggle": true,
        type: true,
        class: true,
        "aria-expanded": true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1bvqpab")
        span.textContent = textContent;
      t1 = claim_space(button_nodes);
      svg0 = claim_svg_element(button_nodes, "svg", {
        class: true,
        fill: true,
        viewBox: true,
        xmlns: true
      });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      t2 = claim_space(button_nodes);
      svg1 = claim_svg_element(button_nodes, "svg", {
        class: true,
        fill: true,
        viewBox: true,
        xmlns: true
      });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, id: true });
      var div0_nodes = children(div0);
      ul = claim_element(div0_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "sr-only");
      add_location(span, file8, 26, 2, 1528);
      attr_dev(path0, "fill-rule", "evenodd");
      attr_dev(path0, "d", "M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z");
      attr_dev(path0, "clip-rule", "evenodd");
      add_location(path0, file8, 28, 4, 1674);
      attr_dev(svg0, "class", "w-8 h-8");
      attr_dev(svg0, "fill", "currentColor");
      attr_dev(svg0, "viewBox", "0 0 20 20");
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg0, file8, 27, 2, 1574);
      attr_dev(path1, "fill-rule", "evenodd");
      attr_dev(path1, "d", "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z");
      attr_dev(path1, "clip-rule", "evenodd");
      add_location(path1, file8, 39, 4, 2016);
      attr_dev(svg1, "class", "hidden w-8 h-8");
      attr_dev(svg1, "fill", "currentColor");
      attr_dev(svg1, "viewBox", "0 0 20 20");
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg1, file8, 34, 2, 1897);
      attr_dev(button, "data-collapse-toggle", "mobile-menu");
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "class",
        /*buttonClass*/
        ctx[1]
      );
      attr_dev(button, "aria-expanded", "false");
      add_location(button, file8, 19, 1, 1388);
      attr_dev(
        ul,
        "class",
        /*topul*/
        ctx[5]
      );
      add_location(ul, file8, 47, 2, 2365);
      attr_dev(
        div0,
        "class",
        /*topDiv*/
        ctx[0]
      );
      attr_dev(div0, "id", "mobile-menu");
      toggle_class(
        div0,
        "hidden",
        /*barHidden*/
        ctx[10]
      );
      add_location(div0, file8, 46, 1, 2300);
      attr_dev(
        div1,
        "class",
        /*topMenuDiv*/
        ctx[3]
      );
      add_location(div1, file8, 18, 0, 1362);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, span);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, svg0);
      append_hydration_dev(svg0, path0);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, svg1);
      append_hydration_dev(svg1, path1);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*handleClickbtn*/
          ctx[12],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*buttonClass*/
      2) {
        attr_dev(
          button,
          "class",
          /*buttonClass*/
          ctx2[1]
        );
      }
      if (dirty & /*topMenus, activeChildLi, activeDropdownDiv, dropdownLi, topli, childLi, $page*/
      3028) {
        each_value = ensure_array_like_dev(
          /*topMenus*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*topul*/
      32) {
        attr_dev(
          ul,
          "class",
          /*topul*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*topDiv*/
      1) {
        attr_dev(
          div0,
          "class",
          /*topDiv*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*topDiv, barHidden*/
      1025) {
        toggle_class(
          div0,
          "hidden",
          /*barHidden*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*topMenuDiv*/
      8) {
        attr_dev(
          div1,
          "class",
          /*topMenuDiv*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let $page;
  validate_store(page, "page");
  component_subscribe($$self, page, ($$value) => $$invalidate(11, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TopMenu", slots, []);
  let { topDiv = "w-full md:block md:w-auto" } = $$props;
  let { buttonClass = "inline-flex items-center text-base text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200" } = $$props;
  let { childLi = "block py-2 pr-4 pl-3  text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 text-base" } = $$props;
  let { topMenuDiv = "container flex flex-wrap justify-end mx-auto" } = $$props;
  let { topMenus } = $$props;
  let { topul = "flex flex-col mt-4 md:flex-row md:space-x-8 md:mt-0 md:text-md md:font-medium pt-1 bg-gray-200" } = $$props;
  let { topli = "block py-2 pr-4 pl-3 text-gray-700 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0" } = $$props;
  let { activeDropdownDiv = "z-10 w-44 text-lg list-none bg-white rounded divide-y divide-gray-100 shadow" } = $$props;
  let { activeChildLi = "block py-2 px-4 text-base text-gray-700 hover:bg-gray-100" } = $$props;
  let { dropdownLi = "flex justify-between items-center py-2 pr-4 pl-3 w-full text-base font-medium text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:w-auto" } = $$props;
  let barHidden = true;
  const handleClickbtn = () => {
    $$invalidate(10, barHidden = !barHidden);
  };
  $$self.$$.on_mount.push(function() {
    if (topMenus === void 0 && !("topMenus" in $$props || $$self.$$.bound[$$self.$$.props["topMenus"]])) {
      console.warn("<TopMenu> was created without expected prop 'topMenus'");
    }
  });
  const writable_props = [
    "topDiv",
    "buttonClass",
    "childLi",
    "topMenuDiv",
    "topMenus",
    "topul",
    "topli",
    "activeDropdownDiv",
    "activeChildLi",
    "dropdownLi"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TopMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("topDiv" in $$props2)
      $$invalidate(0, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(1, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(2, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(3, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(4, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(5, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(6, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(7, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(8, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(9, dropdownLi = $$props2.dropdownLi);
  };
  $$self.$capture_state = () => ({
    page,
    Dropdown: Dropdown_default,
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    barHidden,
    handleClickbtn,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("topDiv" in $$props2)
      $$invalidate(0, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(1, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(2, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(3, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(4, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(5, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(6, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(7, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(8, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(9, dropdownLi = $$props2.dropdownLi);
    if ("barHidden" in $$props2)
      $$invalidate(10, barHidden = $$props2.barHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    barHidden,
    $page,
    handleClickbtn
  ];
}
var TopMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      topDiv: 0,
      buttonClass: 1,
      childLi: 2,
      topMenuDiv: 3,
      topMenus: 4,
      topul: 5,
      topli: 6,
      activeDropdownDiv: 7,
      activeChildLi: 8,
      dropdownLi: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TopMenu",
      options,
      id: create_fragment9.name
    });
  }
  get topDiv() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topDiv(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClass() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClass(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get childLi() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set childLi(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenuDiv() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenuDiv(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenus() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenus(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topul() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topul(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topli() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topli(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeDropdownDiv() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeDropdownDiv(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeChildLi() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeChildLi(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownLi() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownLi(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TopMenu_default = TopMenu;

// node_modules/svelte-sidebar-menu/Side.svelte
var file9 = "node_modules/svelte-sidebar-menu/Side.svelte";
function create_else_block4(ctx) {
  let div;
  let navbar;
  let t;
  let outsideclick;
  let current;
  navbar = new Navbar_default({
    props: {
      alt: (
        /*alt*/
        ctx[0]
      ),
      hamburgerClass: (
        /*hamburgerClass*/
        ctx[1]
      ),
      headerClass: (
        /*headerClass*/
        ctx[2]
      ),
      logo: (
        /*logo*/
        ctx[3]
      ),
      logoClass: (
        /*logoClass*/
        ctx[4]
      ),
      navClass: (
        /*navClass*/
        ctx[5]
      ),
      siteClass: (
        /*siteClass*/
        ctx[6]
      ),
      siteName: (
        /*siteName*/
        ctx[7]
      ),
      spanClass: (
        /*spanClass*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  outsideclick = new OutsideClick_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(navbar.$$.fragment);
      t = space();
      create_component(outsideclick.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(navbar.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(outsideclick.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*sideWrapperClass*/
        ctx[22]
      );
      add_location(div, file9, 70, 1, 2758);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(navbar, div, null);
      append_hydration_dev(div, t);
      mount_component(outsideclick, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & /*alt*/
      1)
        navbar_changes.alt = /*alt*/
        ctx2[0];
      if (dirty & /*hamburgerClass*/
      2)
        navbar_changes.hamburgerClass = /*hamburgerClass*/
        ctx2[1];
      if (dirty & /*headerClass*/
      4)
        navbar_changes.headerClass = /*headerClass*/
        ctx2[2];
      if (dirty & /*logo*/
      8)
        navbar_changes.logo = /*logo*/
        ctx2[3];
      if (dirty & /*logoClass*/
      16)
        navbar_changes.logoClass = /*logoClass*/
        ctx2[4];
      if (dirty & /*navClass*/
      32)
        navbar_changes.navClass = /*navClass*/
        ctx2[5];
      if (dirty & /*siteClass*/
      64)
        navbar_changes.siteClass = /*siteClass*/
        ctx2[6];
      if (dirty & /*siteName*/
      128)
        navbar_changes.siteName = /*siteName*/
        ctx2[7];
      if (dirty & /*spanClass*/
      256)
        navbar_changes.spanClass = /*spanClass*/
        ctx2[8];
      if (dirty & /*$$scope, buttonClass, childLi, topDiv, topMenuDiv, topMenus, topul, topli, activeDropdownDiv, activeChildLi, dropdownLi*/
      34078208) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      const outsideclick_changes = {};
      if (dirty & /*$$scope, asideClass, transitionType, transitionParams*/
      37224448) {
        outsideclick_changes.$$scope = { dirty, ctx: ctx2 };
      }
      outsideclick.$set(outsideclick_changes);
      if (!current || dirty & /*sideWrapperClass*/
      4194304) {
        attr_dev(
          div,
          "class",
          /*sideWrapperClass*/
          ctx2[22]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar.$$.fragment, local);
      transition_in(outsideclick.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(outsideclick.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(navbar);
      destroy_component(outsideclick);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(70:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let outsideclick;
  let current;
  outsideclick = new OutsideClick_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(outsideclick.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(outsideclick.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(outsideclick, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const outsideclick_changes = {};
      if (dirty & /*$$scope, sideWrapperClass, asideClass, transitionType, transitionParams, alt, hamburgerClass, headerClass, logo, logoClass, navClass, siteClass, siteName, spanClass, buttonClass, childLi, topDiv, topMenuDiv, topMenus, topul, topli, activeDropdownDiv, activeChildLi, dropdownLi*/
      41943039) {
        outsideclick_changes.$$scope = { dirty, ctx: ctx2 };
      }
      outsideclick.$set(outsideclick_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(outsideclick.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(outsideclick.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(outsideclick, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(37:0) {#if $sidebarOpen}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let topmenu;
  let current;
  topmenu = new TopMenu_default({
    props: {
      buttonClass: (
        /*buttonClass*/
        ctx[10]
      ),
      childLi: (
        /*childLi*/
        ctx[11]
      ),
      topDiv: (
        /*topDiv*/
        ctx[9]
      ),
      topMenuDiv: (
        /*topMenuDiv*/
        ctx[12]
      ),
      topMenus: (
        /*topMenus*/
        ctx[13]
      ),
      topul: (
        /*topul*/
        ctx[14]
      ),
      topli: (
        /*topli*/
        ctx[15]
      ),
      activeDropdownDiv: (
        /*activeDropdownDiv*/
        ctx[16]
      ),
      activeChildLi: (
        /*activeChildLi*/
        ctx[17]
      ),
      dropdownLi: (
        /*dropdownLi*/
        ctx[18]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(topmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(topmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(topmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const topmenu_changes = {};
      if (dirty & /*buttonClass*/
      1024)
        topmenu_changes.buttonClass = /*buttonClass*/
        ctx2[10];
      if (dirty & /*childLi*/
      2048)
        topmenu_changes.childLi = /*childLi*/
        ctx2[11];
      if (dirty & /*topDiv*/
      512)
        topmenu_changes.topDiv = /*topDiv*/
        ctx2[9];
      if (dirty & /*topMenuDiv*/
      4096)
        topmenu_changes.topMenuDiv = /*topMenuDiv*/
        ctx2[12];
      if (dirty & /*topMenus*/
      8192)
        topmenu_changes.topMenus = /*topMenus*/
        ctx2[13];
      if (dirty & /*topul*/
      16384)
        topmenu_changes.topul = /*topul*/
        ctx2[14];
      if (dirty & /*topli*/
      32768)
        topmenu_changes.topli = /*topli*/
        ctx2[15];
      if (dirty & /*activeDropdownDiv*/
      65536)
        topmenu_changes.activeDropdownDiv = /*activeDropdownDiv*/
        ctx2[16];
      if (dirty & /*activeChildLi*/
      131072)
        topmenu_changes.activeChildLi = /*activeChildLi*/
        ctx2[17];
      if (dirty & /*dropdownLi*/
      262144)
        topmenu_changes.dropdownLi = /*dropdownLi*/
        ctx2[18];
      topmenu.$set(topmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(topmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(topmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(topmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(72:2) <Navbar    {alt}    {hamburgerClass}    {headerClass}    {logo}    {logoClass}    {navClass}    {siteClass}    {siteName}    {spanClass}   >",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(97:3) <Aside {asideClass} {transitionType} {transitionParams}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let aside;
  let current;
  aside = new Aside_default({
    props: {
      asideClass: (
        /*asideClass*/
        ctx[19]
      ),
      transitionType: (
        /*transitionType*/
        ctx[21]
      ),
      transitionParams: (
        /*transitionParams*/
        ctx[20]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(aside.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(aside.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(aside, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const aside_changes = {};
      if (dirty & /*asideClass*/
      524288)
        aside_changes.asideClass = /*asideClass*/
        ctx2[19];
      if (dirty & /*transitionType*/
      2097152)
        aside_changes.transitionType = /*transitionType*/
        ctx2[21];
      if (dirty & /*transitionParams*/
      1048576)
        aside_changes.transitionParams = /*transitionParams*/
        ctx2[20];
      if (dirty & /*$$scope*/
      33554432) {
        aside_changes.$$scope = { dirty, ctx: ctx2 };
      }
      aside.$set(aside_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(aside.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(aside.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(aside, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(96:2) <OutsideClick>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let topmenu;
  let current;
  topmenu = new TopMenu_default({
    props: {
      buttonClass: (
        /*buttonClass*/
        ctx[10]
      ),
      childLi: (
        /*childLi*/
        ctx[11]
      ),
      topDiv: (
        /*topDiv*/
        ctx[9]
      ),
      topMenuDiv: (
        /*topMenuDiv*/
        ctx[12]
      ),
      topMenus: (
        /*topMenus*/
        ctx[13]
      ),
      topul: (
        /*topul*/
        ctx[14]
      ),
      topli: (
        /*topli*/
        ctx[15]
      ),
      activeDropdownDiv: (
        /*activeDropdownDiv*/
        ctx[16]
      ),
      activeChildLi: (
        /*activeChildLi*/
        ctx[17]
      ),
      dropdownLi: (
        /*dropdownLi*/
        ctx[18]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(topmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(topmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(topmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const topmenu_changes = {};
      if (dirty & /*buttonClass*/
      1024)
        topmenu_changes.buttonClass = /*buttonClass*/
        ctx2[10];
      if (dirty & /*childLi*/
      2048)
        topmenu_changes.childLi = /*childLi*/
        ctx2[11];
      if (dirty & /*topDiv*/
      512)
        topmenu_changes.topDiv = /*topDiv*/
        ctx2[9];
      if (dirty & /*topMenuDiv*/
      4096)
        topmenu_changes.topMenuDiv = /*topMenuDiv*/
        ctx2[12];
      if (dirty & /*topMenus*/
      8192)
        topmenu_changes.topMenus = /*topMenus*/
        ctx2[13];
      if (dirty & /*topul*/
      16384)
        topmenu_changes.topul = /*topul*/
        ctx2[14];
      if (dirty & /*topli*/
      32768)
        topmenu_changes.topli = /*topli*/
        ctx2[15];
      if (dirty & /*activeDropdownDiv*/
      65536)
        topmenu_changes.activeDropdownDiv = /*activeDropdownDiv*/
        ctx2[16];
      if (dirty & /*activeChildLi*/
      131072)
        topmenu_changes.activeChildLi = /*activeChildLi*/
        ctx2[17];
      if (dirty & /*dropdownLi*/
      262144)
        topmenu_changes.dropdownLi = /*dropdownLi*/
        ctx2[18];
      topmenu.$set(topmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(topmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(topmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(topmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(40:3) <Navbar     {alt}     {hamburgerClass}     {headerClass}     {logo}     {logoClass}     {navClass}     {siteClass}     {siteName}     {spanClass}    >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(65:3) <Aside {asideClass} {transitionType} {transitionParams}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let div;
  let navbar;
  let t;
  let aside;
  let current;
  navbar = new Navbar_default({
    props: {
      alt: (
        /*alt*/
        ctx[0]
      ),
      hamburgerClass: (
        /*hamburgerClass*/
        ctx[1]
      ),
      headerClass: (
        /*headerClass*/
        ctx[2]
      ),
      logo: (
        /*logo*/
        ctx[3]
      ),
      logoClass: (
        /*logoClass*/
        ctx[4]
      ),
      navClass: (
        /*navClass*/
        ctx[5]
      ),
      siteClass: (
        /*siteClass*/
        ctx[6]
      ),
      siteName: (
        /*siteName*/
        ctx[7]
      ),
      spanClass: (
        /*spanClass*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  aside = new Aside_default({
    props: {
      asideClass: (
        /*asideClass*/
        ctx[19]
      ),
      transitionType: (
        /*transitionType*/
        ctx[21]
      ),
      transitionParams: (
        /*transitionParams*/
        ctx[20]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(navbar.$$.fragment);
      t = space();
      create_component(aside.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(navbar.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(aside.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*sideWrapperClass*/
        ctx[22]
      );
      add_location(div, file9, 38, 2, 2247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(navbar, div, null);
      append_hydration_dev(div, t);
      mount_component(aside, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & /*alt*/
      1)
        navbar_changes.alt = /*alt*/
        ctx2[0];
      if (dirty & /*hamburgerClass*/
      2)
        navbar_changes.hamburgerClass = /*hamburgerClass*/
        ctx2[1];
      if (dirty & /*headerClass*/
      4)
        navbar_changes.headerClass = /*headerClass*/
        ctx2[2];
      if (dirty & /*logo*/
      8)
        navbar_changes.logo = /*logo*/
        ctx2[3];
      if (dirty & /*logoClass*/
      16)
        navbar_changes.logoClass = /*logoClass*/
        ctx2[4];
      if (dirty & /*navClass*/
      32)
        navbar_changes.navClass = /*navClass*/
        ctx2[5];
      if (dirty & /*siteClass*/
      64)
        navbar_changes.siteClass = /*siteClass*/
        ctx2[6];
      if (dirty & /*siteName*/
      128)
        navbar_changes.siteName = /*siteName*/
        ctx2[7];
      if (dirty & /*spanClass*/
      256)
        navbar_changes.spanClass = /*spanClass*/
        ctx2[8];
      if (dirty & /*$$scope, buttonClass, childLi, topDiv, topMenuDiv, topMenus, topul, topli, activeDropdownDiv, activeChildLi, dropdownLi*/
      34078208) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      const aside_changes = {};
      if (dirty & /*asideClass*/
      524288)
        aside_changes.asideClass = /*asideClass*/
        ctx2[19];
      if (dirty & /*transitionType*/
      2097152)
        aside_changes.transitionType = /*transitionType*/
        ctx2[21];
      if (dirty & /*transitionParams*/
      1048576)
        aside_changes.transitionParams = /*transitionParams*/
        ctx2[20];
      if (dirty & /*$$scope*/
      33554432) {
        aside_changes.$$scope = { dirty, ctx: ctx2 };
      }
      aside.$set(aside_changes);
      if (!current || dirty & /*sideWrapperClass*/
      4194304) {
        attr_dev(
          div,
          "class",
          /*sideWrapperClass*/
          ctx2[22]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar.$$.fragment, local);
      transition_in(aside.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(aside.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(navbar);
      destroy_component(aside);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(38:1) <OutsideClick>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$sidebarOpen*/
      ctx2[23]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let $sidebarOpen;
  validate_store(sidebarOpen, "sidebarOpen");
  component_subscribe($$self, sidebarOpen, ($$value) => $$invalidate(23, $sidebarOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Side", slots, ["default"]);
  let { alt = "" } = $$props;
  let { hamburgerClass = "text-gray-500 hover:text-gray-700 cursor-pointer mr-4 border-none focus:outline-none lg:hidden" } = $$props;
  let { headerClass = "bg-gray-200 pt-4 px-10 items-center text-gray-600" } = $$props;
  let { logo = "" } = $$props;
  let { logoClass = "" } = $$props;
  let { navClass = "flex relative" } = $$props;
  let { siteClass = "w-1/4 h-12 text-lg pt-1 pl-12" } = $$props;
  let { siteName = "Demo" } = $$props;
  let { spanClass = "pl-2 self-center text-lg font-semibold text-gray-900 whitespace-nowrap" } = $$props;
  let { topDiv = "w-full md:block md:w-auto" } = $$props;
  let { buttonClass = "inline-flex items-center text-base text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200" } = $$props;
  let { childLi = "block py-2 pr-4 pl-3  text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 text-base" } = $$props;
  let { topMenuDiv = "container flex flex-wrap justify-end mx-auto" } = $$props;
  let { topMenus } = $$props;
  let { topul = "flex flex-col mt-4 md:flex-row md:space-x-8 md:mt-0 md:text-md md:font-medium pt-1 bg-white" } = $$props;
  let { topli = "block py-2 pr-4 pl-3 text-gray-700 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0" } = $$props;
  let { activeDropdownDiv = "z-10 w-44 text-lg list-none bg-white rounded divide-y divide-gray-100 shadow" } = $$props;
  let { activeChildLi = "block py-2 px-4 text-base text-gray-700 hover:bg-gray-100" } = $$props;
  let { dropdownLi = "flex justify-between items-center py-2 pr-4 pl-3 w-full text-base font-medium text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:w-auto" } = $$props;
  let { asideClass = "absolute w-auto border-r-2 shadow-lg z-50 bg-white h-screen overflow-scroll" } = $$props;
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  let { sideWrapperClass = "fixed z-50 top-0 left-0 w-full" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (topMenus === void 0 && !("topMenus" in $$props || $$self.$$.bound[$$self.$$.props["topMenus"]])) {
      console.warn("<Side> was created without expected prop 'topMenus'");
    }
  });
  const writable_props = [
    "alt",
    "hamburgerClass",
    "headerClass",
    "logo",
    "logoClass",
    "navClass",
    "siteClass",
    "siteName",
    "spanClass",
    "topDiv",
    "buttonClass",
    "childLi",
    "topMenuDiv",
    "topMenus",
    "topul",
    "topli",
    "activeDropdownDiv",
    "activeChildLi",
    "dropdownLi",
    "asideClass",
    "transitionParams",
    "transitionType",
    "sideWrapperClass"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Side> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("alt" in $$props2)
      $$invalidate(0, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(1, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(2, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(3, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(4, logoClass = $$props2.logoClass);
    if ("navClass" in $$props2)
      $$invalidate(5, navClass = $$props2.navClass);
    if ("siteClass" in $$props2)
      $$invalidate(6, siteClass = $$props2.siteClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("spanClass" in $$props2)
      $$invalidate(8, spanClass = $$props2.spanClass);
    if ("topDiv" in $$props2)
      $$invalidate(9, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(10, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(11, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(12, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(13, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(14, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(15, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(16, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(17, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(18, dropdownLi = $$props2.dropdownLi);
    if ("asideClass" in $$props2)
      $$invalidate(19, asideClass = $$props2.asideClass);
    if ("transitionParams" in $$props2)
      $$invalidate(20, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(21, transitionType = $$props2.transitionType);
    if ("sideWrapperClass" in $$props2)
      $$invalidate(22, sideWrapperClass = $$props2.sideWrapperClass);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Aside: Aside_default,
    Navbar: Navbar_default,
    TopMenu: TopMenu_default,
    OutsideClick: OutsideClick_default,
    sidebarOpen,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass,
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    asideClass,
    transitionParams,
    transitionType,
    sideWrapperClass,
    $sidebarOpen
  });
  $$self.$inject_state = ($$props2) => {
    if ("alt" in $$props2)
      $$invalidate(0, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(1, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(2, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(3, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(4, logoClass = $$props2.logoClass);
    if ("navClass" in $$props2)
      $$invalidate(5, navClass = $$props2.navClass);
    if ("siteClass" in $$props2)
      $$invalidate(6, siteClass = $$props2.siteClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("spanClass" in $$props2)
      $$invalidate(8, spanClass = $$props2.spanClass);
    if ("topDiv" in $$props2)
      $$invalidate(9, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(10, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(11, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(12, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(13, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(14, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(15, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(16, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(17, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(18, dropdownLi = $$props2.dropdownLi);
    if ("asideClass" in $$props2)
      $$invalidate(19, asideClass = $$props2.asideClass);
    if ("transitionParams" in $$props2)
      $$invalidate(20, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(21, transitionType = $$props2.transitionType);
    if ("sideWrapperClass" in $$props2)
      $$invalidate(22, sideWrapperClass = $$props2.sideWrapperClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass,
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    asideClass,
    transitionParams,
    transitionType,
    sideWrapperClass,
    $sidebarOpen,
    slots,
    $$scope
  ];
}
var Side = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      alt: 0,
      hamburgerClass: 1,
      headerClass: 2,
      logo: 3,
      logoClass: 4,
      navClass: 5,
      siteClass: 6,
      siteName: 7,
      spanClass: 8,
      topDiv: 9,
      buttonClass: 10,
      childLi: 11,
      topMenuDiv: 12,
      topMenus: 13,
      topul: 14,
      topli: 15,
      activeDropdownDiv: 16,
      activeChildLi: 17,
      dropdownLi: 18,
      asideClass: 19,
      transitionParams: 20,
      transitionType: 21,
      sideWrapperClass: 22
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Side",
      options,
      id: create_fragment10.name
    });
  }
  get alt() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hamburgerClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logoClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logoClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spanClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spanClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topDiv() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topDiv(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get childLi() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set childLi(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenuDiv() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenuDiv(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenus() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenus(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topul() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topul(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topli() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topli(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeDropdownDiv() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeDropdownDiv(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeChildLi() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeChildLi(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownLi() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownLi(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionParams() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionParams(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionType() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionType(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideWrapperClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideWrapperClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Side_default = Side;

// node_modules/svelte-sidebar-menu/click_outside.js
function clickOutside(node) {
  const handleClick = (event) => {
    if (!node.contains(event.target)) {
      node.dispatchEvent(new CustomEvent("outclick"));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}

// node_modules/svelte-sidebar-menu/OutsideClick.svelte
var file10 = "node_modules/svelte-sidebar-menu/OutsideClick.svelte";
function create_fragment11(ctx) {
  let div;
  let clickOutside_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file10, 11, 0, 337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(clickOutside_action = clickOutside.call(null, div)),
          listen_dev(
            div,
            "outclick",
            /*handleOutClick*/
            ctx[0],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $sidebarStayOpen;
  validate_store(sidebarStayOpen, "sidebarStayOpen");
  component_subscribe($$self, sidebarStayOpen, ($$value) => $$invalidate(3, $sidebarStayOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutsideClick", slots, ["default"]);
  const handleOutClick = () => {
    if ($sidebarStayOpen === false) {
      sidebarOpen.update((n) => n = false);
      sidebarIsInert.update((n) => n = true);
    }
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OutsideClick> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    clickOutside,
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    handleOutClick,
    $sidebarStayOpen
  });
  return [handleOutClick, $$scope, slots];
}
var OutsideClick = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutsideClick",
      options,
      id: create_fragment11.name
    });
  }
};
var OutsideClick_default = OutsideClick;
export {
  Aside_default as Aside,
  Nav_default as Nav,
  Navbar_default as Navbar,
  OutsideClick_default as OutsideClick,
  Responsive_default as Responsive,
  Side_default as Side,
  Sidebar_default as Sidebar,
  SidebarList_default as SidebarList,
  TopMenu_default as TopMenu,
  clickOutside,
  sidebarIsInert,
  sidebarOpen,
  sidebarStayOpen
};
//# sourceMappingURL=svelte-sidebar-menu.js.map
