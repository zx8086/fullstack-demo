import { AnyVariables, OperationResult, Client, OperationContext, RequestPolicy, GraphQLRequestParams, ClientOptions } from '@urql/core';
export * from '@urql/core';
import { Readable, Writable } from 'svelte/store';

/** An {@link OperationResult} with an added {@link OperationResultState.fetching} flag.
 *
 * @remarks
 * Stores will contain a readable state based on {@link OperationResult | OperationResults}
 * they received.
 */
interface OperationResultState<Data = any, Variables extends AnyVariables = AnyVariables> extends OperationResult<Data, Variables> {
    /** Indicates whether the store is waiting for a new {@link OperationResult}.
     *
     * @remarks
     * When a store starts executing a GraphQL operation, `fetching` is
     * set to `true` until a result arrives.
     *
     * Hint: This is subtly different than whether the operation is actually
     * fetching, and doesn’t indicate whether an operation is being re-executed
     * in the background. For this, see {@link OperationResult.stale}.
     */
    fetching: boolean;
}
/** A Readable store of {@link OperationResultState}. */
type OperationResultStore<Data = any, Variables extends AnyVariables = AnyVariables> = Readable<OperationResultState<Data, Variables>>;
/** A pausable Svelte store.
 *
 * @remarks
 * The {@link queryStore} and {@link useSubscription} store allow
 * you to pause execution and resume it later on, which is managed
 * by a `pause` option passed to them.
 *
 * A `Pauseable` allows execution of GraphQL operations to be paused,
 * which means a {@link OperationResultStore} won’t update with new
 * results or execute new operations, and to be resumed later on.
 */
interface Pausable {
    /** Indicates whether a store is currently paused.
     *
     * @remarks
     * When a {@link OperationResultStore} has been paused, it will stop
     * receiving updates from the {@link Client} and won’t execute GraphQL
     * operations, until this writable becomes `true` or
     * {@link Pausable.resume} is called.
     *
     * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for
     * documentation on the `Pausable`.
     */
    isPaused$: Writable<boolean>;
    /** Pauses a GraphQL operation to stop it from executing.
     *
     * @remarks
     * Pauses an {@link OperationResultStore}’s GraphQL operation, which
     * stops it from receiving updates from the {@link Client} and to stop
     * an ongoing operation.
     *
     * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for
     * documentation on the `Pausable`.
     */
    pause(): void;
    /** Resumes a paused GraphQL operation if it’s currently paused.
     *
     * @remarks
     * Resumes or starts {@link OperationResultStore}’s GraphQL operation,
     * if it’s currently paused.
     *
     * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for
     * documentation on the `Pausable`.
     */
    resume(): void;
}

/** Input arguments for the {@link queryStore} function.
 *
 * @param query - The GraphQL query that the `queryStore` executes.
 * @param variables - The variables for the GraphQL query that `queryStore` executes.
 */
type QueryArgs<Data = any, Variables extends AnyVariables = AnyVariables> = {
    /** The {@link Client} using which the query will be executed.
     *
     * @remarks
     * If you’ve previously provided a {@link Client} on Svelte’s context
     * this can be set to {@link getContextClient}’s return value.
     */
    client: Client;
    /** Updates the {@link OperationContext} for the executed GraphQL query operation.
     *
     * @remarks
     * `context` may be passed to {@link queryStore}, to update the {@link OperationContext}
     * of a query operation. This may be used to update the `context` that exchanges
     * will receive for a single hook.
     *
     * @example
     * ```ts
     * queryStore({
     *   query,
     *   context: {
     *     additionalTypenames: ['Item'],
     *   },
     * });
     * ```
     */
    context?: Partial<OperationContext>;
    /** Sets the {@link RequestPolicy} for the executed GraphQL query operation.
     *
     * @remarks
     * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation
     * that the {@link queryStore} executes, and indicates a caching strategy for cache exchanges.
     *
     * For example, when set to `'cache-and-network'`, the `queryStore` will
     * receive a cached result with `stale: true` and an API request will be
     * sent in the background.
     *
     * @see {@link OperationContext.requestPolicy} for where this value is set.
     */
    requestPolicy?: RequestPolicy;
    /** Prevents the {@link queryStore} from automatically executing GraphQL query operations.
     *
     * @remarks
     * `pause` may be set to `true` to stop the {@link queryStore} from executing
     * automatically. The store will stop receiving updates from the {@link Client}
     * and won’t execute the query operation, until either it’s set to `false`
     * or {@link Pausable.resume} is called.
     *
     * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for
     * documentation on the `pause` option.
     */
    pause?: boolean;
} & GraphQLRequestParams<Data, Variables>;
/** Function to create a `queryStore` that runs a GraphQL query and updates with GraphQL results.
 *
 * @param args - a {@link QueryArgs} object, to pass a `query`, `variables`, and options.
 * @returns a {@link OperationResultStore} of query results, which implements {@link Pausable}.
 *
 * @remarks
 * `queryStore` allows GraphQL queries to be defined as Svelte stores.
 * Given {@link QueryArgs.query}, it executes the GraphQL query on the
 * {@link QueryArgs.client}.
 *
 * The returned store updates with {@link OperationResult} values when
 * the `Client` has new results for the query.
 *
 * @see {@link https://urql.dev/goto/docs/basics/svelte#queries} for `queryStore` docs.
 *
 * @example
 * ```ts
 * import { queryStore, gql, getContextClient } from '@urql/svelte';
 *
 * const todos = queryStore({
 *   client: getContextClient(),
 *   query: gql`{ todos { id, title } }`,
 * });
 * ```
 */
declare function queryStore<Data = any, Variables extends AnyVariables = AnyVariables>(args: QueryArgs<Data, Variables>): OperationResultStore<Data, Variables> & Pausable;

/** Input arguments for the {@link mutationStore} function.
 *
 * @param query - The GraphQL mutation that the `mutationStore` executes.
 * @param variables - The variables for the GraphQL mutation that `mutationStore` executes.
 */
type MutationArgs<Data = any, Variables extends AnyVariables = AnyVariables> = {
    /** The {@link Client} using which the subscription will be started.
     *
     * @remarks
     * If you’ve previously provided a {@link Client} on Svelte’s context
     * this can be set to {@link getContextClient}’s return value.
     */
    client: Client;
    /** Updates the {@link OperationContext} for the GraphQL mutation operation.
     *
     * @remarks
     * `context` may be passed to {@link mutationStore}, to update the
     * {@link OperationContext} of a mutation operation. This may be used to update
     * the `context` that exchanges will receive for a single hook.
     *
     * @example
     * ```ts
     * mutationStore({
     *   query,
     *   context: {
     *     additionalTypenames: ['Item'],
     *   },
     * });
     * ```
     */
    context?: Partial<OperationContext>;
} & GraphQLRequestParams<Data, Variables>;
/** Function to create a `mutationStore` that runs a GraphQL mutation and updates with a GraphQL result.
 *
 * @param args - a {@link MutationArgs} object, to pass a `query`, `variables`, and options.
 * @returns a {@link OperationResultStore} of the mutation’s result.
 *
 * @remarks
 * `mutationStore` allows a GraphQL mutation to be defined as a Svelte store.
 * Given {@link MutationArgs.query}, it executes the GraphQL mutation on the
 * {@link MutationArgs.client}.
 *
 * The returned store updates with an {@link OperationResult} when
 * the `Client` returns a result for the mutation.
 *
 * Hint: It’s often easier to use {@link Client.mutation} if you’re
 * creating a mutation imperatively and don’t need a store.
 *
 * @see {@link https://urql.dev/goto/docs/basics/svelte#mutations} for
 * `mutationStore` docs.
 *
 * @example
 * ```ts
 * import { mutationStore, gql, getContextClient } from '@urql/svelte';
 *
 * const client = getContextClient();
 *
 * let result;
 * function updateTodo({ id, title }) {
 *   result = queryStore({
 *     client,
 *     query: gql`
 *       mutation($id: ID!, $title: String!) {
 *         updateTodo(id: $id, title: $title) { id, title }
 *       }
 *     `,
 *     variables: { id, title },
 *   });
 * }
 * ```
 */
declare function mutationStore<Data = any, Variables extends AnyVariables = AnyVariables>(args: MutationArgs<Data, Variables>): OperationResultStore<Data, Variables>;

/** Combines previous data with an incoming subscription result’s data.
 *
 * @remarks
 * A `SubscriptionHandler` may be passed to {@link subscriptionStore} to
 * aggregate subscription results into a combined `data` value on the
 * {@link OperationResultStore}.
 *
 * This is useful when a subscription event delivers a single item, while
 * you’d like to display a list of events.
 *
 * @example
 * ```ts
 * const NotificationsSubscription = gql`
 *   subscription { newNotification { id, text } }
 * `;
 *
 * subscriptionStore(
 *   { query: NotificationsSubscription },
 *   function combineNotifications(notifications = [], data) {
 *     return [...notifications, data.newNotification];
 *   },
 * );
 * ```
 */
type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;
/** Input arguments for the {@link subscriptionStore} function.
 *
 * @param query - The GraphQL subscription that the `subscriptionStore` executes.
 * @param variables - The variables for the GraphQL subscription that `subscriptionStore` executes.
 */
type SubscriptionArgs<Data = any, Variables extends AnyVariables = AnyVariables> = {
    /** The {@link Client} using which the subscription will be started.
     *
     * @remarks
     * If you’ve previously provided a {@link Client} on Svelte’s context
     * this can be set to {@link getContextClient}’s return value.
     */
    client: Client;
    /** Updates the {@link OperationContext} for the GraphQL subscription operation.
     *
     * @remarks
     * `context` may be passed to {@link subscriptionStore}, to update the
     * {@link OperationContext} of a subscription operation. This may be used to update
     * the `context` that exchanges will receive for a single hook.
     *
     * @example
     * ```ts
     * subscriptionStore({
     *   query,
     *   context: {
     *     additionalTypenames: ['Item'],
     *   },
     * });
     * ```
     */
    context?: Partial<OperationContext>;
    /** Prevents the {@link subscriptionStore} from automatically starting the GraphQL subscription.
     *
     * @remarks
     * `pause` may be set to `true` to stop the {@link subscriptionStore} from starting
     * its subscription automatically. The store won't execute the subscription operation,
     * until either it’s set to `false` or {@link Pausable.resume} is called.
     */
    pause?: boolean;
} & GraphQLRequestParams<Data, Variables>;
/** Function to create a `subscriptionStore` that starts a GraphQL subscription.
 *
 * @param args - a {@link QueryArgs} object, to pass a `query`, `variables`, and options.
 * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.
 * @returns a {@link OperationResultStore} of subscription results, which implements {@link Pausable}.
 *
 * @remarks
 * `subscriptionStore` allows GraphQL subscriptions to be defined as Svelte stores.
 * Given {@link SubscriptionArgs.query}, it executes the GraphQL subsription on the
 * {@link SubscriptionArgs.client}.
 *
 * The returned store updates with {@link OperationResult} values when
 * the `Client` has new results for the subscription.
 *
 * @see {@link https://urql.dev/goto/docs/advanced/subscriptions#svelte} for
 * `subscriptionStore` docs.
 *
 * @example
 * ```ts
 * import { subscriptionStore, gql, getContextClient } from '@urql/svelte';
 *
 * const todos = subscriptionStore({
 *   client: getContextClient(),
 *   query: gql`
 *     subscription {
 *       newNotification { id, text }
 *     }
 *   `,
 *   },
 *   function combineNotifications(notifications = [], data) {
 *     return [...notifications, data.newNotification];
 *   },
 * );
 * ```
 */
declare function subscriptionStore<Data, Result = Data, Variables extends AnyVariables = AnyVariables>(args: SubscriptionArgs<Data, Variables>, handler?: SubscriptionHandler<Data, Result>): OperationResultStore<Result, Variables> & Pausable;

/** Returns a provided {@link Client}.
 *
 * @remarks
 * `getContextClient` returns the {@link Client} that’s previously
 * been provided on Svelte’s context with {@link setContextClient}.
 *
 * This is useful to create a `Client` on Svelte’s context once, and
 * then pass it to all GraphQL store functions without importing it
 * from a singleton export.
 *
 * @throws
 * In development, if `getContextClient` can’t get a {@link Client}
 * from Svelte’s context, an error will be thrown.
 */
declare const getContextClient: () => Client;
/** Provides a {@link Client} to a component’s children.
 *
 * @remarks
 * `setContextClient` updates the Svelte context to provide
 * a {@link Client} to be later retrieved using the
 * {@link getContextClient} function.
 */
declare const setContextClient: (client: Client) => void;
/** Creates a {@link Client} and provides it to a component’s children.
 *
 * @param args - a {@link ClientOptions} object to create a `Client` with.
 * @returns the created {@link Client}.
 *
 * @remarks
 * `initContextClient` is a convenience wrapper around
 * `setContextClient` that accepts {@link ClientOptions},
 * creates a {@link Client} and provides it to be later
 * retrieved using the {@link getContextClient} function.
 */
declare const initContextClient: (args: ClientOptions) => Client;

export { MutationArgs, OperationResultState, OperationResultStore, Pausable, QueryArgs, SubscriptionArgs, SubscriptionHandler, getContextClient, initContextClient, mutationStore, queryStore, setContextClient, subscriptionStore };
