Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@urql/core');
var wonka = require('wonka');
var store = require('svelte/store');
var svelte = require('svelte');

/** An {@link OperationResult} with an added {@link OperationResultState.fetching} flag.
 *
 * @remarks
 * Stores will contain a readable state based on {@link OperationResult | OperationResults}
 * they received.
 */

/** A Readable store of {@link OperationResultState}. */

/** Consumes a {@link Readable} as a {@link Source}.
 * @internal
 */
var fromStore = store$ => wonka.make(observer => store$.subscribe(observer.next));
var initialResult = {
  operation: undefined,
  fetching: false,
  data: undefined,
  error: undefined,
  extensions: undefined,
  hasNext: false,
  stale: false
};

/** A pausable Svelte store.
 *
 * @remarks
 * The {@link queryStore} and {@link useSubscription} store allow
 * you to pause execution and resume it later on, which is managed
 * by a `pause` option passed to them.
 *
 * A `Pauseable` allows execution of GraphQL operations to be paused,
 * which means a {@link OperationResultStore} won’t update with new
 * results or execute new operations, and to be resumed later on.
 */

/** Creates a {@link Pausable}.
 * @internal
 */
var createPausable = isPaused$ => ({
  isPaused$,
  pause() {
    isPaused$.set(true);
  },
  resume() {
    isPaused$.set(false);
  }
});

/** Input arguments for the {@link queryStore} function.
 *
 * @param query - The GraphQL query that the `queryStore` executes.
 * @param variables - The variables for the GraphQL query that `queryStore` executes.
 */

/** Function to create a `queryStore` that runs a GraphQL query and updates with GraphQL results.
 *
 * @param args - a {@link QueryArgs} object, to pass a `query`, `variables`, and options.
 * @returns a {@link OperationResultStore} of query results, which implements {@link Pausable}.
 *
 * @remarks
 * `queryStore` allows GraphQL queries to be defined as Svelte stores.
 * Given {@link QueryArgs.query}, it executes the GraphQL query on the
 * {@link QueryArgs.client}.
 *
 * The returned store updates with {@link OperationResult} values when
 * the `Client` has new results for the query.
 *
 * @see {@link https://urql.dev/goto/docs/basics/svelte#queries} for `queryStore` docs.
 *
 * @example
 * ```ts
 * import { queryStore, gql, getContextClient } from '@urql/svelte';
 *
 * const todos = queryStore({
 *   client: getContextClient(),
 *   query: gql`{ todos { id, title } }`,
 * });
 * ```
 */
function queryStore(args) {
  var request = core.createRequest(args.query, args.variables);
  var context = {
    requestPolicy: args.requestPolicy,
    ...args.context
  };
  var operation = args.client.createRequestOperation('query', request, context);
  var initialState = {
    ...initialResult,
    operation
  };
  var isPaused$ = store.writable(!!args.pause);
  var result$ = store.writable(initialState, () => {
    return wonka.subscribe(result => {
      result$.set(result);
    })(wonka.scan((result, partial) => ({
      ...result,
      ...partial
    }), initialState)(wonka.switchMap(isPaused => {
      if (isPaused) {
        return wonka.never;
      }
      return wonka.concat([wonka.fromValue({
        fetching: true,
        stale: false
      }), wonka.map(({
        stale,
        data,
        error,
        extensions,
        operation
      }) => ({
        fetching: false,
        stale: !!stale,
        data,
        error,
        operation,
        extensions
      }))(args.client.executeRequestOperation(operation)), wonka.fromValue({
        fetching: false
      })]);
    })(fromStore(isPaused$)))).unsubscribe;
  });
  return {
    ...store.derived(result$, (result, set) => {
      set(result);
    }),
    ...createPausable(isPaused$)
  };
}

/** Input arguments for the {@link mutationStore} function.
 *
 * @param query - The GraphQL mutation that the `mutationStore` executes.
 * @param variables - The variables for the GraphQL mutation that `mutationStore` executes.
 */

/** Function to create a `mutationStore` that runs a GraphQL mutation and updates with a GraphQL result.
 *
 * @param args - a {@link MutationArgs} object, to pass a `query`, `variables`, and options.
 * @returns a {@link OperationResultStore} of the mutation’s result.
 *
 * @remarks
 * `mutationStore` allows a GraphQL mutation to be defined as a Svelte store.
 * Given {@link MutationArgs.query}, it executes the GraphQL mutation on the
 * {@link MutationArgs.client}.
 *
 * The returned store updates with an {@link OperationResult} when
 * the `Client` returns a result for the mutation.
 *
 * Hint: It’s often easier to use {@link Client.mutation} if you’re
 * creating a mutation imperatively and don’t need a store.
 *
 * @see {@link https://urql.dev/goto/docs/basics/svelte#mutations} for
 * `mutationStore` docs.
 *
 * @example
 * ```ts
 * import { mutationStore, gql, getContextClient } from '@urql/svelte';
 *
 * const client = getContextClient();
 *
 * let result;
 * function updateTodo({ id, title }) {
 *   result = queryStore({
 *     client,
 *     query: gql`
 *       mutation($id: ID!, $title: String!) {
 *         updateTodo(id: $id, title: $title) { id, title }
 *       }
 *     `,
 *     variables: { id, title },
 *   });
 * }
 * ```
 */
function mutationStore(args) {
  var request = core.createRequest(args.query, args.variables);
  var operation = args.client.createRequestOperation('mutation', request, args.context);
  var initialState = {
    ...initialResult,
    operation,
    fetching: true
  };
  var result$ = store.writable(initialState);
  var subscription = wonka.subscribe(result => {
    result$.set(result);
  })(wonka.scan((result, partial) => ({
    ...result,
    ...partial
  }), initialState)(wonka.map(({
    stale,
    data,
    error,
    extensions,
    operation
  }) => ({
    fetching: false,
    stale,
    data,
    error,
    operation,
    extensions
  }))(args.client.executeRequestOperation(operation))));
  return store.derived(result$, (result, set) => {
    set(result);
    return subscription.unsubscribe;
  });
}

/** Combines previous data with an incoming subscription result’s data.
 *
 * @remarks
 * A `SubscriptionHandler` may be passed to {@link subscriptionStore} to
 * aggregate subscription results into a combined `data` value on the
 * {@link OperationResultStore}.
 *
 * This is useful when a subscription event delivers a single item, while
 * you’d like to display a list of events.
 *
 * @example
 * ```ts
 * const NotificationsSubscription = gql`
 *   subscription { newNotification { id, text } }
 * `;
 *
 * subscriptionStore(
 *   { query: NotificationsSubscription },
 *   function combineNotifications(notifications = [], data) {
 *     return [...notifications, data.newNotification];
 *   },
 * );
 * ```
 */

/** Input arguments for the {@link subscriptionStore} function.
 *
 * @param query - The GraphQL subscription that the `subscriptionStore` executes.
 * @param variables - The variables for the GraphQL subscription that `subscriptionStore` executes.
 */

/** Function to create a `subscriptionStore` that starts a GraphQL subscription.
 *
 * @param args - a {@link QueryArgs} object, to pass a `query`, `variables`, and options.
 * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.
 * @returns a {@link OperationResultStore} of subscription results, which implements {@link Pausable}.
 *
 * @remarks
 * `subscriptionStore` allows GraphQL subscriptions to be defined as Svelte stores.
 * Given {@link SubscriptionArgs.query}, it executes the GraphQL subsription on the
 * {@link SubscriptionArgs.client}.
 *
 * The returned store updates with {@link OperationResult} values when
 * the `Client` has new results for the subscription.
 *
 * @see {@link https://urql.dev/goto/docs/advanced/subscriptions#svelte} for
 * `subscriptionStore` docs.
 *
 * @example
 * ```ts
 * import { subscriptionStore, gql, getContextClient } from '@urql/svelte';
 *
 * const todos = subscriptionStore({
 *   client: getContextClient(),
 *   query: gql`
 *     subscription {
 *       newNotification { id, text }
 *     }
 *   `,
 *   },
 *   function combineNotifications(notifications = [], data) {
 *     return [...notifications, data.newNotification];
 *   },
 * );
 * ```
 */
function subscriptionStore(args, handler) {
  var request = core.createRequest(args.query, args.variables);
  var operation = args.client.createRequestOperation('subscription', request, args.context);
  var initialState = {
    ...initialResult,
    operation,
    fetching: true
  };
  var isPaused$ = store.writable(!!args.pause);
  var result$ = store.writable(initialState, () => {
    return wonka.subscribe(result => {
      result$.set(result);
    })(wonka.scan((result, partial) => {
      var data = partial.data !== undefined ? typeof handler === 'function' ? handler(result.data, partial.data) : partial.data : result.data;
      return {
        ...result,
        ...partial,
        data
      };
    }, initialState)(wonka.switchMap(isPaused => {
      if (isPaused) {
        return wonka.never;
      }
      return wonka.concat([wonka.fromValue({
        fetching: true,
        stale: false
      }), wonka.map(({
        stale,
        data,
        error,
        extensions,
        operation
      }) => ({
        fetching: true,
        stale: !!stale,
        data,
        error,
        operation,
        extensions
      }))(args.client.executeRequestOperation(operation)), wonka.fromValue({
        fetching: false
      })]);
    })(fromStore(isPaused$)))).unsubscribe;
  });
  return {
    ...store.derived(result$, (result, set) => {
      set(result);
    }),
    ...createPausable(isPaused$)
  };
}

var _contextKey = '$$_urql';

/** Returns a provided {@link Client}.
 *
 * @remarks
 * `getContextClient` returns the {@link Client} that’s previously
 * been provided on Svelte’s context with {@link setContextClient}.
 *
 * This is useful to create a `Client` on Svelte’s context once, and
 * then pass it to all GraphQL store functions without importing it
 * from a singleton export.
 *
 * @throws
 * In development, if `getContextClient` can’t get a {@link Client}
 * from Svelte’s context, an error will be thrown.
 */
var getContextClient = () => {
  var client = svelte.getContext(_contextKey);
  if (process.env.NODE_ENV !== 'production' && !client) {
    throw new Error('No urql Client was found in Svelte context. Did you forget to call setContextClient?');
  }
  return client;
};

/** Provides a {@link Client} to a component’s children.
 *
 * @remarks
 * `setContextClient` updates the Svelte context to provide
 * a {@link Client} to be later retrieved using the
 * {@link getContextClient} function.
 */
var setContextClient = client => {
  svelte.setContext(_contextKey, client);
};

/** Creates a {@link Client} and provides it to a component’s children.
 *
 * @param args - a {@link ClientOptions} object to create a `Client` with.
 * @returns the created {@link Client}.
 *
 * @remarks
 * `initContextClient` is a convenience wrapper around
 * `setContextClient` that accepts {@link ClientOptions},
 * creates a {@link Client} and provides it to be later
 * retrieved using the {@link getContextClient} function.
 */
var initContextClient = args => {
  var client = new core.Client(args);
  setContextClient(client);
  return client;
};

exports.getContextClient = getContextClient;
exports.initContextClient = initContextClient;
exports.mutationStore = mutationStore;
exports.queryStore = queryStore;
exports.setContextClient = setContextClient;
exports.subscriptionStore = subscriptionStore;
Object.keys(core).forEach(function (k) {
if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
enumerable: true,
get: function () { return core[k]; }
});
});
//# sourceMappingURL=urql-svelte.js.map
