{"version":3,"file":"urql-svelte.min.mjs","sources":["../src/common.ts","../src/queryStore.ts","../src/mutationStore.ts","../src/subscriptionStore.ts","../src/context.ts"],"sourcesContent":["import type { Readable, Writable } from 'svelte/store';\nimport type { AnyVariables, OperationResult } from '@urql/core';\nimport { Source, make } from 'wonka';\n\n/** An {@link OperationResult} with an added {@link OperationResultState.fetching} flag.\n *\n * @remarks\n * Stores will contain a readable state based on {@link OperationResult | OperationResults}\n * they received.\n */\nexport interface OperationResultState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends OperationResult<Data, Variables> {\n  /** Indicates whether the store is waiting for a new {@link OperationResult}.\n   *\n   * @remarks\n   * When a store starts executing a GraphQL operation, `fetching` is\n   * set to `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the operation is actually\n   * fetching, and doesn’t indicate whether an operation is being re-executed\n   * in the background. For this, see {@link OperationResult.stale}.\n   */\n  fetching: boolean;\n}\n\n/** A Readable store of {@link OperationResultState}. */\nexport type OperationResultStore<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = Readable<OperationResultState<Data, Variables>>;\n\n/** Consumes a {@link Readable} as a {@link Source}.\n * @internal\n */\nexport const fromStore = <T>(store$: Readable<T>): Source<T> =>\n  make(observer => store$.subscribe(observer.next));\n\nexport const initialResult = {\n  operation: undefined,\n  fetching: false,\n  data: undefined,\n  error: undefined,\n  extensions: undefined,\n  hasNext: false,\n  stale: false,\n};\n\n/** A pausable Svelte store.\n *\n * @remarks\n * The {@link queryStore} and {@link useSubscription} store allow\n * you to pause execution and resume it later on, which is managed\n * by a `pause` option passed to them.\n *\n * A `Pauseable` allows execution of GraphQL operations to be paused,\n * which means a {@link OperationResultStore} won’t update with new\n * results or execute new operations, and to be resumed later on.\n */\nexport interface Pausable {\n  /** Indicates whether a store is currently paused.\n   *\n   * @remarks\n   * When a {@link OperationResultStore} has been paused, it will stop\n   * receiving updates from the {@link Client} and won’t execute GraphQL\n   * operations, until this writable becomes `true` or\n   * {@link Pausable.resume} is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for\n   * documentation on the `Pausable`.\n   */\n  isPaused$: Writable<boolean>;\n  /** Pauses a GraphQL operation to stop it from executing.\n   *\n   * @remarks\n   * Pauses an {@link OperationResultStore}’s GraphQL operation, which\n   * stops it from receiving updates from the {@link Client} and to stop\n   * an ongoing operation.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for\n   * documentation on the `Pausable`.\n   */\n  pause(): void;\n  /** Resumes a paused GraphQL operation if it’s currently paused.\n   *\n   * @remarks\n   * Resumes or starts {@link OperationResultStore}’s GraphQL operation,\n   * if it’s currently paused.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for\n   * documentation on the `Pausable`.\n   */\n  resume(): void;\n}\n\n/** Creates a {@link Pausable}.\n * @internal\n */\nexport const createPausable = (isPaused$: Writable<boolean>): Pausable => ({\n  isPaused$,\n  pause() {\n    isPaused$.set(true);\n  },\n  resume() {\n    isPaused$.set(false);\n  },\n});\n","import {\n  Client,\n  GraphQLRequestParams,\n  AnyVariables,\n  OperationContext,\n  RequestPolicy,\n  createRequest,\n} from '@urql/core';\n\nimport {\n  Source,\n  pipe,\n  map,\n  fromValue,\n  switchMap,\n  subscribe,\n  concat,\n  scan,\n  never,\n} from 'wonka';\n\nimport { derived, writable } from 'svelte/store';\n\nimport {\n  OperationResultState,\n  OperationResultStore,\n  Pausable,\n  initialResult,\n  createPausable,\n  fromStore,\n} from './common';\n\n/** Input arguments for the {@link queryStore} function.\n *\n * @param query - The GraphQL query that the `queryStore` executes.\n * @param variables - The variables for the GraphQL query that `queryStore` executes.\n */\nexport type QueryArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** The {@link Client} using which the query will be executed.\n   *\n   * @remarks\n   * If you’ve previously provided a {@link Client} on Svelte’s context\n   * this can be set to {@link getContextClient}’s return value.\n   */\n  client: Client;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link queryStore}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * queryStore({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Sets the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that the {@link queryStore} executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, the `queryStore` will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Prevents the {@link queryStore} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop the {@link queryStore} from executing\n   * automatically. The store will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or {@link Pausable.resume} is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/svelte#pausing-queries} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Function to create a `queryStore` that runs a GraphQL query and updates with GraphQL results.\n *\n * @param args - a {@link QueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link OperationResultStore} of query results, which implements {@link Pausable}.\n *\n * @remarks\n * `queryStore` allows GraphQL queries to be defined as Svelte stores.\n * Given {@link QueryArgs.query}, it executes the GraphQL query on the\n * {@link QueryArgs.client}.\n *\n * The returned store updates with {@link OperationResult} values when\n * the `Client` has new results for the query.\n *\n * @see {@link https://urql.dev/goto/docs/basics/svelte#queries} for `queryStore` docs.\n *\n * @example\n * ```ts\n * import { queryStore, gql, getContextClient } from '@urql/svelte';\n *\n * const todos = queryStore({\n *   client: getContextClient(),\n *   query: gql`{ todos { id, title } }`,\n * });\n * ```\n */\nexport function queryStore<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  args: QueryArgs<Data, Variables>\n): OperationResultStore<Data, Variables> & Pausable {\n  const request = createRequest(args.query, args.variables as Variables);\n\n  const context: Partial<OperationContext> = {\n    requestPolicy: args.requestPolicy,\n    ...args.context,\n  };\n\n  const operation = args.client.createRequestOperation(\n    'query',\n    request,\n    context\n  );\n  const initialState: OperationResultState<Data, Variables> = {\n    ...initialResult,\n    operation,\n  };\n\n  const isPaused$ = writable(!!args.pause);\n\n  const result$ = writable(initialState, () => {\n    return pipe(\n      fromStore(isPaused$),\n      switchMap(\n        (isPaused): Source<Partial<OperationResultState<Data, Variables>>> => {\n          if (isPaused) {\n            return never as any;\n          }\n\n          return concat<Partial<OperationResultState<Data, Variables>>>([\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              args.client.executeRequestOperation(operation),\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                operation,\n                extensions,\n              }))\n            ),\n            fromValue({ fetching: false }),\n          ]);\n        }\n      ),\n      scan(\n        (result: OperationResultState<Data, Variables>, partial) => ({\n          ...result,\n          ...partial,\n        }),\n        initialState\n      ),\n      subscribe(result => {\n        result$.set(result);\n      })\n    ).unsubscribe;\n  });\n\n  return {\n    ...derived(result$, (result, set) => {\n      set(result);\n    }),\n    ...createPausable(isPaused$),\n  };\n}\n","import { pipe, map, scan, subscribe } from 'wonka';\nimport { derived, writable } from 'svelte/store';\n\nimport {\n  AnyVariables,\n  GraphQLRequestParams,\n  Client,\n  OperationContext,\n  createRequest,\n} from '@urql/core';\n\nimport {\n  OperationResultState,\n  OperationResultStore,\n  initialResult,\n} from './common';\n\n/** Input arguments for the {@link mutationStore} function.\n *\n * @param query - The GraphQL mutation that the `mutationStore` executes.\n * @param variables - The variables for the GraphQL mutation that `mutationStore` executes.\n */\nexport type MutationArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** The {@link Client} using which the subscription will be started.\n   *\n   * @remarks\n   * If you’ve previously provided a {@link Client} on Svelte’s context\n   * this can be set to {@link getContextClient}’s return value.\n   */\n  client: Client;\n  /** Updates the {@link OperationContext} for the GraphQL mutation operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link mutationStore}, to update the\n   * {@link OperationContext} of a mutation operation. This may be used to update\n   * the `context` that exchanges will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * mutationStore({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Function to create a `mutationStore` that runs a GraphQL mutation and updates with a GraphQL result.\n *\n * @param args - a {@link MutationArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link OperationResultStore} of the mutation’s result.\n *\n * @remarks\n * `mutationStore` allows a GraphQL mutation to be defined as a Svelte store.\n * Given {@link MutationArgs.query}, it executes the GraphQL mutation on the\n * {@link MutationArgs.client}.\n *\n * The returned store updates with an {@link OperationResult} when\n * the `Client` returns a result for the mutation.\n *\n * Hint: It’s often easier to use {@link Client.mutation} if you’re\n * creating a mutation imperatively and don’t need a store.\n *\n * @see {@link https://urql.dev/goto/docs/basics/svelte#mutations} for\n * `mutationStore` docs.\n *\n * @example\n * ```ts\n * import { mutationStore, gql, getContextClient } from '@urql/svelte';\n *\n * const client = getContextClient();\n *\n * let result;\n * function updateTodo({ id, title }) {\n *   result = queryStore({\n *     client,\n *     query: gql`\n *       mutation($id: ID!, $title: String!) {\n *         updateTodo(id: $id, title: $title) { id, title }\n *       }\n *     `,\n *     variables: { id, title },\n *   });\n * }\n * ```\n */\nexport function mutationStore<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(args: MutationArgs<Data, Variables>): OperationResultStore<Data, Variables> {\n  const request = createRequest(args.query, args.variables as Variables);\n  const operation = args.client.createRequestOperation(\n    'mutation',\n    request,\n    args.context\n  );\n  const initialState: OperationResultState<Data, Variables> = {\n    ...initialResult,\n    operation,\n    fetching: true,\n  };\n  const result$ = writable(initialState);\n\n  const subscription = pipe(\n    pipe(\n      args.client.executeRequestOperation(operation),\n      map(({ stale, data, error, extensions, operation }) => ({\n        fetching: false,\n        stale,\n        data,\n        error,\n        operation,\n        extensions,\n      }))\n    ),\n    scan(\n      (result: OperationResultState<Data, Variables>, partial) => ({\n        ...result,\n        ...partial,\n      }),\n      initialState\n    ),\n    subscribe(result => {\n      result$.set(result);\n    })\n  );\n\n  return derived(result$, (result, set) => {\n    set(result);\n    return subscription.unsubscribe;\n  });\n}\n","import {\n  AnyVariables,\n  GraphQLRequestParams,\n  Client,\n  OperationContext,\n  createRequest,\n} from '@urql/core';\n\nimport {\n  Source,\n  pipe,\n  map,\n  fromValue,\n  switchMap,\n  subscribe,\n  concat,\n  scan,\n  never,\n} from 'wonka';\n\nimport { derived, writable } from 'svelte/store';\n\nimport {\n  OperationResultState,\n  OperationResultStore,\n  Pausable,\n  initialResult,\n  createPausable,\n  fromStore,\n} from './common';\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link subscriptionStore} to\n * aggregate subscription results into a combined `data` value on the\n * {@link OperationResultStore}.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * subscriptionStore(\n *   { query: NotificationsSubscription },\n *   function combineNotifications(notifications = [], data) {\n *     return [...notifications, data.newNotification];\n *   },\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** Input arguments for the {@link subscriptionStore} function.\n *\n * @param query - The GraphQL subscription that the `subscriptionStore` executes.\n * @param variables - The variables for the GraphQL subscription that `subscriptionStore` executes.\n */\nexport type SubscriptionArgs<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = {\n  /** The {@link Client} using which the subscription will be started.\n   *\n   * @remarks\n   * If you’ve previously provided a {@link Client} on Svelte’s context\n   * this can be set to {@link getContextClient}’s return value.\n   */\n  client: Client;\n  /** Updates the {@link OperationContext} for the GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link subscriptionStore}, to update the\n   * {@link OperationContext} of a subscription operation. This may be used to update\n   * the `context` that exchanges will receive for a single hook.\n   *\n   * @example\n   * ```ts\n   * subscriptionStore({\n   *   query,\n   *   context: {\n   *     additionalTypenames: ['Item'],\n   *   },\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents the {@link subscriptionStore} from automatically starting the GraphQL subscription.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop the {@link subscriptionStore} from starting\n   * its subscription automatically. The store won't execute the subscription operation,\n   * until either it’s set to `false` or {@link Pausable.resume} is called.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Function to create a `subscriptionStore` that starts a GraphQL subscription.\n *\n * @param args - a {@link QueryArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link OperationResultStore} of subscription results, which implements {@link Pausable}.\n *\n * @remarks\n * `subscriptionStore` allows GraphQL subscriptions to be defined as Svelte stores.\n * Given {@link SubscriptionArgs.query}, it executes the GraphQL subsription on the\n * {@link SubscriptionArgs.client}.\n *\n * The returned store updates with {@link OperationResult} values when\n * the `Client` has new results for the subscription.\n *\n * @see {@link https://urql.dev/goto/docs/advanced/subscriptions#svelte} for\n * `subscriptionStore` docs.\n *\n * @example\n * ```ts\n * import { subscriptionStore, gql, getContextClient } from '@urql/svelte';\n *\n * const todos = subscriptionStore({\n *   client: getContextClient(),\n *   query: gql`\n *     subscription {\n *       newNotification { id, text }\n *     }\n *   `,\n *   },\n *   function combineNotifications(notifications = [], data) {\n *     return [...notifications, data.newNotification];\n *   },\n * );\n * ```\n */\nexport function subscriptionStore<\n  Data,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(\n  args: SubscriptionArgs<Data, Variables>,\n  handler?: SubscriptionHandler<Data, Result>\n): OperationResultStore<Result, Variables> & Pausable {\n  const request = createRequest(args.query, args.variables as Variables);\n\n  const operation = args.client.createRequestOperation(\n    'subscription',\n    request,\n    args.context\n  );\n  const initialState: OperationResultState<Result, Variables> = {\n    ...initialResult,\n    operation,\n    fetching: true,\n  };\n\n  const isPaused$ = writable(!!args.pause);\n\n  const result$ = writable(initialState, () => {\n    return pipe(\n      fromStore(isPaused$),\n      switchMap(\n        (isPaused): Source<Partial<OperationResultState<Data, Variables>>> => {\n          if (isPaused) {\n            return never as any;\n          }\n\n          return concat<Partial<OperationResultState<Data, Variables>>>([\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              args.client.executeRequestOperation(operation),\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                operation,\n                extensions,\n              }))\n            ),\n            fromValue({ fetching: false }),\n          ]);\n        }\n      ),\n      scan((result: OperationResultState<Result, Variables>, partial) => {\n        const data =\n          partial.data !== undefined\n            ? typeof handler === 'function'\n              ? handler(result.data, partial.data)\n              : partial.data\n            : result.data;\n        return {\n          ...result,\n          ...partial,\n          data,\n        } as OperationResultState<Result, Variables>;\n      }, initialState),\n      subscribe(result => {\n        result$.set(result);\n      })\n    ).unsubscribe;\n  });\n\n  return {\n    ...derived(result$, (result, set) => {\n      set(result);\n    }),\n    ...createPausable(isPaused$),\n  };\n}\n","import { setContext, getContext } from 'svelte';\nimport { Client, ClientOptions } from '@urql/core';\n\nconst _contextKey = '$$_urql';\n\n/** Returns a provided {@link Client}.\n *\n * @remarks\n * `getContextClient` returns the {@link Client} that’s previously\n * been provided on Svelte’s context with {@link setContextClient}.\n *\n * This is useful to create a `Client` on Svelte’s context once, and\n * then pass it to all GraphQL store functions without importing it\n * from a singleton export.\n *\n * @throws\n * In development, if `getContextClient` can’t get a {@link Client}\n * from Svelte’s context, an error will be thrown.\n */\nexport const getContextClient = (): Client => {\n  const client = getContext(_contextKey);\n  if (process.env.NODE_ENV !== 'production' && !client) {\n    throw new Error(\n      'No urql Client was found in Svelte context. Did you forget to call setContextClient?'\n    );\n  }\n\n  return client as Client;\n};\n\n/** Provides a {@link Client} to a component’s children.\n *\n * @remarks\n * `setContextClient` updates the Svelte context to provide\n * a {@link Client} to be later retrieved using the\n * {@link getContextClient} function.\n */\nexport const setContextClient = (client: Client): void => {\n  setContext(_contextKey, client);\n};\n\n/** Creates a {@link Client} and provides it to a component’s children.\n *\n * @param args - a {@link ClientOptions} object to create a `Client` with.\n * @returns the created {@link Client}.\n *\n * @remarks\n * `initContextClient` is a convenience wrapper around\n * `setContextClient` that accepts {@link ClientOptions},\n * creates a {@link Client} and provides it to be later\n * retrieved using the {@link getContextClient} function.\n */\nexport const initContextClient = (args: ClientOptions): Client => {\n  const client = new Client(args);\n  setContextClient(client);\n  return client;\n};\n"],"names":["fromStore","store$","make","observer","subscribe","next","initialResult","operation","undefined","fetching","data","error","extensions","hasNext","stale","createPausable","isPaused$","pause","set","resume","queryStore","args","request","createRequest","query","variables","context","requestPolicy","client","createRequestOperation","initialState","writable","result$","result","scan","partial","switchMap","isPaused","never","concat","fromValue","map","executeRequestOperation","unsubscribe","derived","mutationStore","subscription","subscriptionStore","handler","_contextKey","getContextClient","getContext","setContextClient","setContext","initContextClient","Client"],"mappings":"4SAoCO,IAAMA,EAAgBC,GAC3BC,GAAKC,GAAYF,EAAOG,UAAUD,EAASE,QAEhCC,EAAgB,CAC3BC,eAAWC,EACXC,UAAU,EACVC,UAAMF,EACNG,WAAOH,EACPI,gBAAYJ,EACZK,SAAS,EACTC,OAAO,GAqDIC,EAAkBC,IAA4C,CACzEA,YACAC,QACED,EAAUE,KAAI,EACf,EACDC,SACEH,EAAUE,KAAI,EAChB,ICYK,SAASE,EAIdC,GAEA,IAAMC,EAAUC,EAAcF,EAAKG,MAAOH,EAAKI,WAEzCC,EAAqC,CACzCC,cAAeN,EAAKM,iBACjBN,EAAKK,SAGJnB,EAAYc,EAAKO,OAAOC,uBAC5B,QACAP,EACAI,GAEII,EAAsD,IACvDxB,EACHC,aAGIS,EAAYe,IAAWV,EAAKJ,OAE5Be,EAAUD,EAASD,GAAc,IAiCnC1B,GAAU6B,IACRD,EAAQd,IAAIe,EAAO,GADrB7B,CAPA8B,GACE,CAACD,EAA+CE,KAAa,IACxDF,KACAE,KAELL,EALFI,CAvBAE,GACGC,GACKA,EACKC,EAGFC,EAAuD,CAC5DC,EAAU,CAAE/B,UAAU,EAAMK,OAAO,IAGjC2B,GAAI,EAAG3B,QAAOJ,OAAMC,QAAOC,aAAYL,gBAAiB,CACtDE,UAAU,EACVK,QAASA,EACTJ,OACAC,QACAJ,YACAK,gBANF6B,CADApB,EAAKO,OAAOc,wBAAwBnC,IAUtCiC,EAAU,CAAE/B,UAAU,OAnB5B2B,CADApC,EAAUgB,MAkCV2B,cAGJ,MAAO,IACFC,EAAQZ,GAAS,CAACC,EAAQf,KAC3BA,EAAIe,EAAO,OAEVlB,EAAeC,GAEtB,CChGO,SAAS6B,EAGdxB,GACA,IAAMC,EAAUC,EAAcF,EAAKG,MAAOH,EAAKI,WACzClB,EAAYc,EAAKO,OAAOC,uBAC5B,WACAP,EACAD,EAAKK,SAEDI,EAAsD,IACvDxB,EACHC,YACAE,UAAU,GAENuB,EAAUD,EAASD,GAEnBgB,EAmBJ1C,GAAU6B,IACRD,EAAQd,IAAIe,EAAO,GADrB7B,CAPA8B,GACE,CAACD,EAA+CE,KAAa,IACxDF,KACAE,KAELL,EALFI,CATEO,GAAI,EAAG3B,QAAOJ,OAAMC,QAAOC,aAAYL,gBAAiB,CACtDE,UAAU,EACVK,QACAJ,OACAC,QACAJ,YACAK,gBANF6B,CADApB,EAAKO,OAAOc,wBAAwBnC,MAsBxC,OAAOqC,EAAQZ,GAAS,CAACC,EAAQf,KAC/BA,EAAIe,GACGa,EAAaH,cAExB,CCDO,SAASI,EAKd1B,EACA2B,GAEA,IAAM1B,EAAUC,EAAcF,EAAKG,MAAOH,EAAKI,WAEzClB,EAAYc,EAAKO,OAAOC,uBAC5B,eACAP,EACAD,EAAKK,SAEDI,EAAwD,IACzDxB,EACHC,YACAE,UAAU,GAGNO,EAAYe,IAAWV,EAAKJ,OAE5Be,EAAUD,EAASD,GAAc,IAuCnC1B,GAAU6B,IACRD,EAAQd,IAAIe,EAAO,GADrB7B,CAbA8B,GAAK,CAACD,EAAiDE,KACrD,IAAMzB,OACaF,IAAjB2B,EAAQzB,KACe,mBAAZsC,EACLA,EAAQf,EAAOvB,KAAMyB,EAAQzB,MAC7ByB,EAAQzB,KACVuB,EAAOvB,KACb,MAAO,IACFuB,KACAE,EACHzB,OACD,GACAoB,EAZHI,CAvBAE,GACGC,GACKA,EACKC,EAGFC,EAAuD,CAC5DC,EAAU,CAAE/B,UAAU,EAAMK,OAAO,IAGjC2B,GAAI,EAAG3B,QAAOJ,OAAMC,QAAOC,aAAYL,gBAAiB,CACtDE,UAAU,EACVK,QAASA,EACTJ,OACAC,QACAJ,YACAK,gBANF6B,CADApB,EAAKO,OAAOc,wBAAwBnC,IAUtCiC,EAAU,CAAE/B,UAAU,OAnB5B2B,CADApC,EAAUgB,MAwCV2B,cAGJ,MAAO,IACFC,EAAQZ,GAAS,CAACC,EAAQf,KAC3BA,EAAIe,EAAO,OAEVlB,EAAeC,GAEtB,CC/MA,IAAMiC,EAAc,UAgBPC,EAAmBA,IACfC,EAAWF,GAiBfG,EAAoBxB,IAC/ByB,EAAWJ,EAAarB,EAAO,EAcpB0B,EAAqBjC,IAChC,IAAMO,EAAS,IAAI2B,EAAOlC,GAE1B,OADA+B,EAAiBxB,GACVA,CAAM"}