#!/usr/bin/env node

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/error.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/error.js"(exports) {
    var CommanderError2 = class extends Error {
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/argument.js"(exports) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      name() {
        return this._name;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      argRequired() {
        this.required = true;
        return this;
      }
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports.Argument = Argument2;
    exports.humanReadableArgName = humanReadableArgName;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/help.js
var require_help = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/help.js"(exports) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
      }
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a2, b2) => {
            return a2.name().localeCompare(b2.name());
          });
        }
        return visibleCommands;
      }
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          const getSortKey = (option) => {
            return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
          };
          visibleOptions.sort((a2, b2) => {
            return getSortKey(a2).localeCompare(getSortKey(b2));
          });
        }
        return visibleOptions;
      }
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        return [];
      }
      subcommandTerm(cmd) {
        const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
      }
      optionTerm(option) {
        return option.flags;
      }
      argumentTerm(argument) {
        return argument.name();
      }
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        return parentCmdNames + cmdName + " " + cmd.usage();
      }
      commandDescription(cmd) {
        return cmd.description();
      }
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([commandDescription, ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      wrap(str, width, indent3, minColumnWidth = 40) {
        if (str.match(/[\n]\s+/))
          return str;
        const columnWidth = width - indent3;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent3);
        const columnText = str.slice(indent3);
        const indentString = " ".repeat(indent3);
        const regex = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i2) => {
          if (line.slice(-1) === "\n") {
            line = line.slice(0, line.length - 1);
          }
          return (i2 > 0 ? indentString : "") + line.trimRight();
        }).join("\n");
      }
    };
    exports.Help = Help2;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/option.js
var require_option = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/option.js"(exports) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      implies(impliedOptionValues) {
        this.implied = Object.assign(this.implied || {}, impliedOptionValues);
        return this;
      }
      env(name) {
        this.envVar = name;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports.Option = Option2;
    exports.splitOptionFlags = splitOptionFlags;
    exports.DualOptions = DualOptions;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/suggestSimilar.js"(exports) {
    var maxDistance = 3;
    function editDistance(a2, b2) {
      if (Math.abs(a2.length - b2.length) > maxDistance)
        return Math.max(a2.length, b2.length);
      const d3 = [];
      for (let i2 = 0; i2 <= a2.length; i2++) {
        d3[i2] = [i2];
      }
      for (let j2 = 0; j2 <= b2.length; j2++) {
        d3[0][j2] = j2;
      }
      for (let j2 = 1; j2 <= b2.length; j2++) {
        for (let i2 = 1; i2 <= a2.length; i2++) {
          let cost = 1;
          if (a2[i2 - 1] === b2[j2 - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d3[i2][j2] = Math.min(
            d3[i2 - 1][j2] + 1,
            d3[i2][j2 - 1] + 1,
            d3[i2 - 1][j2 - 1] + cost
          );
          if (i2 > 1 && j2 > 1 && a2[i2 - 1] === b2[j2 - 2] && a2[i2 - 2] === b2[j2 - 1]) {
            d3[i2][j2] = Math.min(d3[i2][j2], d3[i2 - 2][j2 - 2] + 1);
          }
        }
      }
      return d3[a2.length][b2.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a2, b2) => a2.localeCompare(b2));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports.suggestSimilar = suggestSimilar;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/command.js
var require_command = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/command.js"(exports) {
    var EventEmitter = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path3 = require("path");
    var fs3 = require("fs");
    var process2 = require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class extends EventEmitter {
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      createCommand(name) {
        return new Command2(name);
      }
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this._args.push(argument);
        return this;
      }
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `${invalidValueMessage} ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m3 = regex.exec(val);
            return m3 ? m3[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process2.argv;
          if (process2.versions && process2.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path3.resolve(baseDir, baseName);
          if (fs3.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path3.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find((ext) => fs3.existsSync(`${localBin}${ext}`));
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs3.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path3.resolve(path3.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path3.basename(this._scriptPath, path3.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path3.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process2.exit.bind(process2));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError2(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let hookResult;
        hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, "preSubcommand");
        hookResult = this._chainOrCall(hookResult, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return hookResult;
      }
      _checkNumberOfArguments() {
        this._args.forEach((arg, i2) => {
          if (arg.required && this.args[i2] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v2) => {
                  return myParseArg(declaredArg, v2, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, "preAction");
          actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            actionResult = this._chainOrCall(actionResult, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          actionResult = this._chainOrCallHooks(actionResult, "postAction");
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(
          (option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          }
        );
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      _checkForConflictingOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd._checkForConflictingLocalOptions();
        }
      }
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i2 = 0; i2 < len; i2++) {
            const key = this.options[i2].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      optsWithGlobals() {
        return getCommandAndParents(this).reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      error(message, errorOptions) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
          });
        });
      }
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this._args.length;
        const s2 = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s2} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this._args.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      nameFromFilename(filename) {
        this._name = path3.basename(filename, path3.extname(filename));
        return this;
      }
      executableDir(path4) {
        if (path4 === void 0)
          return this._executableDir;
        this._executableDir = path4;
        return this;
      }
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit("afterHelp", context);
        getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context));
      }
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports.Command = Command2;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/index.js
var require_commander = __commonJS({
  "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/index.js"(exports, module2) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports = module2.exports = new Command2();
    exports.program = exports;
    exports.Argument = Argument2;
    exports.Command = Command2;
    exports.CommanderError = CommanderError2;
    exports.Help = Help2;
    exports.InvalidArgumentError = InvalidArgumentError2;
    exports.InvalidOptionArgumentError = InvalidArgumentError2;
    exports.Option = Option2;
  }
});

// ../../node_modules/.pnpm/minimatch@5.1.2/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "../../node_modules/.pnpm/minimatch@5.1.2/node_modules/minimatch/lib/path.js"(exports, module2) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a2, b2, str) {
      if (a2 instanceof RegExp)
        a2 = maybeMatch(a2, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r3 = range(a2, b2, str);
      return r3 && {
        start: r3[0],
        end: r3[1],
        pre: str.slice(0, r3[0]),
        body: str.slice(r3[0] + a2.length, r3[1]),
        post: str.slice(r3[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m3 = str.match(reg);
      return m3 ? m3[0] : null;
    }
    balanced.range = range;
    function range(a2, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a2);
      var bi = str.indexOf(b2, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a2 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a2, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return str.split(",");
      var pre = m3.pre;
      var body = m3.body;
      var post = m3.post;
      var p3 = pre.split(",");
      p3[p3.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p3[p3.length - 1] += postParts.shift();
        p3.push.apply(p3, postParts);
      }
      parts.push.apply(parts, p3);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y3) {
      return i2 <= y3;
    }
    function gte(i2, y3) {
      return i2 >= y3;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return [str];
      var pre = m3.pre;
      var post = m3.post.length ? expand(m3.post, false) : [""];
      if (/\$$/.test(m3.pre)) {
        for (var k3 = 0; k3 < post.length; k3++) {
          var expansion = pre + "{" + m3.body + "}" + post[k3];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m3.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m3.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m3.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m3.post.match(/,.*\}/)) {
            str = m3.pre + "{" + m3.body + escClose + m3.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m3.body.split(/\.\./);
        } else {
          n = parseCommaParts(m3.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p3) {
                return m3.pre + n[0] + p3;
              });
            }
          }
        }
        var N3;
        if (isSequence) {
          var x3 = numeric(n[0]);
          var y3 = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y3 < x3;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N3 = [];
          for (var i2 = x3; test(i2, y3); i2 += incr) {
            var c2;
            if (isAlphaSequence) {
              c2 = String.fromCharCode(i2);
              if (c2 === "\\")
                c2 = "";
            } else {
              c2 = String(i2);
              if (pad) {
                var need = width - c2.length;
                if (need > 0) {
                  var z3 = new Array(need + 1).join("0");
                  if (i2 < 0)
                    c2 = "-" + z3 + c2.slice(1);
                  else
                    c2 = z3 + c2;
                }
              }
            }
            N3.push(c2);
          }
        } else {
          N3 = [];
          for (var j2 = 0; j2 < n.length; j2++) {
            N3.push.apply(N3, expand(n[j2], false));
          }
        }
        for (var j2 = 0; j2 < N3.length; j2++) {
          for (var k3 = 0; k3 < post.length; k3++) {
            var expansion = pre + N3[j2] + post[k3];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/.pnpm/minimatch@5.1.2/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../node_modules/.pnpm/minimatch@5.1.2/node_modules/minimatch/minimatch.js"(exports, module2) {
    var minimatch2 = module2.exports = (p3, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p3);
    };
    module2.exports = minimatch2;
    var path3 = require_path();
    minimatch2.sep = path3.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch2.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s2) => s2.split("").reduce((set, c2) => {
      set[c2] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch2.filter = (pattern, options = {}) => (p3, i2, list) => minimatch2(p3, pattern, options);
    var ext = (a2, b2 = {}) => {
      const t3 = {};
      Object.keys(a2).forEach((k3) => t3[k3] = a2[k3]);
      Object.keys(b2).forEach((k3) => t3[k3] = b2[k3]);
      return t3;
    };
    minimatch2.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      const orig = minimatch2;
      const m3 = (p3, pattern, options) => orig(p3, pattern, ext(def, options));
      m3.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m3.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m3.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m3.defaults = (options) => orig.defaults(ext(def, options));
      m3.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m3.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m3.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m3;
    };
    minimatch2.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch2.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch2.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f5) => mm.match(f5));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s2) => s2.replace(/\\(.)/g, "$1");
    var charUnescape = (s2) => s2.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s2) => s2.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s2) => s2.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s2, si, set2) => s2.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s2) => s2.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p3 = pattern[pi];
          var f5 = file[fi];
          this.debug(pattern, p3, f5);
          if (p3 === false)
            return false;
          if (p3 === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p3, f5]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p3 === "string") {
            hit = f5 === p3;
            this.debug("string match", p3, f5, hit);
          } else {
            hit = f5.match(p3);
            this.debug("pattern match", p3, f5, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = !!options.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i2 = 0, c2; i2 < pattern.length && (c2 = pattern.charAt(i2)); i2++) {
          this.debug("%s	%s %s %j", pattern, i2, re, c2);
          if (escaping) {
            if (c2 === "/") {
              return false;
            }
            if (reSpecials[c2]) {
              re += "\\";
            }
            re += c2;
            escaping = false;
            continue;
          }
          switch (c2) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i2 + 1) === "-") {
                re += c2;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c2);
              if (inClass) {
                this.debug("  in class");
                if (c2 === "!" && i2 === classStart + 1)
                  c2 = "^";
                re += c2;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c2;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i2 - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c2;
                continue;
              }
              inClass = true;
              classStart = i2;
              reClassStart = re.length;
              re += c2;
              continue;
            case "]":
              if (i2 === classStart + 1 || !inClass) {
                re += "\\" + c2;
                continue;
              }
              cs = pattern.substring(classStart + 1, i2);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c2;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c2] && !(c2 === "^" && inClass)) {
                re += "\\";
              }
              re += c2;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_3, $1, $22) => {
            if (!$22) {
              $22 = "\\";
            }
            return $1 + $1 + $22 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t3 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t3 + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i2 = 0; i2 < openParensBefore; i2++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p3) => typeof p3 === "string" ? regExpEscape(p3) : p3 === GLOBSTAR ? GLOBSTAR : p3._src
          ).reduce((set2, p3) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p3 === GLOBSTAR)) {
              set2.push(p3);
            }
            return set2;
          }, []);
          pattern.forEach((p3, i2) => {
            if (p3 !== GLOBSTAR || pattern[i2 - 1] === GLOBSTAR) {
              return;
            }
            if (i2 === 0) {
              if (pattern.length > 1) {
                pattern[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i2 + 1];
              } else {
                pattern[i2] = twoStar;
              }
            } else if (i2 === pattern.length - 1) {
              pattern[i2 - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i2 - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i2 + 1];
              pattern[i2 + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p3) => p3 !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f5, partial = this.partial) {
        this.debug("match", f5, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f5 === "";
        if (f5 === "/" && partial)
          return true;
        const options = this.options;
        if (path3.sep !== "/") {
          f5 = f5.split(path3.sep).join("/");
        }
        f5 = f5.split(slashSplit);
        this.debug(this.pattern, "split", f5);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i2 = f5.length - 1; i2 >= 0; i2--) {
          filename = f5[i2];
          if (filename)
            break;
        }
        for (let i2 = 0; i2 < set.length; i2++) {
          const pattern = set[i2];
          let file = f5;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch2.defaults(def).Minimatch;
      }
    };
    minimatch2.Minimatch = Minimatch;
  }
});

// ../../node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve2, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve2(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r3) => cb(null, r3), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d3) {
        cwd = null;
        chdir.call(process, d3);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs3);
      }
      if (!fs3.lutimes) {
        patchLutimes(fs3);
      }
      fs3.chown = chownFix(fs3.chown);
      fs3.fchown = chownFix(fs3.fchown);
      fs3.lchown = chownFix(fs3.lchown);
      fs3.chmod = chmodFix(fs3.chmod);
      fs3.fchmod = chmodFix(fs3.fchmod);
      fs3.lchmod = chmodFix(fs3.lchmod);
      fs3.chownSync = chownFixSync(fs3.chownSync);
      fs3.fchownSync = chownFixSync(fs3.fchownSync);
      fs3.lchownSync = chownFixSync(fs3.lchownSync);
      fs3.chmodSync = chmodFixSync(fs3.chmodSync);
      fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
      fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
      fs3.stat = statFix(fs3.stat);
      fs3.fstat = statFix(fs3.fstat);
      fs3.lstat = statFix(fs3.lstat);
      fs3.statSync = statFixSync(fs3.statSync);
      fs3.fstatSync = statFixSync(fs3.fstatSync);
      fs3.lstatSync = statFixSync(fs3.lstatSync);
      if (fs3.chmod && !fs3.lchmod) {
        fs3.lchmod = function(path3, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lchmodSync = function() {
        };
      }
      if (fs3.chown && !fs3.lchown) {
        fs3.lchown = function(path3, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs3.rename = typeof fs3.rename !== "function" ? fs3.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs3.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs3.rename);
      }
      fs3.read = typeof fs3.read !== "function" ? fs3.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _3, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs3.read);
      fs3.readSync = typeof fs3.readSync !== "function" ? fs3.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs3, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs3.readSync);
      function patchLchmod(fs4) {
        fs4.lchmod = function(path3, mode, callback) {
          fs4.open(
            path3,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs4.fchmod(fd, mode, function(err2) {
                fs4.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs4.lchmodSync = function(path3, mode) {
          var fd = fs4.openSync(path3, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs4.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs4) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs4.futimes) {
          fs4.lutimes = function(path3, at, mt, cb) {
            fs4.open(path3, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs4.futimes(fd, at, mt, function(er2) {
                fs4.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs4.lutimesSync = function(path3, at, mt) {
            var fd = fs4.openSync(path3, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs4.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs4.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs4.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs4.futimes) {
          fs4.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs4.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs3, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs3, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs3, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs3, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream3 = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs3) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path3, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path3, options);
        Stream3.call(this);
        var self2 = this;
        this.path = path3;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index = 0, length = keys2.length; index < length; index++) {
          var key = keys2[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs3.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path3, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path3, options);
        Stream3.call(this);
        this.path = path3;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index = 0, length = keys2.length; index < length; index++) {
          var key = keys2[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs3.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone2;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone2(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs3 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone2 = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop2;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m3 = util.format.apply(util, arguments);
        m3 = "GFS4: " + m3.split(/\n/).join("\nGFS4: ");
        console.error(m3);
      };
    if (!fs3[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs3, queue);
      fs3.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs3, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs3.close);
      fs3.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs3, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs3.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs3[gracefulQueue]);
          require("assert").equal(fs3[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs3[gracefulQueue]);
    }
    module2.exports = patch(clone2(fs3));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
      module2.exports = patch(fs3);
      fs3.__patched = true;
    }
    function patch(fs4) {
      polyfills(fs4);
      fs4.gracefulify = patch;
      fs4.createReadStream = createReadStream2;
      fs4.createWriteStream = createWriteStream;
      var fs$readFile = fs4.readFile;
      fs4.readFile = readFile2;
      function readFile2(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path3, options, cb);
        function go$readFile(path4, options2, cb2, startTime) {
          return fs$readFile(path4, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path4, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs4.writeFile;
      fs4.writeFile = writeFile2;
      function writeFile2(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path3, data, options, cb);
        function go$writeFile(path4, data2, options2, cb2, startTime) {
          return fs$writeFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs4.appendFile;
      if (fs$appendFile)
        fs4.appendFile = appendFile;
      function appendFile(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path3, data, options, cb);
        function go$appendFile(path4, data2, options2, cb2, startTime) {
          return fs$appendFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs4.copyFile;
      if (fs$copyFile)
        fs4.copyFile = copyFile2;
      function copyFile2(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs4.readdir;
      fs4.readdir = readdir2;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir2(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, options2, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path3, options, cb);
        function fs$readdirCallback(path4, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path4, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs4);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs4.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs4.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs4, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs4, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs4, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs4, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path3, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path3, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path3, options) {
        return new fs4.ReadStream(path3, options);
      }
      function createWriteStream(path3, options) {
        return new fs4.WriteStream(path3, options);
      }
      var fs$open = fs4.open;
      fs4.open = open;
      function open(path3, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path3, flags, mode, cb);
        function go$open(path4, flags2, mode2, cb2, startTime) {
          return fs$open(path4, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path4, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs4;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs3[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i2 = 0; i2 < fs3[gracefulQueue].length; ++i2) {
        if (fs3[gracefulQueue][i2].length > 2) {
          fs3[gracefulQueue][i2][3] = now;
          fs3[gracefulQueue][i2][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs3[gracefulQueue].length === 0)
        return;
      var elem = fs3[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs3[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs3[key] === "function";
    });
    Object.assign(exports, fs3);
    api.forEach((method) => {
      exports[method] = u2(fs3[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs3.exists(filename, callback);
      }
      return new Promise((resolve2) => {
        return fs3.exists(filename, resolve2);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs3.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve2, reject) => {
        fs3.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve2({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.write(fd, buffer, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs3.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs3.writev === "function") {
      exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs3.writev(fd, buffers, ...args);
        }
        return new Promise((resolve2, reject) => {
          fs3.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve2({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs3.realpath.native === "function") {
      exports.realpath.native = u2(fs3.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module2) {
    "use strict";
    var path3 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path3.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs3.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs3.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u2(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs3 = require_fs();
    function pathExists(path3) {
      return fs3.access(path3).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u2(pathExists),
      pathExistsSync: fs3.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    function utimesMillis(path3, atime, mtime, callback) {
      fs3.open(path3, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs3.futimes(fd, atime, mtime, (futimesErr) => {
          fs3.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path3, atime, mtime) {
      const fd = fs3.openSync(path3, "r+");
      fs3.futimesSync(fd, atime, mtime);
      return fs3.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs3 = require_fs();
    var path3 = require("path");
    var util = require("util");
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs3.stat(file, { bigint: true }) : (file) => fs3.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs3.statSync(file, { bigint: true }) : (file) => fs3.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path3.basename(src);
            const destBaseName = path3.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path3.basename(src);
          const destBaseName = path3.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root)
        return cb();
      fs3.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs3.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path3.resolve(src).split(path3.sep).filter((i2) => i2);
      const destArr = path3.resolve(dest).split(path3.sep).filter((i2) => i2);
      return srcArr.reduce((acc, cur, i2) => acc && destArr[i2] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = require("path");
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat3 = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      stat3.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat3.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path3.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat4 = opts.dereference ? fs3.stat : fs3.lstat;
      stat4(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile2(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs3.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile2(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile2(srcStat, src, dest, opts, cb) {
      fs3.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs3.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs3.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs3.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs3.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path3.join(src, item);
      const destItem = path3.join(dest, item);
      stat3.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs3.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs3.symlink(resolvedSrc, dest, cb);
        } else {
          fs3.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs3.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path3.resolve(process.cwd(), resolvedDest);
            }
            if (stat3.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat3.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs3.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs3.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat3 = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat3.checkPathsSync(src, dest, "copy", opts);
      stat3.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path3.dirname(dest);
      if (!fs3.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync2 = opts.dereference ? fs3.statSync : fs3.lstatSync;
      const srcStat = statSync2(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile2(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs3.unlinkSync(dest);
        return copyFile2(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile2(srcStat, src, dest, opts) {
      fs3.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs3.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs3.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs3.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs3.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path3.join(src, item);
      const destItem = path3.join(dest, item);
      const { destStat } = stat3.checkPathsSync(srcItem, destItem, "copy", opts);
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs3.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs3.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs3.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs3.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path3.resolve(process.cwd(), resolvedDest);
        }
        if (stat3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs3.statSync(dest).isDirectory() && stat3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs3.unlinkSync(dest);
      return fs3.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    module2.exports = {
      copy: u2(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/rimraf.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = require("path");
    var assert = require("assert");
    var isWindows = process.platform === "win32";
    function defaults(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m3) => {
        options[m3] = options[m3] || fs3[m3];
        m3 = m3 + "Sync";
        options[m3] = options[m3] || fs3[m3];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p3, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p3, "rimraf: missing path");
      assert.strictEqual(typeof p3, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      rimraf_(p3, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p3, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p3, options, cb) {
      assert(p3);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p3, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows) {
          return fixWinEPERM(p3, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir2(p3, options, er, cb);
        }
        options.unlink(p3, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows ? fixWinEPERM(p3, options, er2, cb) : rmdir2(p3, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir2(p3, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p3, options, er, cb) {
      assert(p3);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p3, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p3, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir2(p3, options, er, cb);
            } else {
              options.unlink(p3, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p3, options, er) {
      let stats;
      assert(p3);
      assert(options);
      try {
        options.chmodSync(p3, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p3);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p3, options, er);
      } else {
        options.unlinkSync(p3);
      }
    }
    function rmdir2(p3, options, originalEr, cb) {
      assert(p3);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p3, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p3, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p3, options, cb) {
      assert(p3);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p3, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p3, cb);
        files.forEach((f5) => {
          rimraf(path3.join(p3, f5), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p3, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p3, options) {
      let st;
      options = options || {};
      defaults(options);
      assert(p3, "rimraf: missing path");
      assert.strictEqual(typeof p3, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p3);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows) {
          fixWinEPERMSync(p3, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p3, options, null);
        } else {
          options.unlinkSync(p3);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows ? fixWinEPERMSync(p3, options, er) : rmdirSync(p3, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p3, options, er);
      }
    }
    function rmdirSync(p3, options, originalEr) {
      assert(p3);
      assert(options);
      try {
        options.rmdirSync(p3);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p3, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p3, options) {
      assert(p3);
      assert(options);
      options.readdirSync(p3).forEach((f5) => rimrafSync(path3.join(p3, f5), options));
      if (isWindows) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p3, options);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p3, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var u2 = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    function remove2(path3, callback) {
      if (fs3.rm)
        return fs3.rm(path3, { recursive: true, force: true }, callback);
      rimraf(path3, callback);
    }
    function removeSync(path3) {
      if (fs3.rmSync)
        return fs3.rmSync(path3, { recursive: true, force: true });
      rimraf.sync(path3);
    }
    module2.exports = {
      remove: u2(remove2),
      removeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs3 = require_fs();
    var path3 = require("path");
    var mkdir2 = require_mkdirs();
    var remove2 = require_remove();
    var emptyDir = u2(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs3.readdir(dir);
      } catch {
        return mkdir2.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove2.remove(path3.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs3.readdirSync(dir);
      } catch {
        return mkdir2.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path3.join(dir, item);
        remove2.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var path3 = require("path");
    var fs3 = require_graceful_fs();
    var mkdir2 = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs3.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs3.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path3.dirname(file);
        fs3.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir2.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs3.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs3.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path3.dirname(file);
      try {
        if (!fs3.statSync(dir).isDirectory()) {
          fs3.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir2.mkdirsSync(dir);
        else
          throw err;
      }
      fs3.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u2(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var path3 = require("path");
    var fs3 = require_graceful_fs();
    var mkdir2 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs3.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs3.lstat(dstpath, (_3, dstStat) => {
        fs3.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path3.dirname(dstpath);
          pathExists(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir2.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs3.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs3.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path3.dirname(dstpath);
      const dirExists = fs3.existsSync(dir);
      if (dirExists)
        return fs3.linkSync(srcpath, dstpath);
      mkdir2.mkdirsSync(dir);
      return fs3.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u2(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path3 = require("path");
    var fs3 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path3.isAbsolute(srcpath)) {
        return fs3.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path3.dirname(dstpath);
        const relativeToDst = path3.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs3.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path3.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path3.isAbsolute(srcpath)) {
        exists = fs3.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path3.dirname(dstpath);
        const relativeToDst = path3.join(dstdir, srcpath);
        exists = fs3.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs3.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path3.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs3.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs3.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var path3 = require("path");
    var fs3 = require_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      fs3.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs3.stat(srcpath),
            fs3.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative2) => {
        if (err)
          return callback(err);
        srcpath = relative2.toDst;
        symlinkType(relative2.toCwd, type, (err2, type2) => {
          if (err2)
            return callback(err2);
          const dir = path3.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs3.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs3.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs3.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs3.statSync(srcpath);
        const dstStat = fs3.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative2 = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative2.toDst;
      type = symlinkTypeSync(relative2.toCwd, type);
      const dir = path3.dirname(dstpath);
      const exists = fs3.existsSync(dir);
      if (exists)
        return fs3.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs3.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u2(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module2) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_3) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs3 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs3.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync2(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs3 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs3.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs3 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs3.writeFile)(file, str, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs3 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs3.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync: readFileSync2,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/output-file/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var fs3 = require_graceful_fs();
    var path3 = require("path");
    var mkdir2 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path3.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs3.writeFile(file, data, encoding, callback);
        mkdir2.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs3.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path3.dirname(file);
      if (fs3.existsSync(dir)) {
        return fs3.writeFileSync(file, ...args);
      }
      mkdir2.mkdirsSync(dir);
      fs3.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u2(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u2(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = require("path");
    var copy = require_copy2().copy;
    var remove2 = require_remove().remove;
    var mkdirp2 = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat3 = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      stat3.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat3.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp2(path3.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent2 = path3.dirname(dest);
      const parsedPath = path3.parse(parent2);
      return parsedPath.root === parent2;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename(src, dest, overwrite, cb);
      if (overwrite) {
        return remove2(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs3.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove2(src, cb);
      });
    }
    module2.exports = move;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move-sync.js"(exports, module2) {
    "use strict";
    var fs3 = require_graceful_fs();
    var path3 = require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync2 = require_mkdirs().mkdirpSync;
    var stat3 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat3.checkPathsSync(src, dest, "move", opts);
      stat3.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync2(path3.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent2 = path3.dirname(dest);
      const parsedPath = path3.parse(parent2);
      return parsedPath.root === parent2;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs3.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs3.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    module2.exports = {
      move: u2(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      ...require_fs(),
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs3 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p3, cache) {
      p3 = pathModule.resolve(p3);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p3)) {
        return cache[p3];
      }
      var original = p3, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m3 = splitRootRe.exec(p3);
        pos = m3[0].length;
        current = m3[0];
        base = m3[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p3.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p3);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat3 = fs3.lstatSync(base);
          if (!stat3.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat3.dev.toString(32) + ":" + stat3.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs3.statSync(base);
            linkTarget = fs3.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p3 = pathModule.resolve(resolvedLink, p3.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p3;
      return p3;
    };
    exports.realpath = function realpath(p3, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p3 = pathModule.resolve(p3);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p3)) {
        return process.nextTick(cb.bind(null, null, cache[p3]));
      }
      var original = p3, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m3 = splitRootRe.exec(p3);
        pos = m3[0].length;
        current = m3[0];
        base = m3[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p3.length) {
          if (cache)
            cache[original] = p3;
          return cb(null, p3);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p3);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs3.lstat(base, gotStat);
      }
      function gotStat(err, stat3) {
        if (err)
          return cb(err);
        if (!stat3.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat3.dev.toString(32) + ":" + stat3.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs3.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs3.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p3 = pathModule.resolve(resolvedLink, p3.slice(pos));
        start();
      }
    };
  }
});

// ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
var require_fs2 = __commonJS({
  "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs3 = require("fs");
    var origRealpath = fs3.realpath;
    var origRealpathSync = fs3.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p3, cache, cb) {
      if (ok) {
        return origRealpath(p3, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p3, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p3, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p3, cache) {
      if (ok) {
        return origRealpathSync(p3, cache);
      }
      try {
        return origRealpathSync(p3, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p3, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs3.realpath = realpath;
      fs3.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs3.realpath = origRealpath;
      fs3.realpathSync = origRealpathSync;
    }
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e3) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs3 = require("fs");
    var path3 = require("path");
    var minimatch2 = require_minimatch();
    var isAbsolute2 = require("path").isAbsolute;
    var Minimatch = minimatch2.Minimatch;
    function alphasort(a2, b2) {
      return a2.localeCompare(b2, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs3;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = path3.resolve(cwd);
      else {
        self2.cwd = path3.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path3.resolve(self2.cwd, "/");
      self2.root = path3.resolve(self2.root);
      self2.cwdAbs = isAbsolute2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      self2.nomount = !!options.nomount;
      if (process.platform === "win32") {
        self2.root = self2.root.replace(/\\/g, "/");
        self2.cwd = self2.cwd.replace(/\\/g, "/");
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      }
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i2 = 0, l2 = self2.matches.length; i2 < l2; i2++) {
        var matches = self2.matches[i2];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i2];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m3 = Object.keys(matches);
          if (nou)
            all.push.apply(all, m3);
          else
            m3.forEach(function(m4) {
              all[m4] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i2 = 0; i2 < all.length; i2++) {
          all[i2] = self2._mark(all[i2]);
        }
        if (self2.nodir) {
          all = all.filter(function(e3) {
            var notDir = !/\/$/.test(e3);
            var c2 = self2.cache[e3] || self2.cache[makeAbs(self2, e3)];
            if (notDir && c2)
              notDir = c2 !== "DIR" && !Array.isArray(c2);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m4) {
          return !isIgnored(self2, m4);
        });
      self2.found = all;
    }
    function mark(self2, p3) {
      var abs = makeAbs(self2, p3);
      var c2 = self2.cache[abs];
      var m3 = p3;
      if (c2) {
        var isDir = c2 === "DIR" || Array.isArray(c2);
        var slash = p3.slice(-1) === "/";
        if (isDir && !slash)
          m3 += "/";
        else if (!isDir && slash)
          m3 = m3.slice(0, -1);
        if (m3 !== p3) {
          var mabs = makeAbs(self2, m3);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m3;
    }
    function makeAbs(self2, f5) {
      var abs = f5;
      if (f5.charAt(0) === "/") {
        abs = path3.join(self2.root, f5);
      } else if (isAbsolute2(f5) || f5 === "") {
        abs = f5;
      } else if (self2.changedCwd) {
        abs = path3.resolve(self2.cwd, f5);
      } else {
        abs = path3.resolve(f5);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path4) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path4) || !!(item.gmatcher && item.gmatcher.match(path4));
      });
    }
    function childrenIgnored(self2, path4) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path4));
      });
    }
  }
});

// ../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/sync.js
var require_sync = __commonJS({
  "../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs2();
    var minimatch2 = require_minimatch();
    var Minimatch = minimatch2.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path3 = require("path");
    var assert = require("assert");
    var isAbsolute2 = require("path").isAbsolute;
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i2 = 0; i2 < n; i2++) {
        this._process(this.minimatch.set[i2], i2, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p3 in matchset) {
            try {
              p3 = self2._makeAbs(p3);
              var real = rp.realpathSync(p3, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p3)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p3) {
        return typeof p3 === "string" ? p3 : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute2(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e3 = entries[i2];
        if (e3.charAt(0) !== "." || dotOk) {
          var m3;
          if (negate && !prefix) {
            m3 = !e3.match(pn);
          } else {
            m3 = e3.match(pn);
          }
          if (m3)
            matchedEntries.push(e3);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e3 = matchedEntries[i2];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e3 = prefix + "/" + e3;
            else
              e3 = prefix + e3;
          }
          if (e3.charAt(0) === "/" && !this.nomount) {
            e3 = path3.join(this.root, e3);
          }
          this._emitMatch(index, e3);
        }
        return;
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = matchedEntries[i2];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e3];
        else
          newPattern = [e3];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e3) {
      if (isIgnored(this, e3))
        return;
      var abs = this._makeAbs(e3);
      if (this.mark)
        e3 = this._mark(e3);
      if (this.absolute) {
        e3 = abs;
      }
      if (this.matches[index][e3])
        return;
      if (this.nodir) {
        var c2 = this.cache[abs];
        if (c2 === "DIR" || Array.isArray(c2))
          return;
      }
      this.matches[index][e3] = true;
      if (this.stat)
        this._stat(e3);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat3;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return null;
        if (Array.isArray(c2))
          return c2;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e3 = entries[i2];
          if (abs === "/")
            e3 = abs + e3;
          else
            e3 = abs + "/" + e3;
          this.cache[e3] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f5, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f5);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f5)] = false;
          break;
        default:
          this.cache[this._makeAbs(f5)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = entries[i2];
        if (e3.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute2(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path3.join(this.root, prefix);
        } else {
          prefix = path3.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f5) {
      var abs = this._makeAbs(f5);
      var needDir = f5.slice(-1) === "/";
      if (f5.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (Array.isArray(c2))
          c2 = "DIR";
        if (!needDir || c2 === "DIR")
          return c2;
        if (needDir && c2 === "FILE")
          return false;
      }
      var exists;
      var stat3 = this.statCache[abs];
      if (!stat3) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat3 = this.fs.statSync(abs);
          } catch (er) {
            stat3 = lstat;
          }
        } else {
          stat3 = lstat;
        }
      }
      this.statCache[abs] = stat3;
      var c2 = true;
      if (stat3)
        c2 = stat3.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c2;
      if (needDir && c2 === "FILE")
        return false;
      return c2;
    };
    GlobSync.prototype._mark = function(p3) {
      return common.mark(this, p3);
    };
    GlobSync.prototype._makeAbs = function(f5) {
      return common.makeAbs(this, f5);
    };
  }
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k3) {
        wrapper[k3] = fn[k3];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k3) {
            ret[k3] = cb2[k3];
          });
        }
        return ret;
      }
    }
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({
  "../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f5 = function() {
        if (f5.called)
          return f5.value;
        f5.called = true;
        return f5.value = fn.apply(this, arguments);
      };
      f5.called = false;
      return f5;
    }
    function onceStrict(fn) {
      var f5 = function() {
        if (f5.called)
          throw new Error(f5.onceError);
        f5.called = true;
        return f5.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f5.onceError = name + " shouldn't be called more than once";
      f5.called = false;
      return f5;
    }
  }
});

// ../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i2 = 0; i2 < len; i2++) {
            cbs[i2].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i2 = 0; i2 < length; i2++)
        array[i2] = args[i2];
      return array;
    }
  }
});

// ../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/glob.js
var require_glob = __commonJS({
  "../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob2;
    var rp = require_fs2();
    var minimatch2 = require_minimatch();
    var Minimatch = minimatch2.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path3 = require("path");
    var assert = require("assert");
    var isAbsolute2 = require("path").isAbsolute;
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob2(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob2.sync = globSync;
    var GlobSync = glob2.GlobSync = globSync.GlobSync;
    glob2.glob = glob2;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys2 = Object.keys(add);
      var i2 = keys2.length;
      while (i2--) {
        origin[keys2[i2]] = add[keys2[i2]];
      }
      return origin;
    }
    glob2.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g3 = new Glob(pattern, options);
      var set = g3.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j2 = 0; j2 < set[0].length; j2++) {
        if (typeof set[0][j2] !== "string")
          return true;
      }
      return false;
    };
    glob2.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i2 = 0; i2 < n; i2++) {
        this._process(this.minimatch.set[i2], i2, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i2 = 0; i2 < this.matches.length; i2++)
        this._realpathSet(i2, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p3, i2) {
        p3 = self2._makeAbs(p3);
        rp.realpath(p3, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p3] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p3) {
      return common.mark(this, p3);
    };
    Glob.prototype._makeAbs = function(f5) {
      return common.makeAbs(this, f5);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i2 = 0; i2 < eq.length; i2++) {
            var e3 = eq[i2];
            this._emitMatch(e3[0], e3[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i2 = 0; i2 < pq.length; i2++) {
            var p3 = pq[i2];
            this._processing--;
            this._process(p3[0], p3[1], p3[2], p3[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p3) {
        return typeof p3 === "string" ? p3 : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute2(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e3 = entries[i2];
        if (e3.charAt(0) !== "." || dotOk) {
          var m3;
          if (negate && !prefix) {
            m3 = !e3.match(pn);
          } else {
            m3 = e3.match(pn);
          }
          if (m3)
            matchedEntries.push(e3);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e3 = matchedEntries[i2];
          if (prefix) {
            if (prefix !== "/")
              e3 = prefix + "/" + e3;
            else
              e3 = prefix + e3;
          }
          if (e3.charAt(0) === "/" && !this.nomount) {
            e3 = path3.join(this.root, e3);
          }
          this._emitMatch(index, e3);
        }
        return cb();
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = matchedEntries[i2];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e3 = prefix + "/" + e3;
          else
            e3 = prefix + e3;
        }
        this._process([e3].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e3) {
      if (this.aborted)
        return;
      if (isIgnored(this, e3))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e3]);
        return;
      }
      var abs = isAbsolute2(e3) ? e3 : this._makeAbs(e3);
      if (this.mark)
        e3 = this._mark(e3);
      if (this.absolute)
        e3 = abs;
      if (this.matches[index][e3])
        return;
      if (this.nodir) {
        var c2 = this.cache[abs];
        if (c2 === "DIR" || Array.isArray(c2))
          return;
      }
      this.matches[index][e3] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e3, st);
      this.emit("match", e3);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return cb();
        if (Array.isArray(c2))
          return cb(null, c2);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e3 = entries[i2];
          if (abs === "/")
            e3 = abs + e3;
          else
            e3 = abs + "/" + e3;
          this.cache[e3] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f5, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f5);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f5)] = false;
          break;
        default:
          this.cache[this._makeAbs(f5)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = entries[i2];
        if (e3.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute2(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path3.join(this.root, prefix);
        } else {
          prefix = path3.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f5, cb) {
      var abs = this._makeAbs(f5);
      var needDir = f5.slice(-1) === "/";
      if (f5.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (Array.isArray(c2))
          c2 = "DIR";
        if (!needDir || c2 === "DIR")
          return cb(null, c2);
        if (needDir && c2 === "FILE")
          return cb();
      }
      var exists;
      var stat3 = this.statCache[abs];
      if (stat3 !== void 0) {
        if (stat3 === false)
          return cb(null, stat3);
        else {
          var type = stat3.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat3);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat4) {
            if (er2)
              self2._stat2(f5, abs, null, lstat, cb);
            else
              self2._stat2(f5, abs, er2, stat4, cb);
          });
        } else {
          self2._stat2(f5, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f5, abs, er, stat3, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f5.slice(-1) === "/";
      this.statCache[abs] = stat3;
      if (abs.slice(-1) === "/" && stat3 && !stat3.isDirectory())
        return cb(null, false, stat3);
      var c2 = true;
      if (stat3)
        c2 = stat3.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c2;
      if (needDir && c2 === "FILE")
        return cb();
      return cb(null, c2, stat3);
    };
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.constants = void 0;
    exports.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      UV_FS_COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_EXCL: 1,
      COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE_FORCE: 4
    };
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/getBigInt.js
var require_getBigInt = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/getBigInt.js"(exports) {
    if (typeof BigInt === "function")
      exports.default = BigInt;
    else
      exports.default = function BigIntNotSupported() {
        throw new Error("BigInt is not supported in this environment.");
      };
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/Stats.js
var require_Stats = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/Stats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stats = void 0;
    var constants_1 = require_constants();
    var getBigInt_1 = require_getBigInt();
    var S_IFMT = constants_1.constants.S_IFMT;
    var S_IFDIR = constants_1.constants.S_IFDIR;
    var S_IFREG = constants_1.constants.S_IFREG;
    var S_IFBLK = constants_1.constants.S_IFBLK;
    var S_IFCHR = constants_1.constants.S_IFCHR;
    var S_IFLNK = constants_1.constants.S_IFLNK;
    var S_IFIFO = constants_1.constants.S_IFIFO;
    var S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Stats = function() {
      function Stats2() {
      }
      Stats2.build = function(node, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var stats = new Stats2();
        var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
        var getStatNumber = !bigint ? function(number) {
          return number;
        } : getBigInt_1.default;
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
      };
      Stats2.prototype._checkModeProperty = function(property) {
        return (Number(this.mode) & S_IFMT) === property;
      };
      Stats2.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Stats2.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Stats2.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Stats2.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Stats2.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Stats2.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Stats2.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Stats2;
    }();
    exports.Stats = Stats;
    exports.default = Stats;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/internal/buffer.js
var require_buffer = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/internal/buffer.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;
    var buffer_1 = require("buffer");
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return buffer_1.Buffer;
    } });
    function bufferV0P12Ponyfill(arg0) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
    }
    var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports.bufferAllocUnsafe = bufferAllocUnsafe;
    var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports.bufferFrom = bufferFrom;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/internal/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/internal/errors.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d3, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
          d4.__proto__ = b3;
        } || function(d4, b3) {
          for (var p3 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p3))
              d4[p3] = b3[p3];
        };
        return extendStatics(d3, b2);
      };
      return function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.E = exports.AssertionError = exports.message = exports.RangeError = exports.TypeError = exports.Error = void 0;
    var assert = require("assert");
    var util = require("util");
    var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    var messages = {};
    function makeNodeError(Base) {
      return function(_super) {
        __extends(NodeError, _super);
        function NodeError(key) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          var _this = _super.call(this, message(key, args)) || this;
          _this.code = key;
          _this[kCode] = key;
          _this.name = "".concat(_super.prototype.name, " [").concat(_this[kCode], "]");
          return _this;
        }
        return NodeError;
      }(Base);
    }
    var g3 = typeof globalThis !== "undefined" ? globalThis : global;
    var AssertionError = function(_super) {
      __extends(AssertionError2, _super);
      function AssertionError2(options) {
        var _this = this;
        if (typeof options !== "object" || options === null) {
          throw new exports.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options.message) {
          _this = _super.call(this, options.message) || this;
        } else {
          _this = _super.call(this, "".concat(util.inspect(options.actual).slice(0, 128), " ") + "".concat(options.operator, " ").concat(util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = "AssertionError [ERR_ASSERTION]";
        _this.code = "ERR_ASSERTION";
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
      }
      return AssertionError2;
    }(g3.Error);
    exports.AssertionError = AssertionError;
    function message(key, args) {
      assert.strictEqual(typeof key, "string");
      var msg = messages[key];
      assert(msg, "An invalid error message key was used: ".concat(key, "."));
      var fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util.format;
        if (args === void 0 || args.length === 0)
          return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    exports.message = message;
    function E2(sym, val) {
      messages[sym] = typeof val === "function" ? val : String(val);
    }
    exports.E = E2;
    exports.Error = makeNodeError(g3.Error);
    exports.TypeError = makeNodeError(g3.TypeError);
    exports.RangeError = makeNodeError(g3.RangeError);
    E2("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
    E2("ERR_ASSERTION", "%s");
    E2("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
    E2("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    E2("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
    E2("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
    E2("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
      return 'c-ares failed to set servers: "'.concat(err, '" [').concat(servers, "]");
    });
    E2("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
    E2("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
      return 'The "'.concat(enc, '" encoding is not supported');
    });
    E2("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
      return "The encoded data was not valid for encoding ".concat(enc);
    });
    E2("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
    E2("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
    E2("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
    E2("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
    E2("ERR_INVALID_ARG_TYPE", invalidArgType);
    E2("ERR_INVALID_ARRAY_LENGTH", function(name, len, actual) {
      assert.strictEqual(typeof actual, "number");
      return 'The array "'.concat(name, '" (length ').concat(actual, ") must be of length ").concat(len, ".");
    });
    E2("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
    E2("ERR_INVALID_CALLBACK", "Callback must be a function");
    E2("ERR_INVALID_CHAR", "Invalid character in %s");
    E2("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
    E2("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
    E2("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E2("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E2("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
    E2("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
    E2("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "'.concat(String(value), '" is invalid for option "').concat(name, '"');
    });
    E2("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
      return 'The value "'.concat(String(value), '" is invalid for option "encoding"');
    });
    E2("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
    E2("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
    E2("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
    E2("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
    E2("ERR_INVALID_URL", "Invalid URL: %s");
    E2("ERR_INVALID_URL_SCHEME", function(expected) {
      return "The URL must be ".concat(oneOf(expected, "scheme"));
    });
    E2("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
    E2("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
    E2("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
    E2("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
    E2("ERR_MISSING_ARGS", missingArgs);
    E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    E2("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
    E2("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
    E2("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
    E2("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
    E2("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
    E2("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
    E2("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
    E2("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
    E2("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
    E2("ERR_SOCKET_CLOSED", "Socket is closed");
    E2("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
    E2("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
    E2("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
    E2("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
    E2("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
    E2("ERR_TLS_DH_PARAM_SIZE", function(size) {
      return "DH parameter size ".concat(size, " is less than 2048");
    });
    E2("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
    E2("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
    E2("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
    E2("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
    E2("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
    E2("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
    E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
    E2("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
    E2("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
    E2("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
    E2("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
    function invalidArgType(name, expected, actual) {
      assert(name, "name is required");
      var determiner;
      if (expected.includes("not ")) {
        determiner = "must not be";
        expected = expected.split("not ")[1];
      } else {
        determiner = "must be";
      }
      var msg;
      if (Array.isArray(name)) {
        var names = name.map(function(val) {
          return '"'.concat(val, '"');
        }).join(", ");
        msg = "The ".concat(names, " arguments ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else if (name.includes(" argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = name.includes(".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      if (arguments.length >= 3) {
        msg += ". Received type ".concat(actual !== null ? typeof actual : "null");
      }
      return msg;
    }
    function missingArgs() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      assert(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a2) {
        return '"'.concat(a2, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }
    function oneOf(expected, thing) {
      assert(expected, "expected is required");
      assert(typeof thing === "string", "thing is required");
      if (Array.isArray(expected)) {
        var len = expected.length;
        assert(len > 0, "At least one expected value needs to be specified");
        expected = expected.map(function(i2) {
          return String(i2);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function bufferOutOfBounds(name, isWriting) {
      if (isWriting) {
        return "Attempt to write outside buffer bounds";
      } else {
        return '"'.concat(name, '" is outside of buffer bounds');
      }
    }
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.strToEncoding = exports.assertEncoding = exports.ENCODING_UTF8 = void 0;
    var buffer_1 = require_buffer();
    var errors = require_errors();
    exports.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding) {
      if (encoding && !buffer_1.Buffer.isEncoding(encoding))
        throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
    }
    exports.assertEncoding = assertEncoding;
    function strToEncoding(str, encoding) {
      if (!encoding || encoding === exports.ENCODING_UTF8)
        return str;
      if (encoding === "buffer")
        return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding);
    }
    exports.strToEncoding = strToEncoding;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/Dirent.js
var require_Dirent = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/Dirent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dirent = void 0;
    var constants_1 = require_constants();
    var encoding_1 = require_encoding();
    var S_IFMT = constants_1.constants.S_IFMT;
    var S_IFDIR = constants_1.constants.S_IFDIR;
    var S_IFREG = constants_1.constants.S_IFREG;
    var S_IFBLK = constants_1.constants.S_IFBLK;
    var S_IFCHR = constants_1.constants.S_IFCHR;
    var S_IFLNK = constants_1.constants.S_IFLNK;
    var S_IFIFO = constants_1.constants.S_IFIFO;
    var S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Dirent = function() {
      function Dirent2() {
        this.name = "";
        this.mode = 0;
      }
      Dirent2.build = function(link, encoding) {
        var dirent = new Dirent2();
        var mode = link.getNode().mode;
        dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
        dirent.mode = mode;
        return dirent;
      };
      Dirent2.prototype._checkModeProperty = function(property) {
        return (this.mode & S_IFMT) === property;
      };
      Dirent2.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Dirent2.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Dirent2.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Dirent2.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Dirent2.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Dirent2.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Dirent2.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Dirent2;
    }();
    exports.Dirent = Dirent;
    exports.default = Dirent;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/setImmediate.js
var require_setImmediate = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/setImmediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _setImmediate;
    if (typeof setImmediate === "function")
      _setImmediate = setImmediate.bind(typeof globalThis !== "undefined" ? globalThis : global);
    else
      _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : global);
    exports.default = _setImmediate;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/process.js
var require_process = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/process.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProcess = void 0;
    var maybeReturnProcess = function() {
      if (typeof process !== "undefined") {
        return process;
      }
      try {
        return require("process");
      } catch (_a) {
        return void 0;
      }
    };
    function createProcess() {
      var p3 = maybeReturnProcess() || {};
      if (!p3.cwd)
        p3.cwd = function() {
          return "/";
        };
      if (!p3.nextTick)
        p3.nextTick = require_setImmediate().default;
      if (!p3.emitWarning)
        p3.emitWarning = function(message, type) {
          console.warn("".concat(type).concat(type ? ": " : "").concat(message));
        };
      if (!p3.env)
        p3.env = {};
      return p3;
    }
    exports.createProcess = createProcess;
    exports.default = createProcess();
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d3, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
          d4.__proto__ = b3;
        } || function(d4, b3) {
          for (var p3 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p3))
              d4[p3] = b3[p3];
        };
        return extendStatics(d3, b2);
      };
      return function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.File = exports.Link = exports.Node = exports.SEP = void 0;
    var process_1 = require_process();
    var buffer_1 = require_buffer();
    var constants_1 = require_constants();
    var events_1 = require("events");
    var Stats_1 = require_Stats();
    var S_IFMT = constants_1.constants.S_IFMT;
    var S_IFDIR = constants_1.constants.S_IFDIR;
    var S_IFREG = constants_1.constants.S_IFREG;
    var S_IFLNK = constants_1.constants.S_IFLNK;
    var O_APPEND = constants_1.constants.O_APPEND;
    var getuid = function() {
      var _a, _b;
      return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
    };
    var getgid = function() {
      var _a, _b;
      return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
    };
    exports.SEP = "/";
    var Node = function(_super) {
      __extends(Node2, _super);
      function Node2(ino, perm) {
        if (perm === void 0) {
          perm = 438;
        }
        var _this = _super.call(this) || this;
        _this.uid = getuid();
        _this.gid = getgid();
        _this.atime = new Date();
        _this.mtime = new Date();
        _this.ctime = new Date();
        _this.perm = 438;
        _this.mode = S_IFREG;
        _this.nlink = 1;
        _this.perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
      }
      Node2.prototype.getString = function(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        return this.getBuffer().toString(encoding);
      };
      Node2.prototype.setString = function(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      };
      Node2.prototype.getBuffer = function() {
        if (!this.buf)
          this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
        return (0, buffer_1.bufferFrom)(this.buf);
      };
      Node2.prototype.setBuffer = function(buf) {
        this.buf = (0, buffer_1.bufferFrom)(buf);
        this.touch();
      };
      Node2.prototype.getSize = function() {
        return this.buf ? this.buf.length : 0;
      };
      Node2.prototype.setModeProperty = function(property) {
        this.mode = this.mode & ~S_IFMT | property;
      };
      Node2.prototype.setIsFile = function() {
        this.setModeProperty(S_IFREG);
      };
      Node2.prototype.setIsDirectory = function() {
        this.setModeProperty(S_IFDIR);
      };
      Node2.prototype.setIsSymlink = function() {
        this.setModeProperty(S_IFLNK);
      };
      Node2.prototype.isFile = function() {
        return (this.mode & S_IFMT) === S_IFREG;
      };
      Node2.prototype.isDirectory = function() {
        return (this.mode & S_IFMT) === S_IFDIR;
      };
      Node2.prototype.isSymlink = function() {
        return (this.mode & S_IFMT) === S_IFLNK;
      };
      Node2.prototype.makeSymlink = function(steps) {
        this.symlink = steps;
        this.setIsSymlink();
      };
      Node2.prototype.write = function(buf, off, len, pos) {
        if (off === void 0) {
          off = 0;
        }
        if (len === void 0) {
          len = buf.length;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off, off + len);
        this.touch();
        return len;
      };
      Node2.prototype.read = function(buf, off, len, pos) {
        if (off === void 0) {
          off = 0;
        }
        if (len === void 0) {
          len = buf.byteLength;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        var actualLen = len;
        if (actualLen > buf.byteLength) {
          actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf, off, pos, pos + actualLen);
        return actualLen;
      };
      Node2.prototype.truncate = function(len) {
        if (len === void 0) {
          len = 0;
        }
        if (!len)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            var buf = (0, buffer_1.bufferAllocUnsafe)(len);
            this.buf.copy(buf);
            buf.fill(0, this.buf.length);
            this.buf = buf;
          }
        }
        this.touch();
      };
      Node2.prototype.chmod = function(perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
      };
      Node2.prototype.chown = function(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      };
      Node2.prototype.touch = function() {
        this.mtime = new Date();
        this.emit("change", this);
      };
      Node2.prototype.canRead = function(uid, gid) {
        if (uid === void 0) {
          uid = getuid();
        }
        if (gid === void 0) {
          gid = getgid();
        }
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      };
      Node2.prototype.canWrite = function(uid, gid) {
        if (uid === void 0) {
          uid = getuid();
        }
        if (gid === void 0) {
          gid = getgid();
        }
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      };
      Node2.prototype.del = function() {
        this.emit("delete", this);
      };
      Node2.prototype.toJSON = function() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      };
      return Node2;
    }(events_1.EventEmitter);
    exports.Node = Node;
    var Link = function(_super) {
      __extends(Link2, _super);
      function Link2(vol2, parent2, name) {
        var _this = _super.call(this) || this;
        _this.children = {};
        _this._steps = [];
        _this.ino = 0;
        _this.length = 0;
        _this.vol = vol2;
        _this.parent = parent2;
        _this.name = name;
        _this.syncSteps();
        return _this;
      }
      Object.defineProperty(Link2.prototype, "steps", {
        get: function() {
          return this._steps;
        },
        set: function(val) {
          this._steps = val;
          for (var _i = 0, _a = Object.values(this.children); _i < _a.length; _i++) {
            var child = _a[_i];
            child === null || child === void 0 ? void 0 : child.syncSteps();
          }
        },
        enumerable: false,
        configurable: true
      });
      Link2.prototype.setNode = function(node) {
        this.node = node;
        this.ino = node.ino;
      };
      Link2.prototype.getNode = function() {
        return this.node;
      };
      Link2.prototype.createChild = function(name, node) {
        if (node === void 0) {
          node = this.vol.createNode();
        }
        var link = new Link2(this.vol, this, name);
        link.setNode(node);
        if (node.isDirectory()) {
        }
        this.setChild(name, link);
        return link;
      };
      Link2.prototype.setChild = function(name, link) {
        if (link === void 0) {
          link = new Link2(this.vol, this, name);
        }
        this.children[name] = link;
        link.parent = this;
        this.length++;
        this.emit("child:add", link, this);
        return link;
      };
      Link2.prototype.deleteChild = function(link) {
        delete this.children[link.getName()];
        this.length--;
        this.emit("child:delete", link, this);
      };
      Link2.prototype.getChild = function(name) {
        if (Object.hasOwnProperty.call(this.children, name)) {
          return this.children[name];
        }
      };
      Link2.prototype.getPath = function() {
        return this.steps.join(exports.SEP);
      };
      Link2.prototype.getName = function() {
        return this.steps[this.steps.length - 1];
      };
      Link2.prototype.walk = function(steps, stop, i2) {
        if (stop === void 0) {
          stop = steps.length;
        }
        if (i2 === void 0) {
          i2 = 0;
        }
        if (i2 >= steps.length)
          return this;
        if (i2 >= stop)
          return this;
        var step = steps[i2];
        var link = this.getChild(step);
        if (!link)
          return null;
        return link.walk(steps, stop, i2 + 1);
      };
      Link2.prototype.toJSON = function() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Object.keys(this.children)
        };
      };
      Link2.prototype.syncSteps = function() {
        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
      };
      return Link2;
    }(events_1.EventEmitter);
    exports.Link = Link;
    var File4 = function() {
      function File5(link, node, flags, fd) {
        this.position = 0;
        this.link = link;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
      }
      File5.prototype.getString = function(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        return this.node.getString();
      };
      File5.prototype.setString = function(str) {
        this.node.setString(str);
      };
      File5.prototype.getBuffer = function() {
        return this.node.getBuffer();
      };
      File5.prototype.setBuffer = function(buf) {
        this.node.setBuffer(buf);
      };
      File5.prototype.getSize = function() {
        return this.node.getSize();
      };
      File5.prototype.truncate = function(len) {
        this.node.truncate(len);
      };
      File5.prototype.seekTo = function(position) {
        this.position = position;
      };
      File5.prototype.stats = function() {
        return Stats_1.default.build(this.node);
      };
      File5.prototype.write = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.length;
        }
        if (typeof position !== "number")
          position = this.position;
        if (this.flags & O_APPEND)
          position = this.getSize();
        var bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File5.prototype.read = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.byteLength;
        }
        if (typeof position !== "number")
          position = this.position;
        var bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File5.prototype.chmod = function(perm) {
        this.node.chmod(perm);
      };
      File5.prototype.chown = function(uid, gid) {
        this.node.chown(uid, gid);
      };
      return File5;
    }();
    exports.File = File4;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/setTimeoutUnref.js
var require_setTimeoutUnref = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/setTimeoutUnref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setTimeoutUnref(callback, time, args) {
      var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : global, arguments);
      if (ref && typeof ref === "object" && typeof ref.unref === "function")
        ref.unref();
      return ref;
    }
    exports.default = setTimeoutUnref;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/promises.js
var require_promises = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/promises.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileHandle = void 0;
    function promisify3(vol2, fn, getResult) {
      if (getResult === void 0) {
        getResult = function(input) {
          return input;
        };
      }
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve2, reject) {
          vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
            if (error)
              return reject(error);
            return resolve2(getResult(result));
          }], false));
        });
      };
    }
    var FileHandle = function() {
      function FileHandle2(vol2, fd) {
        this.vol = vol2;
        this.fd = fd;
      }
      FileHandle2.prototype.appendFile = function(data, options) {
        return promisify3(this.vol, "appendFile")(this.fd, data, options);
      };
      FileHandle2.prototype.chmod = function(mode) {
        return promisify3(this.vol, "fchmod")(this.fd, mode);
      };
      FileHandle2.prototype.chown = function(uid, gid) {
        return promisify3(this.vol, "fchown")(this.fd, uid, gid);
      };
      FileHandle2.prototype.close = function() {
        return promisify3(this.vol, "close")(this.fd);
      };
      FileHandle2.prototype.datasync = function() {
        return promisify3(this.vol, "fdatasync")(this.fd);
      };
      FileHandle2.prototype.read = function(buffer, offset, length, position) {
        return promisify3(this.vol, "read", function(bytesRead) {
          return { bytesRead, buffer };
        })(this.fd, buffer, offset, length, position);
      };
      FileHandle2.prototype.readFile = function(options) {
        return promisify3(this.vol, "readFile")(this.fd, options);
      };
      FileHandle2.prototype.stat = function(options) {
        return promisify3(this.vol, "fstat")(this.fd, options);
      };
      FileHandle2.prototype.sync = function() {
        return promisify3(this.vol, "fsync")(this.fd);
      };
      FileHandle2.prototype.truncate = function(len) {
        return promisify3(this.vol, "ftruncate")(this.fd, len);
      };
      FileHandle2.prototype.utimes = function(atime, mtime) {
        return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
      };
      FileHandle2.prototype.write = function(buffer, offset, length, position) {
        return promisify3(this.vol, "write", function(bytesWritten) {
          return { bytesWritten, buffer };
        })(this.fd, buffer, offset, length, position);
      };
      FileHandle2.prototype.writeFile = function(data, options) {
        return promisify3(this.vol, "writeFile")(this.fd, data, options);
      };
      return FileHandle2;
    }();
    exports.FileHandle = FileHandle;
    function createPromisesApi(vol2) {
      if (typeof Promise === "undefined")
        return null;
      return {
        FileHandle,
        access: function(path3, mode) {
          return promisify3(vol2, "access")(path3, mode);
        },
        appendFile: function(path3, data, options) {
          return promisify3(vol2, "appendFile")(path3 instanceof FileHandle ? path3.fd : path3, data, options);
        },
        chmod: function(path3, mode) {
          return promisify3(vol2, "chmod")(path3, mode);
        },
        chown: function(path3, uid, gid) {
          return promisify3(vol2, "chown")(path3, uid, gid);
        },
        copyFile: function(src, dest, flags) {
          return promisify3(vol2, "copyFile")(src, dest, flags);
        },
        lchmod: function(path3, mode) {
          return promisify3(vol2, "lchmod")(path3, mode);
        },
        lchown: function(path3, uid, gid) {
          return promisify3(vol2, "lchown")(path3, uid, gid);
        },
        link: function(existingPath, newPath) {
          return promisify3(vol2, "link")(existingPath, newPath);
        },
        lstat: function(path3, options) {
          return promisify3(vol2, "lstat")(path3, options);
        },
        mkdir: function(path3, options) {
          return promisify3(vol2, "mkdir")(path3, options);
        },
        mkdtemp: function(prefix, options) {
          return promisify3(vol2, "mkdtemp")(prefix, options);
        },
        open: function(path3, flags, mode) {
          return promisify3(vol2, "open", function(fd) {
            return new FileHandle(vol2, fd);
          })(path3, flags, mode);
        },
        readdir: function(path3, options) {
          return promisify3(vol2, "readdir")(path3, options);
        },
        readFile: function(id, options) {
          return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function(path3, options) {
          return promisify3(vol2, "readlink")(path3, options);
        },
        realpath: function(path3, options) {
          return promisify3(vol2, "realpath")(path3, options);
        },
        rename: function(oldPath, newPath) {
          return promisify3(vol2, "rename")(oldPath, newPath);
        },
        rmdir: function(path3) {
          return promisify3(vol2, "rmdir")(path3);
        },
        rm: function(path3, options) {
          return promisify3(vol2, "rm")(path3, options);
        },
        stat: function(path3, options) {
          return promisify3(vol2, "stat")(path3, options);
        },
        symlink: function(target, path3, type) {
          return promisify3(vol2, "symlink")(target, path3, type);
        },
        truncate: function(path3, len) {
          return promisify3(vol2, "truncate")(path3, len);
        },
        unlink: function(path3) {
          return promisify3(vol2, "unlink")(path3);
        },
        utimes: function(path3, atime, mtime) {
          return promisify3(vol2, "utimes")(path3, atime, mtime);
        },
        writeFile: function(id, data, options) {
          return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
        }
      };
    }
    exports.default = createPromisesApi;
  }
});

// ../../node_modules/.pnpm/fs-monkey@1.0.3/node_modules/fs-monkey/lib/correctPath.js
var require_correctPath = __commonJS({
  "../../node_modules/.pnpm/fs-monkey@1.0.3/node_modules/fs-monkey/lib/correctPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.unixify = unixify;
    exports.correctPath = correctPath;
    var isWin = process.platform === "win32";
    function removeTrailingSeparator(str) {
      var i2 = str.length - 1;
      if (i2 < 2) {
        return str;
      }
      while (isSeparator(str, i2)) {
        i2--;
      }
      return str.substr(0, i2 + 1);
    }
    function isSeparator(str, i2) {
      var _char = str[i2];
      return i2 > 0 && (_char === "/" || isWin && _char === "\\");
    }
    function normalizePath(str, stripTrailing) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false) {
        str = removeTrailingSeparator(str);
      }
      return str;
    }
    function unixify(filepath) {
      var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }
    function correctPath(filepath) {
      return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
    }
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/volume.js
var require_volume = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/volume.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d3, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
          d4.__proto__ = b3;
        } || function(d4, b3) {
          for (var p3 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p3))
              d4[p3] = b3[p3];
        };
        return extendStatics(d3, b2);
      };
      return function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FSWatcher = exports.StatWatcher = exports.Volume = exports.toUnixTimestamp = exports.bufferToEncoding = exports.dataToBuffer = exports.dataToStr = exports.pathToSteps = exports.filenameToSteps = exports.pathToFilename = exports.flagsToNumber = exports.FLAGS = void 0;
    var pathModule = require("path");
    var node_1 = require_node();
    var Stats_1 = require_Stats();
    var Dirent_1 = require_Dirent();
    var buffer_1 = require_buffer();
    var setImmediate_1 = require_setImmediate();
    var process_1 = require_process();
    var setTimeoutUnref_1 = require_setTimeoutUnref();
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    var events_1 = require("events");
    var encoding_1 = require_encoding();
    var errors = require_errors();
    var util = require("util");
    var promises_1 = require_promises();
    var resolveCrossPlatform = pathModule.resolve;
    var O_RDONLY = constants_1.constants.O_RDONLY;
    var O_WRONLY = constants_1.constants.O_WRONLY;
    var O_RDWR = constants_1.constants.O_RDWR;
    var O_CREAT = constants_1.constants.O_CREAT;
    var O_EXCL = constants_1.constants.O_EXCL;
    var O_TRUNC = constants_1.constants.O_TRUNC;
    var O_APPEND = constants_1.constants.O_APPEND;
    var O_SYNC = constants_1.constants.O_SYNC;
    var O_DIRECTORY = constants_1.constants.O_DIRECTORY;
    var F_OK = constants_1.constants.F_OK;
    var COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL;
    var COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
    var _a = pathModule.posix ? pathModule.posix : pathModule;
    var sep2 = _a.sep;
    var relative2 = _a.relative;
    var join4 = _a.join;
    var dirname2 = _a.dirname;
    var isWin = process_1.default.platform === "win32";
    var kMinPoolSpace = 128;
    var ERRSTR = {
      PATH_STR: "path must be a string or Buffer",
      FD: "fd must be a file descriptor",
      MODE_INT: "mode must be an int",
      CB: "callback must be a function",
      UID: "uid must be an unsigned int",
      GID: "gid must be an unsigned int",
      LEN: "len must be an integer",
      ATIME: "atime must be an integer",
      MTIME: "mtime must be an integer",
      PREFIX: "filename prefix is required",
      BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
      OFFSET: "offset must be an integer",
      LENGTH: "length must be an integer",
      POSITION: "position must be an integer"
    };
    var ERRSTR_OPTS = function(tipeof) {
      return "Expected options to be either an object or a string, but got ".concat(tipeof, " instead");
    };
    var ENOENT = "ENOENT";
    var EBADF = "EBADF";
    var EINVAL = "EINVAL";
    var EPERM = "EPERM";
    var EPROTO = "EPROTO";
    var EEXIST = "EEXIST";
    var ENOTDIR = "ENOTDIR";
    var EMFILE = "EMFILE";
    var EACCES = "EACCES";
    var EISDIR = "EISDIR";
    var ENOTEMPTY = "ENOTEMPTY";
    var ENOSYS = "ENOSYS";
    var ERR_FS_EISDIR = "ERR_FS_EISDIR";
    function formatError3(errorCode, func, path3, path22) {
      if (func === void 0) {
        func = "";
      }
      if (path3 === void 0) {
        path3 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      var pathFormatted = "";
      if (path3)
        pathFormatted = " '".concat(path3, "'");
      if (path22)
        pathFormatted += " -> '".concat(path22, "'");
      switch (errorCode) {
        case ENOENT:
          return "ENOENT: no such file or directory, ".concat(func).concat(pathFormatted);
        case EBADF:
          return "EBADF: bad file descriptor, ".concat(func).concat(pathFormatted);
        case EINVAL:
          return "EINVAL: invalid argument, ".concat(func).concat(pathFormatted);
        case EPERM:
          return "EPERM: operation not permitted, ".concat(func).concat(pathFormatted);
        case EPROTO:
          return "EPROTO: protocol error, ".concat(func).concat(pathFormatted);
        case EEXIST:
          return "EEXIST: file already exists, ".concat(func).concat(pathFormatted);
        case ENOTDIR:
          return "ENOTDIR: not a directory, ".concat(func).concat(pathFormatted);
        case EISDIR:
          return "EISDIR: illegal operation on a directory, ".concat(func).concat(pathFormatted);
        case EACCES:
          return "EACCES: permission denied, ".concat(func).concat(pathFormatted);
        case ENOTEMPTY:
          return "ENOTEMPTY: directory not empty, ".concat(func).concat(pathFormatted);
        case EMFILE:
          return "EMFILE: too many open files, ".concat(func).concat(pathFormatted);
        case ENOSYS:
          return "ENOSYS: function not implemented, ".concat(func).concat(pathFormatted);
        case ERR_FS_EISDIR:
          return "[ERR_FS_EISDIR]: Path is a directory: ".concat(func, " returned EISDIR (is a directory) ").concat(path3);
        default:
          return "".concat(errorCode, ": error occurred, ").concat(func).concat(pathFormatted);
      }
    }
    function createError(errorCode, func, path3, path22, Constructor) {
      if (func === void 0) {
        func = "";
      }
      if (path3 === void 0) {
        path3 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      if (Constructor === void 0) {
        Constructor = Error;
      }
      var error = new Constructor(formatError3(errorCode, func, path3, path22));
      error.code = errorCode;
      return error;
    }
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
      FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
      FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
      FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
      FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
      FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
      FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
      FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
      FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
      FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
      FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
      FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
      FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
      FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
      FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
      FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
      FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
      FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
    })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
    function flagsToNumber(flags) {
      if (typeof flags === "number")
        return flags;
      if (typeof flags === "string") {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== "undefined")
          return flagsNum;
      }
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    exports.flagsToNumber = flagsToNumber;
    function getOptions(defaults, options) {
      var opts;
      if (!options)
        return defaults;
      else {
        var tipeof = typeof options;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults, { encoding: options });
            break;
          case "object":
            opts = Object.assign({}, defaults, options);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer")
        (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    function optsGenerator(defaults) {
      return function(options) {
        return getOptions(defaults, options);
      };
    }
    function validateCallback(callback) {
      if (typeof callback !== "function")
        throw TypeError(ERRSTR.CB);
      return callback;
    }
    function optsAndCbGenerator(getOpts) {
      return function(options, callback) {
        return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
      };
    }
    var optsDefaults = {
      encoding: "utf8"
    };
    var getDefaultOpts = optsGenerator(optsDefaults);
    var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
    var readFileOptsDefaults = {
      flag: "r"
    };
    var getReadFileOptions = optsGenerator(readFileOptsDefaults);
    var writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.w]
    };
    var getWriteFileOptions = optsGenerator(writeFileDefaults);
    var appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.a]
    };
    var getAppendFileOpts = optsGenerator(appendFileDefaults);
    var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
    var realpathDefaults = optsDefaults;
    var getRealpathOptions = optsGenerator(realpathDefaults);
    var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
    var mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    var getMkdirOptions = function(options) {
      if (typeof options === "number")
        return Object.assign({}, mkdirDefaults, { mode: options });
      return Object.assign({}, mkdirDefaults, options);
    };
    var rmdirDefaults = {
      recursive: false
    };
    var getRmdirOptions = function(options) {
      return Object.assign({}, rmdirDefaults, options);
    };
    var getRmOpts = optsGenerator(optsDefaults);
    var getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
    var readdirDefaults = {
      encoding: "utf8",
      withFileTypes: false
    };
    var getReaddirOptions = optsGenerator(readdirDefaults);
    var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
    var statDefaults = {
      bigint: false
    };
    var getStatOptions = function(options) {
      if (options === void 0) {
        options = {};
      }
      return Object.assign({}, statDefaults, options);
    };
    var getStatOptsAndCb = function(options, callback) {
      return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
    };
    function getPathFromURLPosix(url) {
      if (url.hostname !== "") {
        throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
      }
      var pathname = url.pathname;
      for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          var third = pathname.codePointAt(n + 2) | 32;
          if (pathname[n + 1] === "2" && third === 102) {
            throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function pathToFilename(path3) {
      if (typeof path3 !== "string" && !buffer_1.Buffer.isBuffer(path3)) {
        try {
          if (!(path3 instanceof require("url").URL))
            throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(ERRSTR.PATH_STR);
        }
        path3 = getPathFromURLPosix(path3);
      }
      var pathString = String(path3);
      nullCheck(pathString);
      return pathString;
    }
    exports.pathToFilename = pathToFilename;
    var resolve2 = function(filename, base) {
      if (base === void 0) {
        base = process_1.default.cwd();
      }
      return resolveCrossPlatform(base, filename);
    };
    if (isWin) {
      _resolve_1 = resolve2;
      unixify_1 = require_correctPath().unixify;
      resolve2 = function(filename, base) {
        return unixify_1(_resolve_1(filename, base));
      };
    }
    var _resolve_1;
    var unixify_1;
    function filenameToSteps(filename, base) {
      var fullPath = resolve2(filename, base);
      var fullPathSansSlash = fullPath.substring(1);
      if (!fullPathSansSlash)
        return [];
      return fullPathSansSlash.split(sep2);
    }
    exports.filenameToSteps = filenameToSteps;
    function pathToSteps(path3) {
      return filenameToSteps(pathToFilename(path3));
    }
    exports.pathToSteps = pathToSteps;
    function dataToStr(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data.toString(encoding);
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data).toString(encoding);
      else
        return String(data);
    }
    exports.dataToStr = dataToStr;
    function dataToBuffer(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data;
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data);
      else
        return (0, buffer_1.bufferFrom)(String(data), encoding);
    }
    exports.dataToBuffer = dataToBuffer;
    function bufferToEncoding(buffer, encoding) {
      if (!encoding || encoding === "buffer")
        return buffer;
      else
        return buffer.toString(encoding);
    }
    exports.bufferToEncoding = bufferToEncoding;
    function nullCheck(path3, callback) {
      if (("" + path3).indexOf("\0") !== -1) {
        var er = new Error("Path must be a string without null bytes");
        er.code = ENOENT;
        if (typeof callback !== "function")
          throw er;
        process_1.default.nextTick(callback, er);
        return false;
      }
      return true;
    }
    function _modeToNumber(mode, def) {
      if (typeof mode === "number")
        return mode;
      if (typeof mode === "string")
        return parseInt(mode, 8);
      if (def)
        return modeToNumber(def);
      return void 0;
    }
    function modeToNumber(mode, def) {
      var result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result))
        throw new TypeError(ERRSTR.MODE_INT);
      return result;
    }
    function isFd(path3) {
      return path3 >>> 0 === path3;
    }
    function validateFd(fd) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
    }
    function toUnixTimestamp(time) {
      if (typeof time === "string" && +time == time) {
        return +time;
      }
      if (time instanceof Date) {
        return time.getTime() / 1e3;
      }
      if (isFinite(time)) {
        if (time < 0) {
          return Date.now() / 1e3;
        }
        return time;
      }
      throw new Error("Cannot parse time: " + time);
    }
    exports.toUnixTimestamp = toUnixTimestamp;
    function validateUid(uid) {
      if (typeof uid !== "number")
        throw TypeError(ERRSTR.UID);
    }
    function validateGid(gid) {
      if (typeof gid !== "number")
        throw TypeError(ERRSTR.GID);
    }
    function flattenJSON(nestedJSON) {
      var flatJSON = {};
      function flatten2(pathPrefix, node) {
        for (var path3 in node) {
          var contentOrNode = node[path3];
          var joinedPath = join4(pathPrefix, path3);
          if (typeof contentOrNode === "string") {
            flatJSON[joinedPath] = contentOrNode;
          } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
            flatten2(joinedPath, contentOrNode);
          } else {
            flatJSON[joinedPath] = null;
          }
        }
      }
      flatten2("", nestedJSON);
      return flatJSON;
    }
    var Volume = function() {
      function Volume2(props) {
        if (props === void 0) {
          props = {};
        }
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.maxFiles = 1e4;
        this.openFiles = 0;
        this.promisesApi = (0, promises_1.default)(this);
        this.statWatchers = {};
        this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
        var root = this.createLink();
        root.setNode(this.createNode(true));
        var self2 = this;
        this.StatWatcher = function(_super) {
          __extends(StatWatcher2, _super);
          function StatWatcher2() {
            return _super.call(this, self2) || this;
          }
          return StatWatcher2;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = function(_super) {
          __extends(class_1, _super);
          function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray([self2], args, false)) || this;
          }
          return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = function(_super) {
          __extends(class_2, _super);
          function class_2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray([self2], args, false)) || this;
          }
          return class_2;
        }(_WriteStream);
        this.FSWatcher = function(_super) {
          __extends(FSWatcher2, _super);
          function FSWatcher2() {
            return _super.call(this, self2) || this;
          }
          return FSWatcher2;
        }(FSWatcher);
        this.root = root;
      }
      Volume2.fromJSON = function(json, cwd) {
        var vol2 = new Volume2();
        vol2.fromJSON(json, cwd);
        return vol2;
      };
      Volume2.fromNestedJSON = function(json, cwd) {
        var vol2 = new Volume2();
        vol2.fromNestedJSON(json, cwd);
        return vol2;
      };
      Object.defineProperty(Volume2.prototype, "promises", {
        get: function() {
          if (this.promisesApi === null)
            throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        },
        enumerable: false,
        configurable: true
      });
      Volume2.prototype.createLink = function(parent2, name, isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        if (!parent2) {
          return new this.props.Link(this, null, "");
        }
        if (!name) {
          throw new Error("createLink: name cannot be empty");
        }
        return parent2.createChild(name, this.createNode(isDirectory, perm));
      };
      Volume2.prototype.deleteLink = function(link) {
        var parent2 = link.parent;
        if (parent2) {
          parent2.deleteChild(link);
          return true;
        }
        return false;
      };
      Volume2.prototype.newInoNumber = function() {
        var releasedFd = this.releasedInos.pop();
        if (releasedFd)
          return releasedFd;
        else {
          this.ino = (this.ino + 1) % 4294967295;
          return this.ino;
        }
      };
      Volume2.prototype.newFdNumber = function() {
        var releasedFd = this.releasedFds.pop();
        return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
      };
      Volume2.prototype.createNode = function(isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory)
          node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
      };
      Volume2.prototype.getNode = function(ino) {
        return this.inodes[ino];
      };
      Volume2.prototype.deleteNode = function(node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
      };
      Volume2.prototype.genRndStr = function() {
        var str = (Math.random() + 1).toString(36).substring(2, 8);
        if (str.length === 6)
          return str;
        else
          return this.genRndStr();
      };
      Volume2.prototype.getLink = function(steps) {
        return this.root.walk(steps);
      };
      Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link)
          throw createError(ENOENT, funcName, filename);
        return link;
      };
      Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
        var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link = this.root;
        var i2 = 0;
        while (i2 < steps.length) {
          var step = steps[i2];
          link = link.getChild(step);
          if (!link)
            return null;
          var node = link.getNode();
          if (node.isSymlink()) {
            steps = node.symlink.concat(steps.slice(i2 + 1));
            link = this.root;
            i2 = 0;
            continue;
          }
          i2++;
        }
        return link;
      };
      Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
        var link = this.getResolvedLink(filename);
        if (!link)
          throw createError(ENOENT, funcName, filename);
        return link;
      };
      Volume2.prototype.resolveSymlinks = function(link) {
        return this.getResolvedLink(link.steps.slice(1));
      };
      Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
        var link = this.getLinkOrThrow(filename, funcName);
        if (!link.getNode().isDirectory())
          throw createError(ENOTDIR, funcName, filename);
        return link;
      };
      Volume2.prototype.getLinkParent = function(steps) {
        return this.root.walk(steps, steps.length - 1);
      };
      Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link = this.getLinkParent(steps);
        if (!link)
          throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
        if (!link.getNode().isDirectory())
          throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
        return link;
      };
      Volume2.prototype.getFileByFd = function(fd) {
        return this.fds[String(fd)];
      };
      Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
        if (!isFd(fd))
          throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file)
          throw createError(EBADF, funcName);
        return file;
      };
      Volume2.prototype.wrapAsync = function(method, args, callback) {
        var _this = this;
        validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          var result;
          try {
            result = method.apply(_this, args);
          } catch (err) {
            callback(err);
            return;
          }
          callback(null, result);
        });
      };
      Volume2.prototype._toJSON = function(link, json, path3) {
        var _a2;
        if (link === void 0) {
          link = this.root;
        }
        if (json === void 0) {
          json = {};
        }
        var isEmpty = true;
        var children = link.children;
        if (link.getNode().isFile()) {
          children = (_a2 = {}, _a2[link.getName()] = link.parent.getChild(link.getName()), _a2);
          link = link.parent;
        }
        for (var name_1 in children) {
          isEmpty = false;
          var child = link.getChild(name_1);
          if (!child) {
            throw new Error("_toJSON: unexpected undefined");
          }
          var node = child.getNode();
          if (node.isFile()) {
            var filename = child.getPath();
            if (path3)
              filename = relative2(path3, filename);
            json[filename] = node.getString();
          } else if (node.isDirectory()) {
            this._toJSON(child, json, path3);
          }
        }
        var dirPath = link.getPath();
        if (path3)
          dirPath = relative2(path3, dirPath);
        if (dirPath && isEmpty) {
          json[dirPath] = null;
        }
        return json;
      };
      Volume2.prototype.toJSON = function(paths, json, isRelative) {
        if (json === void 0) {
          json = {};
        }
        if (isRelative === void 0) {
          isRelative = false;
        }
        var links = [];
        if (paths) {
          if (!(paths instanceof Array))
            paths = [paths];
          for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var path3 = paths_1[_i];
            var filename = pathToFilename(path3);
            var link = this.getResolvedLink(filename);
            if (!link)
              continue;
            links.push(link);
          }
        } else {
          links.push(this.root);
        }
        if (!links.length)
          return json;
        for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
          var link = links_1[_a2];
          this._toJSON(link, json, isRelative ? link.getPath() : "");
        }
        return json;
      };
      Volume2.prototype.fromJSON = function(json, cwd) {
        if (cwd === void 0) {
          cwd = process_1.default.cwd();
        }
        for (var filename in json) {
          var data = json[filename];
          filename = resolve2(filename, cwd);
          if (typeof data === "string") {
            var dir = dirname2(filename);
            this.mkdirpBase(dir, 511);
            this.writeFileSync(filename, data);
          } else {
            this.mkdirpBase(filename, 511);
          }
        }
      };
      Volume2.prototype.fromNestedJSON = function(json, cwd) {
        this.fromJSON(flattenJSON(json), cwd);
      };
      Volume2.prototype.reset = function() {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
      };
      Volume2.prototype.mountSync = function(mountpoint, json) {
        this.fromJSON(json, mountpoint);
      };
      Volume2.prototype.openLink = function(link, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
          throw createError(EMFILE, "open", link.getPath());
        }
        var realLink = link;
        if (resolveSymlinks)
          realLink = this.resolveSymlinks(link);
        if (!realLink)
          throw createError(ENOENT, "open", link.getPath());
        var node = realLink.getNode();
        if (node.isDirectory()) {
          if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
            throw createError(EISDIR, "open", link.getPath());
        } else {
          if (flagsNum & O_DIRECTORY)
            throw createError(ENOTDIR, "open", link.getPath());
        }
        if (!(flagsNum & O_WRONLY)) {
          if (!node.canRead()) {
            throw createError(EACCES, "open", link.getPath());
          }
        }
        if (flagsNum & O_RDWR) {
        }
        var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC)
          file.truncate();
        return file;
      };
      Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        if (link && flagsNum & O_EXCL)
          throw createError(EEXIST, "open", filename);
        if (!link && flagsNum & O_CREAT) {
          var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
          if (!dirLink)
            throw createError(ENOENT, "open", sep2 + steps.join(sep2));
          if (flagsNum & O_CREAT && typeof modeNum === "number") {
            link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
          }
        }
        if (link)
          return this.openLink(link, flagsNum, resolveSymlinks);
        throw createError(ENOENT, "open", filename);
      };
      Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file)
          throw createError(ENOENT, "open", filename);
        return file.fd;
      };
      Volume2.prototype.openSync = function(path3, flags, mode) {
        if (mode === void 0) {
          mode = 438;
        }
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path3);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
      };
      Volume2.prototype.open = function(path3, flags, a2, b2) {
        var mode = a2;
        var callback = b2;
        if (typeof a2 === "function") {
          mode = 438;
          callback = a2;
        }
        mode = mode || 438;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path3);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
      };
      Volume2.prototype.closeFile = function(file) {
        if (!this.fds[file.fd])
          return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
      };
      Volume2.prototype.closeSync = function(fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, "close");
        this.closeFile(file);
      };
      Volume2.prototype.close = function(fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
      };
      Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
        if (typeof id === "number") {
          var file = this.fds[id];
          if (!file)
            throw createError(ENOENT);
          return file;
        } else {
          return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
      };
      Volume2.prototype.readBase = function(fd, buffer, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer, Number(offset), Number(length), position);
      };
      Volume2.prototype.readSync = function(fd, buffer, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer, offset, length, position);
      };
      Volume2.prototype.read = function(fd, buffer, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        if (length === 0) {
          return process_1.default.nextTick(function() {
            if (callback)
              callback(null, 0, buffer);
          });
        }
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.readBase(fd, buffer, offset, length, position);
            callback(null, bytes, buffer);
          } catch (err) {
            callback(err);
          }
        });
      };
      Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === "number";
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd)
          fd = id;
        else {
          var filename = pathToFilename(id);
          var steps = filenameToSteps(filename);
          var link = this.getResolvedLink(steps);
          if (link) {
            var node = link.getNode();
            if (node.isDirectory())
              throw createError(EISDIR, "open", link.getPath());
          }
          fd = this.openSync(id, flagsNum);
        }
        try {
          result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
          if (!userOwnsFd) {
            this.closeSync(fd);
          }
        }
        return result;
      };
      Volume2.prototype.readFileSync = function(file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
      };
      Volume2.prototype.readFile = function(id, a2, b2) {
        var _a2 = optsAndCbGenerator(getReadFileOptions)(a2, b2), opts = _a2[0], callback = _a2[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
      };
      Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, "write");
        return file.write(buf, offset, length, position);
      };
      Volume2.prototype.writeSync = function(fd, a2, b2, c2, d3) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer = typeof a2 !== "string";
        if (isBuffer) {
          offset = (b2 || 0) | 0;
          length = c2;
          position = d3;
        } else {
          position = b2;
          encoding = c2;
        }
        var buf = dataToBuffer(a2, encoding);
        if (isBuffer) {
          if (typeof length === "undefined") {
            length = buf.length;
          }
        } else {
          offset = 0;
          length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
      };
      Volume2.prototype.write = function(fd, a2, b2, c2, d3, e3) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a2;
        var tipb = typeof b2;
        var tipc = typeof c2;
        var tipd = typeof d3;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b2;
          } else if (tipc === "function") {
            offset = b2 | 0;
            callback = c2;
          } else if (tipd === "function") {
            offset = b2 | 0;
            length = c2;
            callback = d3;
          } else {
            offset = b2 | 0;
            length = c2;
            position = d3;
            callback = e3;
          }
        } else {
          if (tipb === "function") {
            callback = b2;
          } else if (tipc === "function") {
            position = b2;
            callback = c2;
          } else if (tipd === "function") {
            position = b2;
            encoding = c2;
            callback = d3;
          }
        }
        var buf = dataToBuffer(a2, encoding);
        if (tipa !== "string") {
          if (typeof length === "undefined")
            length = buf.length;
        } else {
          offset = 0;
          length = buf.length;
        }
        var cb = validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.writeBase(fd, buf, offset, length, position);
            if (tipa !== "string") {
              cb(null, bytes, buf);
            } else {
              cb(null, bytes, a2);
            }
          } catch (err) {
            cb(err);
          }
        });
      };
      Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
        var isUserFd = typeof id === "number";
        var fd;
        if (isUserFd)
          fd = id;
        else {
          fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? void 0 : 0;
        try {
          while (length > 0) {
            var written = this.writeSync(fd, buf, offset, length, position);
            offset += written;
            length -= written;
            if (position !== void 0)
              position += written;
          }
        } finally {
          if (!isUserFd)
            this.closeSync(fd);
        }
      };
      Volume2.prototype.writeFileSync = function(id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
      };
      Volume2.prototype.writeFile = function(id, data, a2, b2) {
        var options = a2;
        var callback = b2;
        if (typeof a2 === "function") {
          options = writeFileDefaults;
          callback = a2;
        }
        var cb = validateCallback(callback);
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
      };
      Volume2.prototype.linkBase = function(filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1)
          throw createError(ENOENT, "link", filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        var dir2 = this.getLinkParent(steps2);
        if (!dir2)
          throw createError(ENOENT, "link", filename1, filename2);
        var name = steps2[steps2.length - 1];
        if (dir2.getChild(name))
          throw createError(EEXIST, "link", filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name, node);
      };
      Volume2.prototype.copyFileBase = function(src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
          if (this.existsSync(dest)) {
            throw createError(EEXIST, "copyFile", src, dest);
          }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
          throw createError(ENOSYS, "copyFile", src, dest);
        }
        this.writeFileBase(dest, buf, FLAGS.w, 438);
      };
      Volume2.prototype.copyFileSync = function(src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
      };
      Volume2.prototype.copyFile = function(src, dest, a2, b2) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a2 === "function") {
          flags = 0;
          callback = a2;
        } else {
          flags = a2;
          callback = b2;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
      };
      Volume2.prototype.linkSync = function(existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
      };
      Volume2.prototype.link = function(existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.unlinkBase = function(filename) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link)
          throw createError(ENOENT, "unlink", filename);
        if (link.length)
          throw Error("Dir not empty...");
        this.deleteLink(link);
        var node = link.getNode();
        node.nlink--;
        if (node.nlink <= 0) {
          this.deleteNode(node);
        }
      };
      Volume2.prototype.unlinkSync = function(path3) {
        var filename = pathToFilename(path3);
        this.unlinkBase(filename);
      };
      Volume2.prototype.unlink = function(path3, callback) {
        var filename = pathToFilename(path3);
        this.wrapAsync(this.unlinkBase, [filename], callback);
      };
      Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink)
          throw createError(ENOENT, "symlink", targetFilename, pathFilename);
        var name = pathSteps[pathSteps.length - 1];
        if (dirLink.getChild(name))
          throw createError(EEXIST, "symlink", targetFilename, pathFilename);
        var symlink = dirLink.createChild(name);
        symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink;
      };
      Volume2.prototype.symlinkSync = function(target, path3, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path3);
        this.symlinkBase(targetFilename, pathFilename);
      };
      Volume2.prototype.symlink = function(target, path3, a2, b2) {
        var callback = validateCallback(typeof a2 === "function" ? a2 : b2);
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path3);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
      };
      Volume2.prototype.realpathBase = function(filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink)
          throw createError(ENOENT, "realpath", filename);
        return (0, encoding_1.strToEncoding)(realLink.getPath() || "/", encoding);
      };
      Volume2.prototype.realpathSync = function(path3, options) {
        return this.realpathBase(pathToFilename(path3), getRealpathOptions(options).encoding);
      };
      Volume2.prototype.realpath = function(path3, a2, b2) {
        var _a2 = getRealpathOptsAndCb(a2, b2), opts = _a2[0], callback = _a2[1];
        var pathFilename = pathToFilename(path3);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
      };
      Volume2.prototype.lstatBase = function(filename, bigint, throwIfNoEntry) {
        if (bigint === void 0) {
          bigint = false;
        }
        if (throwIfNoEntry === void 0) {
          throwIfNoEntry = false;
        }
        var link = this.getLink(filenameToSteps(filename));
        if (link) {
          return Stats_1.default.build(link.getNode(), bigint);
        } else if (!throwIfNoEntry) {
          return void 0;
        } else {
          throw createError(ENOENT, "lstat", filename);
        }
      };
      Volume2.prototype.lstatSync = function(path3, options) {
        var _a2 = getStatOptions(options), _b = _a2.throwIfNoEntry, throwIfNoEntry = _b === void 0 ? true : _b, _c = _a2.bigint, bigint = _c === void 0 ? false : _c;
        return this.lstatBase(pathToFilename(path3), bigint, throwIfNoEntry);
      };
      Volume2.prototype.lstat = function(path3, a2, b2) {
        var _a2 = getStatOptsAndCb(a2, b2), _b = _a2[0], _c = _b.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c, _d = _b.bigint, bigint = _d === void 0 ? false : _d, callback = _a2[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path3), bigint, throwIfNoEntry], callback);
      };
      Volume2.prototype.statBase = function(filename, bigint, throwIfNoEntry) {
        if (bigint === void 0) {
          bigint = false;
        }
        if (throwIfNoEntry === void 0) {
          throwIfNoEntry = true;
        }
        var link = this.getResolvedLink(filenameToSteps(filename));
        if (link) {
          return Stats_1.default.build(link.getNode(), bigint);
        } else if (!throwIfNoEntry) {
          return void 0;
        } else {
          throw createError(ENOENT, "stat", filename);
        }
      };
      Volume2.prototype.statSync = function(path3, options) {
        var _a2 = getStatOptions(options), _b = _a2.bigint, bigint = _b === void 0 ? true : _b, _c = _a2.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c;
        return this.statBase(pathToFilename(path3), bigint, throwIfNoEntry);
      };
      Volume2.prototype.stat = function(path3, a2, b2) {
        var _a2 = getStatOptsAndCb(a2, b2), _b = _a2[0], _c = _b.bigint, bigint = _c === void 0 ? false : _c, _d = _b.throwIfNoEntry, throwIfNoEntry = _d === void 0 ? true : _d, callback = _a2[1];
        this.wrapAsync(this.statBase, [pathToFilename(path3), bigint, throwIfNoEntry], callback);
      };
      Volume2.prototype.fstatBase = function(fd, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file)
          throw createError(EBADF, "fstat");
        return Stats_1.default.build(file.node, bigint);
      };
      Volume2.prototype.fstatSync = function(fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
      };
      Volume2.prototype.fstat = function(fd, a2, b2) {
        var _a2 = getStatOptsAndCb(a2, b2), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
      };
      Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
        var link = this.getLink(filenameToSteps(oldPathFilename));
        if (!link)
          throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var newPathSteps = filenameToSteps(newPathFilename);
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink)
          throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var oldLinkParent = link.parent;
        if (oldLinkParent) {
          oldLinkParent.deleteChild(link);
        }
        var name = newPathSteps[newPathSteps.length - 1];
        link.name = name;
        link.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name], false);
        newPathDirLink.setChild(link.getName(), link);
      };
      Volume2.prototype.renameSync = function(oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
      };
      Volume2.prototype.rename = function(oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.existsBase = function(filename) {
        return !!this.statBase(filename);
      };
      Volume2.prototype.existsSync = function(path3) {
        try {
          return this.existsBase(pathToFilename(path3));
        } catch (err) {
          return false;
        }
      };
      Volume2.prototype.exists = function(path3, callback) {
        var _this = this;
        var filename = pathToFilename(path3);
        if (typeof callback !== "function")
          throw Error(ERRSTR.CB);
        (0, setImmediate_1.default)(function() {
          try {
            callback(_this.existsBase(filename));
          } catch (err) {
            callback(false);
          }
        });
      };
      Volume2.prototype.accessBase = function(filename, mode) {
        var link = this.getLinkOrThrow(filename, "access");
      };
      Volume2.prototype.accessSync = function(path3, mode) {
        if (mode === void 0) {
          mode = F_OK;
        }
        var filename = pathToFilename(path3);
        mode = mode | 0;
        this.accessBase(filename, mode);
      };
      Volume2.prototype.access = function(path3, a2, b2) {
        var mode = F_OK;
        var callback;
        if (typeof a2 !== "function") {
          mode = a2 | 0;
          callback = validateCallback(b2);
        } else {
          callback = a2;
        }
        var filename = pathToFilename(path3);
        this.wrapAsync(this.accessBase, [filename, mode], callback);
      };
      Volume2.prototype.appendFileSync = function(id, data, options) {
        if (options === void 0) {
          options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        if (!opts.flag || isFd(id))
          opts.flag = "a";
        this.writeFileSync(id, data, opts);
      };
      Volume2.prototype.appendFile = function(id, data, a2, b2) {
        var _a2 = getAppendFileOptsAndCb(a2, b2), opts = _a2[0], callback = _a2[1];
        if (!opts.flag || isFd(id))
          opts.flag = "a";
        this.writeFile(id, data, opts, callback);
      };
      Volume2.prototype.readdirBase = function(filename, options) {
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);
        if (!link)
          throw createError(ENOENT, "readdir", filename);
        var node = link.getNode();
        if (!node.isDirectory())
          throw createError(ENOTDIR, "scandir", filename);
        if (options.withFileTypes) {
          var list_1 = [];
          for (var name_2 in link.children) {
            var child = link.getChild(name_2);
            if (!child) {
              continue;
            }
            list_1.push(Dirent_1.default.build(child, options.encoding));
          }
          if (!isWin && options.encoding !== "buffer")
            list_1.sort(function(a2, b2) {
              if (a2.name < b2.name)
                return -1;
              if (a2.name > b2.name)
                return 1;
              return 0;
            });
          return list_1;
        }
        var list = [];
        for (var name_3 in link.children) {
          list.push((0, encoding_1.strToEncoding)(name_3, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer")
          list.sort();
        return list;
      };
      Volume2.prototype.readdirSync = function(path3, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path3);
        return this.readdirBase(filename, opts);
      };
      Volume2.prototype.readdir = function(path3, a2, b2) {
        var _a2 = getReaddirOptsAndCb(a2, b2), options = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path3);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
      };
      Volume2.prototype.readlinkBase = function(filename, encoding) {
        var link = this.getLinkOrThrow(filename, "readlink");
        var node = link.getNode();
        if (!node.isSymlink())
          throw createError(EINVAL, "readlink", filename);
        var str = sep2 + node.symlink.join(sep2);
        return (0, encoding_1.strToEncoding)(str, encoding);
      };
      Volume2.prototype.readlinkSync = function(path3, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path3);
        return this.readlinkBase(filename, opts.encoding);
      };
      Volume2.prototype.readlink = function(path3, a2, b2) {
        var _a2 = getDefaultOptsAndCb(a2, b2), opts = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path3);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
      };
      Volume2.prototype.fsyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fsync");
      };
      Volume2.prototype.fsyncSync = function(fd) {
        this.fsyncBase(fd);
      };
      Volume2.prototype.fsync = function(fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
      };
      Volume2.prototype.fdatasyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fdatasync");
      };
      Volume2.prototype.fdatasyncSync = function(fd) {
        this.fdatasyncBase(fd);
      };
      Volume2.prototype.fdatasync = function(fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
      };
      Volume2.prototype.ftruncateBase = function(fd, len) {
        var file = this.getFileByFdOrThrow(fd, "ftruncate");
        file.truncate(len);
      };
      Volume2.prototype.ftruncateSync = function(fd, len) {
        this.ftruncateBase(fd, len);
      };
      Volume2.prototype.ftruncate = function(fd, a2, b2) {
        var len = typeof a2 === "number" ? a2 : 0;
        var callback = validateCallback(typeof a2 === "number" ? b2 : a2);
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
      };
      Volume2.prototype.truncateBase = function(path3, len) {
        var fd = this.openSync(path3, "r+");
        try {
          this.ftruncateSync(fd, len);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.truncateSync = function(id, len) {
        if (isFd(id))
          return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
      };
      Volume2.prototype.truncate = function(id, a2, b2) {
        var len = typeof a2 === "number" ? a2 : 0;
        var callback = validateCallback(typeof a2 === "number" ? b2 : a2);
        if (isFd(id))
          return this.ftruncate(id, len, callback);
        this.wrapAsync(this.truncateBase, [id, len], callback);
      };
      Volume2.prototype.futimesBase = function(fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, "futimes");
        var node = file.node;
        node.atime = new Date(atime * 1e3);
        node.mtime = new Date(mtime * 1e3);
      };
      Volume2.prototype.futimesSync = function(fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.utimesBase = function(filename, atime, mtime) {
        var fd = this.openSync(filename, "r");
        try {
          this.futimesBase(fd, atime, mtime);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.utimesSync = function(path3, atime, mtime) {
        this.utimesBase(pathToFilename(path3), toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.utimes = function(path3, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path3), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.mkdirBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        if (!steps.length) {
          throw createError(EEXIST, "mkdir", filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
        var name = steps[steps.length - 1];
        if (dir.getChild(name))
          throw createError(EEXIST, "mkdir", filename);
        dir.createChild(name, this.createNode(true, modeNum));
      };
      Volume2.prototype.mkdirpBase = function(filename, modeNum) {
        var fullPath = resolve2(filename);
        var fullPathSansSlash = fullPath.substring(1);
        var steps = !fullPathSansSlash ? [] : fullPathSansSlash.split(sep2);
        var link = this.root;
        var created = false;
        for (var i2 = 0; i2 < steps.length; i2++) {
          var step = steps[i2];
          if (!link.getNode().isDirectory())
            throw createError(ENOTDIR, "mkdir", link.getPath());
          var child = link.getChild(step);
          if (child) {
            if (child.getNode().isDirectory())
              link = child;
            else
              throw createError(ENOTDIR, "mkdir", child.getPath());
          } else {
            link = link.createChild(step, this.createNode(true, modeNum));
            created = true;
          }
        }
        return created ? fullPath : void 0;
      };
      Volume2.prototype.mkdirSync = function(path3, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path3);
        if (opts.recursive)
          return this.mkdirpBase(filename, modeNum);
        this.mkdirBase(filename, modeNum);
      };
      Volume2.prototype.mkdir = function(path3, a2, b2) {
        var opts = getMkdirOptions(a2);
        var callback = validateCallback(typeof a2 === "function" ? a2 : b2);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path3);
        if (opts.recursive)
          this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
        else
          this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
      };
      Volume2.prototype.mkdirpSync = function(path3, mode) {
        return this.mkdirSync(path3, { mode, recursive: true });
      };
      Volume2.prototype.mkdirp = function(path3, a2, b2) {
        var mode = typeof a2 === "function" ? void 0 : a2;
        var callback = validateCallback(typeof a2 === "function" ? a2 : b2);
        this.mkdir(path3, { mode, recursive: true }, callback);
      };
      Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
        if (retry === void 0) {
          retry = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
          this.mkdirBase(filename, 511);
          return (0, encoding_1.strToEncoding)(filename, encoding);
        } catch (err) {
          if (err.code === EEXIST) {
            if (retry > 1)
              return this.mkdtempBase(prefix, encoding, retry - 1);
            else
              throw Error("Could not create temp dir.");
          } else
            throw err;
        }
      };
      Volume2.prototype.mkdtempSync = function(prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== "string")
          throw new TypeError("filename prefix is required");
        nullCheck(prefix);
        return this.mkdtempBase(prefix, encoding);
      };
      Volume2.prototype.mkdtemp = function(prefix, a2, b2) {
        var _a2 = getDefaultOptsAndCb(a2, b2), encoding = _a2[0].encoding, callback = _a2[1];
        if (!prefix || typeof prefix !== "string")
          throw new TypeError("filename prefix is required");
        if (!nullCheck(prefix))
          return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
      };
      Volume2.prototype.rmdirBase = function(filename, options) {
        var opts = getRmdirOptions(options);
        var link = this.getLinkAsDirOrThrow(filename, "rmdir");
        if (link.length && !opts.recursive)
          throw createError(ENOTEMPTY, "rmdir", filename);
        this.deleteLink(link);
      };
      Volume2.prototype.rmdirSync = function(path3, options) {
        this.rmdirBase(pathToFilename(path3), options);
      };
      Volume2.prototype.rmdir = function(path3, a2, b2) {
        var opts = getRmdirOptions(a2);
        var callback = validateCallback(typeof a2 === "function" ? a2 : b2);
        this.wrapAsync(this.rmdirBase, [pathToFilename(path3), opts], callback);
      };
      Volume2.prototype.rmBase = function(filename, options) {
        if (options === void 0) {
          options = {};
        }
        var link = this.getResolvedLink(filename);
        if (!link) {
          if (!options.force)
            throw createError(ENOENT, "stat", filename);
          return;
        }
        if (link.getNode().isDirectory()) {
          if (!options.recursive) {
            throw createError(ERR_FS_EISDIR, "rm", filename);
          }
        }
        this.deleteLink(link);
      };
      Volume2.prototype.rmSync = function(path3, options) {
        this.rmBase(pathToFilename(path3), options);
      };
      Volume2.prototype.rm = function(path3, a2, b2) {
        var _a2 = getRmOptsAndCb(a2, b2), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.rmBase, [pathToFilename(path3), opts], callback);
      };
      Volume2.prototype.fchmodBase = function(fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, "fchmod");
        file.chmod(modeNum);
      };
      Volume2.prototype.fchmodSync = function(fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
      };
      Volume2.prototype.fchmod = function(fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
      };
      Volume2.prototype.chmodBase = function(filename, modeNum) {
        var fd = this.openSync(filename, "r");
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.chmodSync = function(path3, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path3);
        this.chmodBase(filename, modeNum);
      };
      Volume2.prototype.chmod = function(path3, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path3);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.lchmodBase = function(filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.lchmodSync = function(path3, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path3);
        this.lchmodBase(filename, modeNum);
      };
      Volume2.prototype.lchmod = function(path3, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path3);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.fchownBase = function(fd, uid, gid) {
        this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
      };
      Volume2.prototype.fchownSync = function(fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
      };
      Volume2.prototype.fchown = function(fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
      };
      Volume2.prototype.chownBase = function(filename, uid, gid) {
        var link = this.getResolvedLinkOrThrow(filename, "chown");
        var node = link.getNode();
        node.chown(uid, gid);
      };
      Volume2.prototype.chownSync = function(path3, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path3), uid, gid);
      };
      Volume2.prototype.chown = function(path3, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path3), uid, gid], callback);
      };
      Volume2.prototype.lchownBase = function(filename, uid, gid) {
        this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
      };
      Volume2.prototype.lchownSync = function(path3, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path3), uid, gid);
      };
      Volume2.prototype.lchown = function(path3, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path3), uid, gid], callback);
      };
      Volume2.prototype.watchFile = function(path3, a2, b2) {
        var filename = pathToFilename(path3);
        var options = a2;
        var listener = b2;
        if (typeof options === "function") {
          listener = a2;
          options = null;
        }
        if (typeof listener !== "function") {
          throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && typeof options === "object") {
          if (typeof options.interval === "number")
            interval = options.interval;
          if (typeof options.persistent === "boolean")
            persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
          watcher = new this.StatWatcher();
          watcher.start(filename, persistent, interval);
          this.statWatchers[filename] = watcher;
        }
        watcher.addListener("change", listener);
        return watcher;
      };
      Volume2.prototype.unwatchFile = function(path3, listener) {
        var filename = pathToFilename(path3);
        var watcher = this.statWatchers[filename];
        if (!watcher)
          return;
        if (typeof listener === "function") {
          watcher.removeListener("change", listener);
        } else {
          watcher.removeAllListeners("change");
        }
        if (watcher.listenerCount("change") === 0) {
          watcher.stop();
          delete this.statWatchers[filename];
        }
      };
      Volume2.prototype.createReadStream = function(path3, options) {
        return new this.ReadStream(path3, options);
      };
      Volume2.prototype.createWriteStream = function(path3, options) {
        return new this.WriteStream(path3, options);
      };
      Volume2.prototype.watch = function(path3, options, listener) {
        var filename = pathToFilename(path3);
        var givenOptions = options;
        if (typeof options === "function") {
          listener = options;
          givenOptions = null;
        }
        var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
        if (persistent === void 0)
          persistent = true;
        if (recursive === void 0)
          recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
          watcher.addListener("change", listener);
        }
        return watcher;
      };
      Volume2.fd = 2147483647;
      return Volume2;
    }();
    exports.Volume = Volume;
    function emitStop(self2) {
      self2.emit("stop");
    }
    var StatWatcher = function(_super) {
      __extends(StatWatcher2, _super);
      function StatWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this.onInterval = function() {
          try {
            var stats = _this.vol.statSync(_this.filename);
            if (_this.hasChanged(stats)) {
              _this.emit("change", stats, _this.prev);
              _this.prev = stats;
            }
          } finally {
            _this.loop();
          }
        };
        _this.vol = vol2;
        return _this;
      }
      StatWatcher2.prototype.loop = function() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      };
      StatWatcher2.prototype.hasChanged = function(stats) {
        if (stats.mtimeMs > this.prev.mtimeMs)
          return true;
        if (stats.nlink !== this.prev.nlink)
          return true;
        return false;
      };
      StatWatcher2.prototype.start = function(path3, persistent, interval) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (interval === void 0) {
          interval = 5007;
        }
        this.filename = pathToFilename(path3);
        this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : global) : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
      };
      StatWatcher2.prototype.stop = function() {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
      };
      return StatWatcher2;
    }(events_1.EventEmitter);
    exports.StatWatcher = StatWatcher;
    var pool;
    function allocNewPool(poolSize) {
      pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
      pool.used = 0;
    }
    util.inherits(FsReadStream, stream_1.Readable);
    exports.ReadStream = FsReadStream;
    function FsReadStream(vol2, path3, options) {
      if (!(this instanceof FsReadStream))
        return new FsReadStream(vol2, path3, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      stream_1.Readable.call(this, options);
      this.path = pathToFilename(path3);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = void 0;
      this.bytesRead = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
      }
      if (typeof this.fd !== "number")
        this.open();
      this.on("end", function() {
        if (this.autoClose) {
          if (this.destroy)
            this.destroy();
        }
      });
    }
    FsReadStream.prototype.open = function() {
      var self2 = this;
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (self2.autoClose) {
            if (self2.destroy)
              self2.destroy();
          }
          self2.emit("error", er);
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2.read();
      });
    };
    FsReadStream.prototype._read = function(n) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._read(n);
        });
      }
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this._readableState.highWaterMark);
      }
      var thisPool = pool;
      var toRead = Math.min(pool.length - pool.used, n);
      var start = pool.used;
      if (this.pos !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      var self2 = this;
      this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
      if (this.pos !== void 0)
        this.pos += toRead;
      pool.used += toRead;
      function onread(er, bytesRead) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          self2.emit("error", er);
        } else {
          var b2 = null;
          if (bytesRead > 0) {
            self2.bytesRead += bytesRead;
            b2 = thisPool.slice(start, start + bytesRead);
          }
          self2.push(b2);
        }
      }
    };
    FsReadStream.prototype._destroy = function(err, cb) {
      this.close(function(err2) {
        cb(err || err2);
      });
    };
    FsReadStream.prototype.close = function(cb) {
      var _this = this;
      var _a2;
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      if (typeof ((_a2 = this._readableState) === null || _a2 === void 0 ? void 0 : _a2.closed) === "boolean") {
        this._readableState.closed = true;
      } else {
        this.closed = true;
      }
      this._vol.close(this.fd, function(er) {
        if (er)
          _this.emit("error", er);
        else
          _this.emit("close");
      });
      this.fd = null;
    };
    function closeOnOpen(fd) {
      this.close();
    }
    util.inherits(FsWriteStream, stream_1.Writable);
    exports.WriteStream = FsWriteStream;
    function FsWriteStream(vol2, path3, options) {
      if (!(this instanceof FsWriteStream))
        return new FsWriteStream(vol2, path3, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      stream_1.Writable.call(this, options);
      this.path = pathToFilename(path3);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
      this.pos = void 0;
      this.bytesWritten = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
          throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      if (typeof this.fd !== "number")
        this.open();
      this.once("finish", function() {
        if (this.autoClose) {
          this.close();
        }
      });
    }
    FsWriteStream.prototype.open = function() {
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (this.autoClose && this.destroy) {
            this.destroy();
          }
          this.emit("error", er);
          return;
        }
        this.fd = fd;
        this.emit("open", fd);
      }.bind(this));
    };
    FsWriteStream.prototype._write = function(data, encoding, cb) {
      if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
        return this.emit("error", new Error("Invalid data"));
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      var self2 = this;
      this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += data.length;
    };
    FsWriteStream.prototype._writev = function(data, cb) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      var self2 = this;
      var len = data.length;
      var chunks = new Array(len);
      var size = 0;
      for (var i2 = 0; i2 < len; i2++) {
        var chunk = data[i2].chunk;
        chunks[i2] = chunk;
        size += chunk.length;
      }
      var buf = buffer_1.Buffer.concat(chunks);
      this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
        if (er) {
          if (self2.destroy)
            self2.destroy();
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += size;
    };
    FsWriteStream.prototype.close = function(cb) {
      var _this = this;
      var _a2;
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      if (typeof ((_a2 = this._writableState) === null || _a2 === void 0 ? void 0 : _a2.closed) === "boolean") {
        this._writableState.closed = true;
      } else {
        this.closed = true;
      }
      this._vol.close(this.fd, function(er) {
        if (er)
          _this.emit("error", er);
        else
          _this.emit("close");
      });
      this.fd = null;
    };
    FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
    FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
    var FSWatcher = function(_super) {
      __extends(FSWatcher2, _super);
      function FSWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this._filename = "";
        _this._filenameEncoded = "";
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._onNodeChange = function() {
          _this._emit("change");
        };
        _this._onParentChild = function(link) {
          if (link.getName() === _this._getName()) {
            _this._emit("rename");
          }
        };
        _this._emit = function(type) {
          _this.emit("change", type, _this._filenameEncoded);
        };
        _this._persist = function() {
          _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol2;
        return _this;
      }
      FSWatcher2.prototype._getName = function() {
        return this._steps[this._steps.length - 1];
      };
      FSWatcher2.prototype.start = function(path3, persistent, recursive, encoding) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (recursive === void 0) {
          recursive = false;
        }
        if (encoding === void 0) {
          encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path3);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        this._recursive = recursive;
        this._encoding = encoding;
        try {
          this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (err) {
          var error = new Error("watch ".concat(this._filename, " ").concat(err.code));
          error.code = err.code;
          error.errno = err.code;
          throw error;
        }
        this._link.getNode().on("change", this._onNodeChange);
        this._link.on("child:add", this._onNodeChange);
        this._link.on("child:delete", this._onNodeChange);
        var parent2 = this._link.parent;
        if (parent2) {
          parent2.setMaxListeners(parent2.getMaxListeners() + 1);
          parent2.on("child:delete", this._onParentChild);
        }
        if (persistent)
          this._persist();
      };
      FSWatcher2.prototype.close = function() {
        clearTimeout(this._timer);
        this._link.getNode().removeListener("change", this._onNodeChange);
        var parent2 = this._link.parent;
        if (parent2) {
          parent2.removeListener("child:delete", this._onParentChild);
        }
      };
      return FSWatcher2;
    }(events_1.EventEmitter);
    exports.FSWatcher = FSWatcher;
  }
});

// ../../node_modules/.pnpm/fs-monkey@1.0.3/node_modules/fs-monkey/lib/util/lists.js
var require_lists = __commonJS({
  "../../node_modules/.pnpm/fs-monkey@1.0.3/node_modules/fs-monkey/lib/util/lists.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fsAsyncMethods = exports.fsSyncMethods = exports.fsProps = void 0;
    var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
    exports.fsProps = fsProps;
    var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
    exports.fsSyncMethods = fsSyncMethods;
    var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
    exports.fsAsyncMethods = fsAsyncMethods;
  }
});

// ../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/memfs@3.4.12/node_modules/memfs/lib/index.js"(exports, module2) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s2 = arguments[i2];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t3[p3] = s2[p3];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = exports.createFsFromVolume = exports.vol = exports.Volume = void 0;
    var Stats_1 = require_Stats();
    var Dirent_1 = require_Dirent();
    var volume_1 = require_volume();
    var _a = require_lists();
    var fsSyncMethods = _a.fsSyncMethods;
    var fsAsyncMethods = _a.fsAsyncMethods;
    var constants_1 = require_constants();
    var F_OK = constants_1.constants.F_OK;
    var R_OK = constants_1.constants.R_OK;
    var W_OK = constants_1.constants.W_OK;
    var X_OK = constants_1.constants.X_OK;
    exports.Volume = volume_1.Volume;
    exports.vol = new volume_1.Volume();
    function createFsFromVolume(vol2) {
      var fs3 = { F_OK, R_OK, W_OK, X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
      for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol2[method] === "function")
          fs3[method] = vol2[method].bind(vol2);
      }
      for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
        var method = fsAsyncMethods_1[_a2];
        if (typeof vol2[method] === "function")
          fs3[method] = vol2[method].bind(vol2);
      }
      fs3.StatWatcher = vol2.StatWatcher;
      fs3.FSWatcher = vol2.FSWatcher;
      fs3.WriteStream = vol2.WriteStream;
      fs3.ReadStream = vol2.ReadStream;
      fs3.promises = vol2.promises;
      fs3._toUnixTimestamp = volume_1.toUnixTimestamp;
      return fs3;
    }
    exports.createFsFromVolume = createFsFromVolume;
    exports.fs = createFsFromVolume(exports.vol);
    module2.exports = __assign(__assign({}, module2.exports), exports.fs);
    module2.exports.semantic = true;
  }
});

// ../../node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "../../node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop2() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function typeIsObject(x3) {
        return typeof x3 === "object" && x3 !== null || typeof x3 === "function";
      }
      const rethrowAssertionErrorRejection = noop2;
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseResolve = Promise.resolve.bind(originalPromise);
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      const queueMicrotask = (() => {
        const globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        const resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F3, V2, args) {
        if (typeof F3 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F3, V2, args);
      }
      function promiseCall(F3, V2, args) {
        try {
          return promiseResolvedWith(reflectCall(F3, V2, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve2, reject) => {
          reader._closedPromise_resolve = resolve2;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      const PullSteps = SymbolPolyfill("[[PullSteps]]");
      const NumberIsFinite = Number.isFinite || function(x3) {
        return typeof x3 === "number" && isFinite(x3);
      };
      const MathTrunc = Math.trunc || function(v2) {
        return v2 < 0 ? Math.ceil(v2) : Math.floor(v2);
      };
      function isDictionary(x3) {
        return typeof x3 === "object" || typeof x3 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x3, context) {
        if (typeof x3 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject2(x3) {
        return typeof x3 === "object" && x3 !== null || typeof x3 === "function";
      }
      function assertObject(x3, context) {
        if (!isObject2(x3)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x3, position, context) {
        if (x3 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x3, field, context) {
        if (x3 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x3) {
        return x3 === 0 ? 0 : x3;
      }
      function integerPart(x3) {
        return censorNegativeZero(MathTrunc(x3));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x3 = Number(value);
        x3 = censorNegativeZero(x3);
        if (!NumberIsFinite(x3)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x3 = integerPart(x3);
        if (x3 < lowerBound || x3 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x3) || x3 === 0) {
          return 0;
        }
        return x3;
      }
      function assertReadableStream(x3, context) {
        if (!IsReadableStream(x3)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e3) => rejectPromise(e3)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_readRequests")) {
          return false;
        }
        return x3 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x3._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x3) {
        return x3 !== x3;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O2) {
        return O2;
      }
      function IsDetachedBuffer(O2) {
        return false;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function IsNonNegativeNumber(v2) {
        if (typeof v2 !== "number") {
          return false;
        }
        if (NumberIsNaN(v2)) {
          return false;
        }
        if (v2 < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O2) {
        const buffer = ArrayBufferSlice(O2.buffer, O2.byteOffset, O2.byteOffset + O2.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        error(e3 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e3);
        }
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            const entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_controlledReadableByteStream")) {
          return false;
        }
        return x3 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x3 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, (e3) => {
          ReadableByteStreamControllerError(controller, e3);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const elementSize = pullIntoDescriptor.elementSize;
        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        let elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        const ctor = view.constructor;
        const buffer = TransferArrayBuffer(view.buffer);
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e3);
            readIntoRequest._errorSteps(e3);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e3);
            throw e3;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const buffer = chunk.buffer;
        const byteOffset = chunk.byteOffset;
        const byteLength = chunk.byteLength;
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer))
            ;
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e3) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e3);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r3) => {
          ReadableByteStreamControllerError(controller, r3);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve2, reject) => {
            resolvePromise = resolve2;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e3) => rejectPromise(e3)
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_readIntoRequests")) {
          return false;
        }
        return x3 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init3, context) {
        assertDictionary(init3, context);
        const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
        const size = init3 === null || init3 === void 0 ? void 0 : init3.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x3, context) {
        if (!IsWritableStream(x3)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_writableStreamController")) {
          return false;
        }
        return x3 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve2, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve2,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve2, reject) => {
          const closeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve2, reject) => {
          const writeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_ownerWritableStream")) {
          return false;
        }
        return x3 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        error(e3 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e3);
        }
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_controlledWritableStream")) {
          return false;
        }
        return x3 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r3) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r3);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let writeAlgorithm = () => promiseResolvedWith(void 0);
        let closeAlgorithm = () => promiseResolvedWith(void 0);
        let abortAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve2, reject) => {
          writer._closedPromise_resolve = resolve2;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve2, reject) => {
          writer._readyPromise_resolve = resolve2;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve2, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = new DOMException$1("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve2(void 0);
            }
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        error(e3 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e3);
        }
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_controlledReadableStream")) {
          return false;
        }
        return x3 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, (e3) => {
          ReadableStreamDefaultControllerError(controller, e3);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e3) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e3);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r3) => {
          ReadableStreamDefaultControllerError(controller, r3);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve2) => {
          resolveCancelPromise = resolve2;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r3) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r3);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r3);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve2) => {
          resolveCancelPromise = resolve2;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r3) => {
            if (thisReader !== reader) {
              return;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r3);
            ReadableByteStreamControllerError(branch2._readableStreamController, r3);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e3) {
            return promiseRejectedWith(e3);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream2.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_readableStreamController")) {
          return false;
        }
        return x3 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e3) {
        stream._state = "errored";
        stream._storedError = e3;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e3);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._errorSteps(e3);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._errorSteps(e3);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init3, context) {
        assertDictionary(init3, context);
        const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x3 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x3 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve2) => {
            startPromise_resolve = resolve2;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_transformStreamController")) {
          return false;
        }
        return x3 instanceof TransformStream;
      }
      function TransformStreamError(stream, e3) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e3);
        TransformStreamErrorWritableAndUnblockWrite(stream, e3);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e3) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e3);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve2) => {
          stream._backpressureChangePromise_resolve = resolve2;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x3) {
        if (!typeIsObject(x3)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x3, "_controlledTransformStream")) {
          return false;
        }
        return x3 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        let flushAlgorithm = () => promiseResolvedWith(void 0);
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e3) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e3);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e3) {
        TransformStreamError(controller._controlledTransformStream, e3);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r3) => {
          TransformStreamError(controller._controlledTransformStream, r3);
          throw r3;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const readable = stream._readable;
        const controller = stream._transformStreamController;
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r3) => {
          TransformStreamError(stream, r3);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports2.CountQueuingStrategy = CountQueuingStrategy;
      exports2.ReadableByteStreamController = ReadableByteStreamController;
      exports2.ReadableStream = ReadableStream2;
      exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports2.TransformStream = TransformStream;
      exports2.TransformStreamDefaultController = TransformStreamDefaultController;
      exports2.WritableStream = WritableStream;
      exports2.WritableStreamDefaultController = WritableStreamDefaultController;
      exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error) {
          process2.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob4 } = require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b2 = part;
      while (position !== b2.size) {
        const chunk = b2.slice(position, Math.min(b2.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob3, fetch_blob_default;
var init_fetch_blob = __esm({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    fetch_blob_default = Blob3;
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/file.js
var _File, File3, file_default;
var init_file = __esm({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = class File2 extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File3 = _File;
    file_default = File3;
  }
});

// ../../node_modules/.pnpm/formdata-polyfill@4.0.10/node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F3, B = fetch_blob_default) {
  var b2 = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c2 = [], p3 = `--${b2}\r
Content-Disposition: form-data; name="`;
  F3.forEach((v2, n) => typeof v2 == "string" ? c2.push(p3 + e(n) + `"\r
\r
${v2.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c2.push(p3 + e(n) + `"; filename="${e(v2.name, 1)}"\r
Content-Type: ${v2.type || "application/octet-stream"}\r
\r
`, v2, "\r\n"));
  c2.push(`--${b2}--`);
  return new B(c2, { type: "multipart/form-data; boundary=" + b2 });
}
var t, i, h, r, m, f, e, x, FormData2;
var init_esm_min = __esm({
  "../../node_modules/.pnpm/formdata-polyfill@4.0.10/node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a2, b2, c2) => (a2 += "", /^(Blob|File)$/.test(b2 && b2[t]) ? [(c2 = c2 !== void 0 ? c2 + "" : b2[t] == "File" ? b2.name : "blob", a2), b2.name !== c2 || b2[t] == "blob" ? new file_default([b2], c2, b2) : b2] : [a2, b2 + ""]);
    e = (c2, f5) => (f5 ? c2 : c2.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a2, e3) => {
      if (a2.length < e3) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e3} arguments required, but only ${a2.length} present.`);
      }
    };
    FormData2 = class FormData3 {
      #d = [];
      constructor(...a2) {
        if (a2.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o2) {
        return o2 && typeof o2 === "object" && o2[t] === "FormData" && !m.some((m3) => typeof o2[m3] != "function");
      }
      append(...a2) {
        x("append", arguments, 2);
        this.#d.push(f(...a2));
      }
      delete(a2) {
        x("delete", arguments, 1);
        a2 += "";
        this.#d = this.#d.filter(([b2]) => b2 !== a2);
      }
      get(a2) {
        x("get", arguments, 1);
        a2 += "";
        for (var b2 = this.#d, l2 = b2.length, c2 = 0; c2 < l2; c2++)
          if (b2[c2][0] === a2)
            return b2[c2][1];
        return null;
      }
      getAll(a2, b2) {
        x("getAll", arguments, 1);
        b2 = [];
        a2 += "";
        this.#d.forEach((c2) => c2[0] === a2 && b2.push(c2[1]));
        return b2;
      }
      has(a2) {
        x("has", arguments, 1);
        a2 += "";
        return this.#d.some((b2) => b2[0] === a2);
      }
      forEach(a2, b2) {
        x("forEach", arguments, 1);
        for (var [c2, d3] of this)
          a2.call(b2, d3, c2, this);
      }
      set(...a2) {
        x("set", arguments, 2);
        var b2 = [], c2 = true;
        a2 = f(...a2);
        this.#d.forEach((d3) => {
          d3[0] === a2[0] ? c2 && (c2 = !b2.push(a2)) : b2.push(d3);
        });
        c2 && b2.push(a2);
        this.#d = b2;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a2] of this)
          yield a2;
      }
      *values() {
        for (var [, a2] of this)
          yield a2;
      }
    };
  }
});

// ../../node_modules/.pnpm/node-domexception@1.0.0/node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "../../node_modules/.pnpm/node-domexception@1.0.0/node_modules/node-domexception/index.js"(exports, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/from.js
var import_node_fs, import_node_domexception, stat2, BlobDataItem;
var init_from = __esm({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat: stat2 } = import_node_fs.promises);
    BlobDataItem = class {
      #path;
      #start;
      constructor(options) {
        this.#path = options.path;
        this.#start = options.start;
        this.size = options.size;
        this.lastModified = options.lastModified;
      }
      slice(start, end) {
        return new BlobDataItem({
          path: this.#path,
          lastModified: this.lastModified,
          size: end - start,
          start: this.#start + start
        });
      }
      async *stream() {
        const { mtimeMs } = await stat2(this.#path);
        if (mtimeMs > this.lastModified) {
          throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        }
        yield* (0, import_node_fs.createReadStream)(this.#path, {
          start: this.#start,
          end: this.#start + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m3 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m3) {
    return;
  }
  const match = m3[2] || m3[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m4, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m3 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m3) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m3[1] || m3[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData2();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m4 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m4) {
        entryName = m4[2] || m4[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c2) => c2 | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c2;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c2 = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c2 === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c2 !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c2 === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c2 === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c2 !== boundary[index + 2]) {
                index = -2;
              }
              if (c2 === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c2 === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c2 === HYPHEN) {
                break;
              }
              if (c2 === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c2);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c2 === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c2 === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c2 !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c2 !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c2 = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c2) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c2 === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c2 === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c2 === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c2 === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c2;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/@babel+parser@7.20.7/node_modules/@babel/parser/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/@babel+parser@7.20.7/node_modules/@babel/parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line,
        column,
        index
      } = position;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var ParseErrorCode = {
      SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
      SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
    };
    var reflect = (keys2, last = keys2.length - 1) => ({
      get() {
        return keys2.reduce((object, key) => object[key], this);
      },
      set(value) {
        keys2.reduce(
          (item, key, i2) => i2 === last ? item[key] = value : item[key],
          this
        );
      }
    });
    var instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
      value: descriptor,
      enumerable: false
    } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
      configurable: true
    }, descriptor)), Object.assign(new constructor(), properties));
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code: ParseErrorCode.SourceTypeModuleError
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code: ParseErrorCode.SourceTypeModuleError
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = ({
      type,
      prefix: prefix2
    }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: ({
        maxArgumentCount
      }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = {
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`,
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    };
    var _excluded$1 = ["toMessage"];
    var _excluded2$1 = ["message"];
    function toParseErrorConstructor(_ref) {
      let {
        toMessage
      } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
      return function constructor({
        loc,
        details
      }) {
        return instantiate(SyntaxError, Object.assign({}, properties, {
          loc
        }), {
          clone(overrides = {}) {
            const loc2 = overrides.loc || {};
            return constructor({
              loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
              details: Object.assign({}, this.details, overrides.details)
            });
          },
          details: {
            value: details,
            enumerable: false
          },
          message: {
            get() {
              return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
            },
            set(value) {
              Object.defineProperty(this, "message", {
                value
              });
            }
          },
          pos: {
            reflect: "loc.index",
            enumerable: true
          },
          missingPlugin: "missingPlugin" in details && {
            reflect: "details.missingPlugin",
            enumerable: true
          }
        });
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref2 = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: ParseErrorCode.SyntaxError,
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key) => defineProperty(object, key, {
      enumerable: false,
      value: object[key]
    });
    function toESTreeLocation(node) {
      node.loc.start && toUnenumerable(node.loc.start, "index");
      node.loc.end && toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.options.tokens) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (e3) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d3) => this.directiveToStmt(d3));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }
        classBody.body.push(method);
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(
          funcNode,
          isGenerator,
          isAsync,
          isConstructor,
          allowDirectSuper,
          type,
          inClassScope
        );
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        return this.finishNode(
          node,
          "MethodDefinition"
        );
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.kind === "get" || prop.kind === "set") {
          this.raise(Errors.PatternHasAccessor, {
            at: prop.key
          });
        } else if (prop.method) {
          this.raise(Errors.PatternHasMethod, {
            at: prop.key
          });
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          if (this.hasPlugin("importAssertions")) {
            var _node$arguments$;
            node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
          }
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(
                  node,
                  exportStartLoc
                );
              }
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isOptionalChain(node) {
        return node.type === "ChainExpression";
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.method || node.kind === "get" || node.kind === "set";
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types17 = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types17.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token = createToken(name, options);
      keywords$1.set(name, token);
      return token;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name, tokenTypeCounter);
      tokenLabels.push(name);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd"),
      placeholder: createToken("%%", {
        startsExpr: true
      })
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 130;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 130;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 134;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 127 && token <= 129;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 119 && token <= 121;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 122 && token <= 128;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types17.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types17.template) {
          context.pop();
        } else {
          context.push(types17.template);
        }
      };
      tokenTypes[140].updateContext = (context) => {
        context.push(types17.j_expr, types17.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i2 = 0, length = set.length; i2 < length; i2 += 2) {
        pos += set[i2];
        if (pos > code)
          return false;
        pos += set[i2 + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set([
      "break",
      "case",
      "catch",
      "continue",
      "debugger",
      "default",
      "do",
      "else",
      "finally",
      "for",
      "function",
      "if",
      "return",
      "switch",
      "throw",
      "try",
      "var",
      "const",
      "while",
      "with",
      "new",
      "this",
      "super",
      "class",
      "extends",
      "export",
      "import",
      "null",
      "true",
      "false",
      "in",
      "instanceof",
      "typeof",
      "void",
      "delete",
      "implements",
      "interface",
      "let",
      "package",
      "private",
      "protected",
      "public",
      "static",
      "yield",
      "eval",
      "arguments",
      "enum",
      "await"
    ]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var SCOPE_OTHER = 0;
    var SCOPE_PROGRAM = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_ARROW = 4;
    var SCOPE_SIMPLE_CATCH = 8;
    var SCOPE_SUPER = 16;
    var SCOPE_DIRECT_SUPER = 32;
    var SCOPE_CLASS = 64;
    var SCOPE_STATIC_BLOCK = 128;
    var SCOPE_TS_MODULE = 256;
    var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;
    var BIND_KIND_VALUE = 1;
    var BIND_KIND_TYPE = 2;
    var BIND_SCOPE_VAR = 4;
    var BIND_SCOPE_LEXICAL = 8;
    var BIND_SCOPE_FUNCTION = 16;
    var BIND_FLAGS_NONE = 64;
    var BIND_FLAGS_CLASS = 128;
    var BIND_FLAGS_TS_ENUM = 256;
    var BIND_FLAGS_TS_CONST_ENUM = 512;
    var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
    var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
    var BIND_FLAGS_TS_IMPORT = 4096;
    var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
    var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
    var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
    var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
    var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
    var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
    var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
    var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
    var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
    var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
    var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT;
    var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
    var CLASS_ELEMENT_FLAG_STATIC = 4;
    var CLASS_ELEMENT_KIND_GETTER = 2;
    var CLASS_ELEMENT_KIND_SETTER = 1;
    var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
    var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
    var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
    var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_OTHER = 0;
    var Scope = class {
      constructor(flags) {
        this.var = /* @__PURE__ */ new Set();
        this.lexical = /* @__PURE__ */ new Set();
        this.functions = /* @__PURE__ */ new Set();
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & SCOPE_PROGRAM) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
      }
      get inStaticBlock() {
        for (let i2 = this.scopeStack.length - 1; ; i2--) {
          const {
            flags
          } = this.scopeStack[i2];
          if (flags & SCOPE_STATIC_BLOCK) {
            return true;
          }
          if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          if (bindingType & BIND_SCOPE_FUNCTION) {
            scope.functions.add(name);
          } else {
            scope.lexical.add(name);
          }
          if (bindingType & BIND_SCOPE_LEXICAL) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & BIND_SCOPE_VAR) {
          for (let i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            scope = this.scopeStack[i2];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.var.add(name);
            this.maybeExportDefined(scope, name);
            if (scope.flags & SCOPE_VAR)
              break;
          }
        }
        if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, {
            at: loc,
            identifierName: name
          });
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & BIND_KIND_VALUE))
          return false;
        if (bindingType & BIND_SCOPE_LEXICAL) {
          return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
        }
        if (bindingType & BIND_SCOPE_FUNCTION) {
          return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
        }
        return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
          this.undefinedExports.set(name, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i2 = this.scopeStack.length - 1; ; i2--) {
          const {
            flags
          } = this.scopeStack[i2];
          if (flags & SCOPE_VAR) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i2 = this.scopeStack.length - 1; ; i2--) {
          const {
            flags
          } = this.scopeStack[i2];
          if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType))
          return true;
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
          return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin2, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin2)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i2 = elements.length;
      while (lastElement === null && i2 > 0) {
        lastElement = elements[--i2];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename)
          comment.loc.filename = this.filename;
        this.state.comments.push(comment);
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i2 = commentStackLength - 1;
        const lastCommentWS = commentStack[i2];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i2--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i2 >= 0; i2--) {
          const commentWS = commentStack[i2];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i2, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(commentStart - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i2 = commentStack.length - 1; i2 >= 0; i2--) {
          this.finalizeComment(commentStack[i2]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i2 = commentStackLength - 1;
        for (; i2 >= 0; i2--) {
          const commentWS = commentStack[i2];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var lineBreak = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
    var skipWhiteSpaceToLineBreak = new RegExp(
      "(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
      "y"
    );
    function isWhitespace(code) {
      switch (code) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State = class {
      constructor() {
        this.strict = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.maybeInArrowParameters = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.hasFlowComment = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inDisallowConditionalTypesContext = false;
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.comments = [];
        this.commentStack = [];
        this.pos = 0;
        this.type = 137;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.context = [types17.brace];
        this.canStartJSXElement = true;
        this.containsEsc = false;
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      init({
        strictMode,
        sourceType,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos);
      }
      clone(skipArrays) {
        const state = new State();
        const keys2 = Object.keys(this);
        for (let i2 = 0, length = keys2.length; i2 < length; i2++) {
          const key = keys2[i2];
          let val = this[key];
          if (!skipArrays && Array.isArray(val)) {
            val = val.slice();
          }
          state[key] = val;
        }
        return state;
      }
    };
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          ({
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i2 = 0, e3 = len == null ? Infinity : len; i2 < e3; ++i2) {
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code;
      if (ch === 123) {
        ++pos;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code,
        pos
      };
    }
    var _excluded = ["at"];
    var _excluded2 = ["at"];
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!this.options.errorRecovery)
              return false;
            this.raise(Errors.InvalidDigit, {
              at: buildPosition(pos, lineStart, curLine),
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, {
              at: buildPosition(pos, lineStart, curLine)
            });
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, {
              at: buildPosition(pos - 1, lineStart, curLine)
            });
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, {
              at: buildPosition(pos, lineStart, curLine)
            });
          }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
            at
          }));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead)
          this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(137);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition()
          });
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead)
          return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start,
          end: end + commentEnd.length,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead)
          return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start,
          end,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop:
          while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const comment = this.skipBlockComment("*/");
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  case 47: {
                    const comment = this.skipLineComment(2);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  default:
                    break loop;
                }
                break;
              default:
                if (isWhitespace(ch)) {
                  ++this.state.pos;
                } else if (ch === 45 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                    const comment = this.skipLineComment(3);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else if (ch === 60 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                    const comment = this.skipLineComment(4);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else {
                  break loop;
                }
            }
          }
        if (comments.length > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: spaceStart,
            end,
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, {
            at: this.state.curPosition()
          });
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(136, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(136, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
          return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33)
          return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code) {
        let type = code === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            throw this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code) {
        switch (code) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code)) {
              this.readWord(code);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: String.fromCodePoint(code)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              this.expectPlugin("regexpUnicodeSets", nextPos());
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, {
                  at: nextPos()
                });
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, {
                  at: nextPos()
                });
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, {
                at: nextPos()
              });
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, {
              at: nextPos()
            });
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(135, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
      }
      readRadixNumber(radix) {
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, {
            at: createPositionWithColumnOffset(startLoc, 2),
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, {
            at: startLoc
          });
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
          });
        }
        if (isBigInt) {
          const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(133, str);
          return;
        }
        this.finishToken(132, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, {
            at: this.state.curPosition()
          });
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
            at: startLoc
          });
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, {
                at: createPositionWithColumnOffset(startLoc, underscorePos)
              });
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, {
              at: startLoc
            });
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, {
              at: startLoc
            });
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          ++this.state.pos;
          isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
          });
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(133, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(134, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(132, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(
          quote === 34 ? "double" : "single",
          this.input,
          this.state.pos + 1,
          this.state.lineStart,
          this.state.curLine,
          this.errorHandlers_readStringContents_string
        );
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(131, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents(
          "template",
          this.input,
          this.state.pos + 1,
          this.state.lineStart,
          this.state.curLine,
          this.errorHandlers_readStringContents_template
        );
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, {
        at
      }) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, {
            at
          });
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, {
                at: this.state.curPosition()
              });
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, {
                  at: escStart
                });
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(130, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, {
            at: this.state.startLoc,
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, raiseProperties) {
        const {
          at
        } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError({
          loc,
          details
        });
        if (!this.options.errorRecovery)
          throw error;
        if (!this.isLookahead)
          this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, raiseProperties) {
        const {
          at
        } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i2 = errors.length - 1; i2 >= 0; i2--) {
          const error = errors[i2];
          if (error.loc.index === pos) {
            return errors[i2] = toParseError({
              loc,
              details
            });
          }
          if (error.loc.index < pos)
            break;
        }
        return this.raise(toParseError, raiseProperties);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, {
          expected: type ? tokenLabelName(type) : null,
          at: loc != null ? loc : this.state.startLoc
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, {
          at: loc != null ? loc : this.state.startLoc,
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
          throw this.raise(Errors.MissingOneOfPlugins, {
            at: this.state.startLoc,
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, {
            at: buildPosition(pos, lineStart, curLine)
          });
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name
            });
          }
        }
      }
      declarePrivateName(name, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
          const accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
            const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
            const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
            const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined)
              loneAccessors.delete(name);
          } else if (!redefined) {
            loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, {
            at: loc,
            identifierName: name
          });
        }
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name))
            return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name
          });
        }
      }
    };
    var kExpression = 0;
    var kMaybeArrowParameterDeclaration = 1;
    var kMaybeAsyncArrowParameterDeclaration = 2;
    var kParameterDeclaration = 3;
    var ExpressionScope = class {
      constructor(type = kExpression) {
        this.type = void 0;
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
      }
      isCertainlyParameterDeclaration() {
        return this.type === kParameterDeclaration;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, {
        at
      }) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, {
        at: node
      }) {
        const origin = {
          at: node.loc.start
        };
        const {
          stack
        } = this;
        let i2 = stack.length - 1;
        let scope = stack[i2];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i2];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, {
        at: node
      }) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = {
          at: node.loc.start
        };
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError({
        at
      }) {
        const {
          stack
        } = this;
        let i2 = stack.length - 1;
        let scope = stack[i2];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
              at
            });
          }
          scope = stack[--i2];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration())
          return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, {
            at: loc
          });
          let i2 = stack.length - 2;
          let scope = stack[i2];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i2];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(kParameterDeclaration);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var PARAM = 0;
    var PARAM_YIELD = 1;
    var PARAM_AWAIT = 2;
    var PARAM_RETURN = 4;
    var PARAM_IN = 8;
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & PARAM_IN) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node)
          return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, {
              at: this.state.startLoc
            });
          }
          throw this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13))
          return;
        this.raise(Errors.MissingSemicolon, {
          at: this.state.lastTokEndLoc
        });
      }
      expect(type, loc) {
        this.eat(type) || this.unexpected(loc, type);
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
          return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
          });
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, {
            at: doubleProtoLoc
          });
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, {
            at: privateKeyLoc
          });
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isOptionalChain(node) {
        return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = PARAM;
        if (this.inModule) {
          paramFlags |= PARAM_AWAIT;
        }
        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser != null && parser.options.ranges)
          this.range = [pos, 0];
        if (parser != null && parser.filename)
          this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node(void 0, this.start, this.loc.start);
        const keys2 = Object.keys(this);
        for (let i2 = 0, length = keys2.length; i2 < length; i2++) {
          const key = keys2[i2];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node.raw !== void 0) {
        cloned.raw = node.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        return new Node(this, this.state.start, this.state.startLoc);
      }
      startNodeAt(loc) {
        return new Node(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = endLoc.index;
        if (this.options.attachComment)
          this.processComment(node);
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.options.ranges)
          node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitailized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    function isMaybeDefaultImport(type) {
      return tokenIsKeywordOrIdentifier(type) && type !== 97;
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i2 = 0; i2 < list.length; i2++) {
        (test(list[i2], i2, list) ? list1 : list2).push(list[i2]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        if (type !== 131 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        return super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches)
            ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        return super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(108);
        if (this.state.lastTokStart > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
            at: moduloLoc
          });
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(125)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, {
                at: this.state.lastTokStartLoc
              });
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(128)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(127)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(SCOPE_OTHER);
        if (this.match(131)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(128) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                at: this.state.lastTokStartLoc
              });
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                at: bodyElement
              });
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                at: bodyElement
              });
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                at: bodyElement
              });
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
              at: this.state.startLoc,
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        throw this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(109);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass = false) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        node.implements = [];
        node.mixins = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (this.isContextual(115)) {
          this.next();
          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        if (this.isContextual(111)) {
          this.next();
          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, {
            at: this.state.startLoc
          });
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word))
          return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
          at: startLoc,
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(128);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, {
              at: nodeStartLoc
            });
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(140)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.match(48)) {
          node.params.push(this.flowParseType());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(127);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(116)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(104)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(98) || this.isContextual(103)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
              at: inexactStartLoc
            });
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, {
                at: this.state.lastTokStartLoc
              });
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, {
                at: this.state.lastTokStartLoc
              });
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, {
                at: variance
              });
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, {
              at: this.state.lastTokStartLoc
            });
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, {
              at: variance
            });
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: node.value.this
              });
            }
          } else {
            if (kind !== "init")
              this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
            at: property.value.this
          });
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
            at: property
          });
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, {
            at: property
          });
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        var _startLoc;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3))
            break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, {
              at: node
            });
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: node
              });
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47:
            node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          case 10:
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          case 131:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(132)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(133)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected();
          case 132:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 133:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(127)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        throw this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(
                node,
                "OptionalIndexedAccessType"
              );
            } else {
              type = this.finishNode(
                node,
                "IndexedAccessType"
              );
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 130 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
        }
        return super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [
            typeNode.typeAnnotation,
            node.predicate
          ] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(127)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual(124)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(124)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17))
          return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i2 = 0; i2 < invalid.length; i2++) {
              noArrowAt.push(invalid[i2].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, {
              at: state.startLoc
            });
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(
          node.params,
          (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc,
          false
        );
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse13) {
        let result;
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse13();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse13();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        node = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return node;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExport(node, decorators) {
        const decl = super.parseExport(node, decorators);
        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }
        return decl;
      }
      parseExportDeclaration(node) {
        if (this.isContextual(128)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(127)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual(124)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node))
          return true;
        if (this.isContextual(128) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(123)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, {
              at: startLoc
            });
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, {
              at: member.value
            });
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, {
            at: this.state.curPosition(),
            identifierName: fullWord
          });
        }
        this.finishToken(130, fullWord);
      }
      getTokenFromCode(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 123 && next === 124) {
          return this.finishOp(6, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(code === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code === 63) {
          if (next === 46) {
            return this.finishOp(18, 2);
          }
          return this.finishOp(17, 1);
        } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          return this.readIterator();
        } else {
          return super.getTokenFromCode(code);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i2 = 0; i2 < exprList.length; i2++) {
          const expr = exprList[i2];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i2] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i2 = 0; i2 < exprList.length; i2++) {
          var _expr$extra;
          const expr = exprList[i2];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, {
              at: expr.typeAnnotation
            });
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              at: method
            });
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              at: method
            });
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && this.match(47)) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual(111)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, {
              at: param
            });
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, {
              at: param
            });
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10))
            this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, {
              at: param
            });
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              at: param
            });
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, {
            at: param
          });
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, {
            at: param
          });
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, {
            at: node.typeAnnotation
          });
        }
        return node;
      }
      shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return super.shouldParseDefaultImport(node);
        }
        return isMaybeDefaultImport(this.state.type);
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, {
            at: node.specifiers[0].loc.start
          });
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        let kind = null;
        if (this.match(87)) {
          kind = "typeof";
        } else if (this.isContextual(128)) {
          kind = "type";
        }
        if (kind) {
          const lh = this.lookahead();
          const {
            type
          } = lh;
          if (kind === "type" && type === 55) {
            this.unexpected(null, lh.type);
          }
          if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
            this.next();
            node.importKind = kind;
          }
        }
        return super.maybeParseDefaultImportSpecifier(node);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
            at: specifier
          });
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, allowModifiers) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types17.j_oTag || currentContext === types17.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
              abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression")
              abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                  at: typeParameters
                });
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
            at: typeParameters
          });
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [
              typeNode.typeAnnotation,
              node.predicate
            ] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon())
              this.unexpected();
            if (!this.match(19))
              this.unexpected();
            return typeNode;
          });
          if (result.thrown)
            return null;
          if (result.error)
            this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }
        for (let i2 = 0; i2 < node.params.length; i2++) {
          if (this.isThisParam(node.params[i2]) && i2 > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, {
              at: node.params[i2]
            });
          }
        }
        return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments(11, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted)
            return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error)
            return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments(11, false);
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node))
          return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code);
      }
      parseTopLevel(file, program3) {
        const fileNode = super.parseTopLevel(file, program3);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, {
            at: this.state.curPosition()
          });
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, {
              at: this.state.startLoc
            });
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(
          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)
        )) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition()
          });
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
          at: loc,
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
          at: loc
        }, enumContext));
      }
      flowEnumErrorNumberMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
          at: loc,
          enumName,
          memberName
        });
      }
      flowEnumErrorStringMemberInconsistentlyInitailized(node, {
        enumName
      }) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
          at: node,
          enumName
        });
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 132: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 131: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init3 = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init: init3
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init: init3
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, {
              at: id,
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, {
              at: id,
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init3.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init3.loc, context, "boolean");
              memberNode.init = init3.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init3.loc, context, "number");
              memberNode.init = init3.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init3.loc, context, "string");
              memberNode.init = init3.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init3.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init3.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init3.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(101))
          return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
            at: this.state.startLoc,
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, {
            at: this.state.startLoc,
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, {
                at: nameLoc,
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  return this.finishToken(140);
                }
                return super.getTokenFromCode(ch);
              }
              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(139, out);
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(131, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        return this.finishToken(138, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(138)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(14))
          return name;
        const node = this.startNodeAt(startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types17.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types17.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, {
                at: node
              });
            }
            return node;
          case 140:
          case 131:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, {
              at: this.state.startLoc
            });
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types17.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types17.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types17.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(141)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(141)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(141);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(141)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(141);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents:
            for (; ; ) {
              switch (this.state.type) {
                case 140:
                  startLoc = this.state.startLoc;
                  this.next();
                  if (this.eat(56)) {
                    closingElement = this.jsxParseClosingElementAt(startLoc);
                    break contents;
                  }
                  children.push(this.jsxParseElementAt(startLoc));
                  break;
                case 139:
                  children.push(this.parseExprAtom());
                  break;
                case 5: {
                  const node2 = this.startNode();
                  this.setContext(types17.brace);
                  this.next();
                  if (this.match(21)) {
                    children.push(this.jsxParseSpreadChild(node2));
                  } else {
                    children.push(this.jsxParseExpressionContainer(node2, types17.j_expr));
                  }
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, {
              at: closingElement
            });
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, {
              at: closingElement,
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
            at: this.state.startLoc
          });
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(139)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(140)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(140);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace)
          super.skipSpace();
      }
      getTokenFromCode(code) {
        const context = this.curContext();
        if (context === types17.j_expr) {
          return this.jsxReadToken();
        }
        if (context === types17.j_oTag || context === types17.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }
          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(141);
          }
          if ((code === 34 || code === 39) && context === types17.j_oTag) {
            return this.jsxReadString(code);
          }
        }
        if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(140);
        }
        return super.getTokenFromCode(code);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 140) {
          context.splice(-2, 2, types17.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 140) {
          context.push(types17.j_oTag);
        } else if (type === 141) {
          const out = context[context.length - 1];
          if (out === types17.j_oTag && prevType === 56 || out === types17.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types17.j_expr;
          } else {
            this.setContext(types17.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.types = /* @__PURE__ */ new Set();
        this.enums = /* @__PURE__ */ new Set();
        this.constEnums = /* @__PURE__ */ new Set();
        this.classes = /* @__PURE__ */ new Set();
        this.exportOnlyBindings = /* @__PURE__ */ new Set();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags == SCOPE_TS_MODULE) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags == SCOPE_TS_MODULE) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i2 = 0; i2 < len - 1; i2++) {
            if (this.importsStack[i2].has(name))
              return true;
          }
        }
        return false;
      }
      declareName(name, bindingType, loc) {
        if (bindingType & BIND_FLAGS_TS_IMPORT) {
          if (this.hasImport(name, true)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name);
          return;
        }
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
        if (bindingType & BIND_KIND_TYPE) {
          if (!(bindingType & BIND_KIND_VALUE)) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
          }
          scope.types.add(name);
        }
        if (bindingType & BIND_FLAGS_TS_ENUM)
          scope.enums.add(name);
        if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
          scope.constEnums.add(name);
        if (bindingType & BIND_FLAGS_CLASS)
          scope.classes.add(name);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (scope.enums.has(name)) {
          if (bindingType & BIND_FLAGS_TS_ENUM) {
            const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
            const wasConst = scope.constEnums.has(name);
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
          if (scope.lexical.has(name)) {
            return !!(bindingType & BIND_KIND_VALUE);
          } else {
            return false;
          }
        }
        if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name, bindingType);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        if (this.hasImport(name))
          return;
        const len = this.scopeStack.length;
        for (let i2 = len - 1; i2 >= 0; i2--) {
          const scope = this.scopeStack[i2];
          if (scope.types.has(name) || scope.exportOnlyBindings.has(name))
            return;
        }
        super.checkLocalExport(id);
      }
    };
    var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
    function nonNull(x3) {
      if (x3 == null) {
        throw new Error(`Unexpected ${x3} value.`);
      }
      return x3;
    }
    function assert(x3) {
      if (!x3) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.indexOf(modifier) !== -1) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        modified,
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, {
              at: loc,
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, {
              at: loc,
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier)
            break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, {
                at: startLoc,
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, {
                at: startLoc,
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, {
                at: startLoc,
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, {
              at: startLoc,
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
        throw new Error("Unreachable");
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(131)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, {
            at: this.state.startLoc
          });
        }
        node.argument = super.parseExprAtom();
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdentifier(allowReservedWords);
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseInOutModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      tsParseNoneModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: [],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
      }
      tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(140)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList(
          "TypeParametersOrArguments",
          this.tsParseTypeParameter.bind(this, parseModifiers),
          false,
          true,
          refTrailingCommaPos
        );
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, {
            at: node
          });
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        return super.parseBindingList(11, 41).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, {
              at: pattern,
              type: pattern.type
            });
          }
          return pattern;
        });
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17))
          node.optional = true;
        const nodeAny = node;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, {
              at: node
            });
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
              at: this.state.curPosition()
            });
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, {
                at: this.state.curPosition()
              });
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                  at: this.state.curPosition()
                });
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, {
                at: this.state.curPosition()
              });
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                  at: this.state.curPosition()
                });
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                  at: this.state.curPosition()
                });
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                  at: this.state.curPosition()
                });
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                at: method[returnTypeKey]
              });
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly)
            property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        });
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(120);
        }
        if (this.isContextual(120)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(58);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(120);
        } else if (this.eatContextual(120)) {
          node.readonly = true;
        }
        this.expect(0);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        let labeledElements = null;
        node.elementTypes.forEach((elementNode) => {
          var _labeledElements;
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, {
              at: elementNode
            });
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
          let checkType = type;
          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
            checkType = elementNode.type;
          }
          const isLabeled = checkType === "TSNamedTupleMember";
          (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
          if (labeledElements !== isLabeled) {
            this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
              at: elementNode
            });
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const {
          startLoc
        } = this.state;
        const rest = this.eat(21);
        let type = this.tsParseType();
        const optional = this.eat(17);
        const labeled = this.eat(14);
        if (labeled) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(TSErrors.InvalidTupleMemberLabel, {
              at: type
            });
            labeledNode.label = type;
          }
          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract)
            this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.state.type) {
            case 132:
            case 133:
            case 131:
            case 85:
            case 86:
              return super.parseExprAtom();
            default:
              throw this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = super.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType)
          return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 131:
          case 132:
          case 133:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 132 && nextToken.type !== 133) {
                throw this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        throw this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(
            node
          );
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, {
              at: node
            });
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(113);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types18 = [];
        do {
          types18.push(parseConstituentType());
        } while (this.eat(operator));
        if (types18.length === 1 && !hasLeadingOperator) {
          return types18[0];
        }
        node.types = types18;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, true);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t3 = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t3.typeAnnotation = thisTypePredicate;
            return this.finishNode(t3, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t3);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t3.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t3, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t3.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t3, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
      }
      tsTryParseTypeAnnotation() {
        return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 107) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, {
            at: this.state.lastTokStartLoc,
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t3 = this.startNode()) {
        this.tsInType(() => {
          if (eatColon)
            this.expect(14);
          t3.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t3, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(122) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, {
            at: this.state.startLoc
          });
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, {
            at: originalStartLoc,
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak())
          return null;
        this.expectContextual(127);
        if (properties.declare)
          node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, {
            at: this.state.startLoc
          });
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, BIND_TS_TYPE);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          this.expect(29);
          if (this.isContextual(112) && this.lookahead().type !== 16) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const)
          node.const = true;
        if (properties.declare)
          node.declare = true;
        this.expectContextual(124);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(110)) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(131)) {
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, {
            at: moduleReference
          });
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(117) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(117);
        this.expect(10);
        if (!this.match(131)) {
          throw this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f5) {
        const state = this.state.clone();
        const res = f5();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f5) {
        const result = this.tryParse((abort) => f5() || abort());
        if (result.aborted || !result.node)
          return void 0;
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      tsTryParse(f5) {
        const state = this.state.clone();
        const result = f5();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.state = state;
          return void 0;
        }
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.state.type;
        let kind;
        if (this.isContextual(99)) {
          starttype = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          if (starttype === 68) {
            nany.declare = true;
            return super.parseFunctionStatement(nany, false, false);
          }
          if (starttype === 80) {
            nany.declare = true;
            return this.parseClass(nany, true, false);
          }
          if (starttype === 124) {
            return this.tsParseEnumDeclaration(nany, {
              declare: true
            });
          }
          if (starttype === 110) {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          }
          if (starttype === 75 || starttype === 74) {
            if (!this.match(75) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.state.value, true);
            }
            this.expect(75);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          }
          if (starttype === 127) {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result)
              return result;
          }
          if (tokenIsIdentifier(starttype)) {
            return this.tsParseDeclaration(nany, this.state.value, true, null);
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
              return declaration;
            }
            break;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(131)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak())
            return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters();
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) {
          return void 0;
        }
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) {
          return void 0;
        }
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInNoContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, {
            at: node
          });
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
          return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const startLoc = this.state.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers({
            modified,
            allowedModifiers: ["public", "private", "protected", "override", "readonly"]
          });
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(TSErrors.UnexpectedParameterModifier, {
              at: startLoc
            });
          }
        }
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility)
            pp.accessibility = accessibility;
          if (readonly)
            pp.readonly = readonly;
          if (override)
            pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, {
              at: pp
            });
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, {
            at: node
          });
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, BIND_TS_AMBIENT);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, {
              at: node.typeAnnotation
            });
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments)
              return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              result2.typeParameters = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(11, false);
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeParameters = typeArguments;
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            node.typeParameters = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                at: this.state.startLoc
              });
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          node.typeParameters = callee.typeParameters;
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, {
                  at: this.state.startLoc,
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(
            node,
            leftStartLoc,
            minPrec
          );
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, {
            at: node.specifiers[0].loc.start
          });
        }
      }
      checkDuplicateExports() {
      }
      parseImport(node) {
        node.importKind = "value";
        if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
          let ahead = this.lookahead();
          if (this.isContextual(128) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
            node.importKind = "type";
            this.next();
            ahead = this.lookahead();
          }
          if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
            return this.tsParseImportEqualsDeclaration(node);
          }
        }
        const importNode = super.parseImport(node);
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
            at: importNode
          });
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          this.next();
          if (this.isContextual(128) && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.next();
          } else {
            node.importKind = "value";
          }
          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(126);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.isContextual(128) && this.lookahead().type === 5) {
            this.next();
            node.exportKind = "type";
          } else {
            node.exportKind = "value";
          }
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(122) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(127)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result)
            return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext)
          return declaration;
        for (const {
          id,
          init: init3
        } of declaration.declarations) {
          if (!init3)
            continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
              at: init3
            });
          } else if (init3.type !== "StringLiteral" && init3.type !== "BooleanLiteral" && init3.type !== "NumericLiteral" && init3.type !== "BigIntLiteral" && (init3.type !== "TemplateLiteral" || init3.expressions.length > 0) && !isPossiblyLiteralEnum(init3)) {
            this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
              at: init3
            });
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            const: true
          });
        }
        if (this.isContextual(124)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(127)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result)
            return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(104) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          modified: member,
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                at: this.state.curPosition()
              });
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, {
              at: member
            });
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, {
              at: member,
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, {
              at: member
            });
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, {
              at: member
            });
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
            at: member
          });
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, {
              at: member
            });
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional)
          methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, {
            at: methodOrProp
          });
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, {
            at: methodOrProp
          });
        }
      }
      parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
          return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      parseParenItem(node, startLoc) {
        node = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(123)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(123);
        if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
            at: this.state.startLoc
          });
        }
        const isIdentifier2 = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier2 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration)
          return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(111)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (typeParameters)
          node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, {
            at: this.state.startLoc
          });
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, {
            at: this.state.startLoc,
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, {
            at: node
          });
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, {
            at: node,
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, {
            at: node
          });
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, {
            at: typeParameters
          });
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, {
            at: method,
            kind
          });
        }
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod")
          return;
        if (node.type === "MethodDefinition" && !node.value.body)
          return;
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual(111)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, allowModifiers) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          node.typeParameters = typeParameters;
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types17.j_oTag || currentContext === types17.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state)
          state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters();
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error)
            return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown)
          throw jsx2.error;
        if (arrow.thrown)
          throw arrow.error;
        if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
          throw typeCast.error;
        throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra;
        if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, {
            at: node
          });
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors, sawUnary);
        }
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19))
              abort();
            return returnType;
          });
          if (result.aborted)
            return;
          if (!result.thrown) {
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
            this.raise(TSErrors.PatternIsOptional, {
              at: param
            });
          }
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                at: node
              });
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                at: node
              });
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn$1({
          TSTypeCastExpression: true,
          TSParameterProperty: "parameter",
          TSNonNullExpression: "expression",
          TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
          TSSatisfiesExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
          TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
        }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        } else {
          return super.checkCommaAfterRest(close);
        }
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, {
            at: node.typeAnnotation
          });
        }
        return node;
      }
      getTokenFromCode(code) {
        if (this.state.inType) {
          if (code === 62) {
            return this.finishOp(48, 1);
          }
          if (code === 60) {
            return this.finishOp(47, 1);
          }
        }
        return super.getTokenFromCode(code);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i2 = 0; i2 < exprList.length; i2++) {
          const expr = exprList[i2];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i2] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments)
            node.typeParameters = typeArguments;
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.state.isAmbientContext;
        this.state.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
        }
      }
      parseClass(node, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(127)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
              at: node
            });
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
          if (hasBody) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, {
              at: method,
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
            at: loc
          });
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression")
        return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier")
        return true;
      if (expression.type !== "MemberExpression")
        return false;
      if (expression.computed)
        return false;
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(142)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(142);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        const isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      }
      getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(142, 2);
        }
        return super.getTokenFromCode(code);
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 142) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder")
          return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrFunctionDeclaration(false);
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(142) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
              at: this.state.startLoc
            });
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseExport(node, decorators);
        if (!this.isContextual(97) && !this.match(12)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter(
            (node2) => node2.exported.type === "Placeholder"
          );
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(97) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport)
            this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(97);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.state.lastTokEndLoc.index) {
          this.raise(PlaceholderErrors.UnexpectedSpace, {
            at: this.state.lastTokEndLoc
          });
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name = this.parseIdentifierName();
            const identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    function hasPlugin(plugins, expectedConfig) {
      const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
      const expectedKeys = Object.keys(expectedOptions);
      const expectedOptionsIsEmpty = expectedKeys.length === 0;
      return plugins.some((p3) => {
        if (typeof p3 === "string") {
          return expectedOptionsIsEmpty && p3 === expectedName;
        } else {
          const [pluginName, pluginOptions] = p3;
          if (pluginName !== expectedName) {
            return false;
          }
          for (const key of expectedKeys) {
            if (pluginOptions[key] !== expectedOptions[key]) {
              return false;
            }
          }
          return true;
        }
      });
    }
    function getPluginOption(plugins, name, option) {
      const plugin2 = plugins.find((plugin3) => {
        if (Array.isArray(plugin3)) {
          return plugin3[0] === name;
        } else {
          return plugin3 === name;
        }
      });
      if (plugin2 && Array.isArray(plugin2) && plugin2.length > 1) {
        return plugin2[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
    function validatePlugins2(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
        }
        const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p3) => `"${p3}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
          syntaxType: "hash"
        }]);
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t3) => `"${t3}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          if (hasPlugin(plugins, "importAssertions")) {
            throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
        throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p3) => `'${p3}'`).join(", "));
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions = {
      sourceType: "script",
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true
    };
    function getOptions(opts) {
      const options = {};
      for (const key of Object.keys(defaultOptions)) {
        options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
      }
      return options;
    }
    var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            } else if (parenthesized.type !== "MemberExpression") {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, {
              at: node
            });
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i2 = 0, length = node.properties.length, last = length - 1; i2 < length; i2++) {
              var _node$extra2;
              const prop = node.properties[i2];
              const isLast = i2 === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: node.extra.trailingCommaLoc
                });
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, {
                at: node.left.loc.end
              });
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
            at: prop.key
          });
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, {
              at: prop
            });
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i2 = 0; i2 <= end; i2++) {
          const elt = exprList[i2];
          if (!elt)
            continue;
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
          } else {
            this.toAssignable(elt, isLHS);
          }
          if (elt.type === "RestElement") {
            if (i2 < end) {
              this.raise(Errors.RestTrailingComma, {
                at: elt
              });
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, {
                at: trailingCommaLoc
              });
            }
          }
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i2) => {
              return prop.type !== "ObjectMethod" && (i2 === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(allowModifiers, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const prop = this.startNode();
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(prop);
        } else if (type === 136) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseAssignableListItemTypes(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29))
          return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn(
          {
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          },
          type
        );
      }
      checkLVal(expression, {
        in: ancestor,
        binding = BIND_NONE,
        checkClashes = false,
        strictModeChanged = false,
        allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),
        hasParenthesizedAncestor = false
      }) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression))
          return;
        if (type === "MemberExpression") {
          if (binding !== BIND_NONE) {
            this.raise(Errors.InvalidPropertyBindingPattern, {
              at: expression
            });
          }
          return;
        }
        if (expression.type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);
          const {
            name
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(Errors.ParamDupe, {
                at: expression
              });
            } else {
              checkClashes.add(name);
            }
          }
          return;
        }
        const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true)
          return;
        if (validity === false) {
          const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, {
            at: expression,
            ancestor: ancestor.type === "UpdateExpression" ? {
              type: "UpdateExpression",
              prefix: ancestor.prefix
            } : {
              type: ancestor.type
            }
          });
          return;
        }
        const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
        const nextAncestor = expression.type === "ArrayPattern" || expression.type === "ObjectPattern" || expression.type === "ParenthesizedExpression" ? expression : ancestor;
        for (const child of [].concat(expression[key])) {
          if (child) {
            this.checkLVal(child, {
              in: nextAncestor,
              binding,
              checkClashes,
              allowingSloppyLetBinding,
              strictModeChanged,
              hasParenthesizedAncestor: isParenthesizedExpression
            });
          }
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === BIND_NONE) {
            this.raise(Errors.StrictEvalArguments, {
              at,
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, {
              at,
              bindingName: at.name
            });
          }
        }
        if (!allowLetBinding && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, {
            at
          });
        }
        if (!(bindingType & BIND_NONE)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern)
              break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, {
              at: node
            });
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
          at: this.state.startLoc
        });
        return true;
      }
    };
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, {
              at: key
            });
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, {
                at: key
              });
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(137)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(106)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, {
            in: this.finishNode(node, "AssignmentExpression")
          });
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, {
              at: left,
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                  at: this.state.startLoc
                });
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, {
                at: this.state.startLoc
              });
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(106)) {
                    throw this.raise(Errors.PipeBodyIsTighter, {
                      at: this.state.startLoc
                    });
                  }
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(
          body.type
        );
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, {
            at: startLoc,
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, {
            at: startLoc
          });
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
            at: node.argument
          });
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.isAwaitAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary)
            this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, {
                at: node
              });
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, {
                at: node
              });
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(
          node,
          update,
          refExpressionErrors
        );
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
              at: startLoc
            });
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, {
            in: this.finishNode(updateExpressionNode, "UpdateExpression")
          });
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false))
          return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, {
            in: expr = this.finishNode(node2, "UpdateExpression")
          });
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls && this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(136)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, {
              at: startLoc
            });
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(
            11,
            base.type === "Import",
            base.type !== "Super",
            node,
            refExpressionErrors
          );
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, {
            at: startLoc
          });
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 2) {
            {
              if (!this.hasPlugin("moduleAttributes")) {
                this.expectPlugin("importAssertions");
              }
            }
          }
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, {
              at: node,
              maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
            });
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, {
                  at: arg
                });
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                this.raise(Errors.ImportCallArgumentTrailingComma, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node);
            }
            if (!this.match(10)) {
              this.raise(Errors.UnsupportedImport, {
                at: this.state.lastTokStartLoc
              });
            }
            return this.finishNode(node, "Import");
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 132:
            return this.parseNumericLiteral(this.state.value);
          case 133:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseDecimalLiteral(this.state.value);
          case 131:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, {
                at: callee
              });
            }
          }
          case 136: {
            this.raise(Errors.PrivateInExpectedIn, {
              at: this.state.startLoc,
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            } else {
              throw this.unexpected();
            }
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
              break;
            } else {
              throw this.unexpected();
            }
          }
          default:
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              throw this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          throw this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(
              pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound,
              {
                at: startLoc
              }
            );
          }
          this.registerTopicReference();
          return this.finishNode(node, nodeType);
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, {
            at: startLoc,
            token: tokenLabelName(tokenType)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, {
              at: startLoc
            });
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, {
            at: this.state.curPosition()
          });
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(PARAM_AWAIT);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.SuperNotAllowed, {
            at: node
          });
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.UnexpectedSuper, {
            at: node
          });
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, {
            at: node
          });
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(
          createPositionWithColumnOffset(this.state.startLoc, 1)
        );
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(102)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, {
            at: node.property,
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(100)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, {
              at: id
            });
          }
          this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.parseLiteral(value.value, "RegExpLiteral");
        node.pattern = value.pattern;
        node.flags = value.flags;
        return node;
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc)
          this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc)
          this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(
          startLoc,
          val
        );
      }
      wrapParenthesis(startLoc, expression) {
        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
            this.raise(Errors.UnexpectedNewTarget, {
              at: metaProp
            });
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        node.callee = this.parseNoCallExpr();
        if (node.callee.type === "Import") {
          this.raise(Errors.ImportCallNotNewExpression, {
            at: node.callee
          });
        } else if (this.isOptionalChain(node.callee)) {
          this.raise(Errors.OptionalChainingNoNew, {
            at: this.state.lastTokEndLoc
          });
        } else if (this.eat(18)) {
          this.raise(Errors.OptionalChainingNoNew, {
            at: this.state.startLoc
          });
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, {
              at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
            });
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        node.expressions = [];
        let curElt = this.parseTemplateElement(isTagged);
        node.quasis = [curElt];
        while (!curElt.tail) {
          node.expressions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          node.quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(
                node
              );
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, {
              at: prop
            });
          }
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStart);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, {
              at: this.state.startLoc
            });
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length)
            this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        const key = this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, {
                at: this.state.curPosition(),
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
            at: method
          });
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, {
            at: method
          });
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(
            prop,
            isGenerator,
            false,
            false,
            false,
            "ObjectMethod"
          );
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern)
            this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, {
                at: shorthandAssignLoc
              });
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node)
          this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 132:
                key = this.parseNumericLiteral(value);
                break;
              case 131:
                key = this.parseStringLiteral(value);
                break;
              case 133:
                key = this.parseBigIntLiteral(value);
                break;
              case 134:
                key = this.parseDecimalLiteral(value);
                break;
              case 136: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, {
                    at: privateKeyLoc
                  });
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                throw this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 136) {
            prop.computed = false;
          }
        }
        return prop.key;
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        const allowModifiers = isConstructor;
        this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, allowModifiers);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(
          close,
          !isTuple,
          refExpressionErrors,
          node
        );
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= PARAM_IN;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
          node.body = this.parseBlock(
            true,
            false,
            (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node.id) {
                this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
              }
            }
          );
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i2 = 0, len = params.length; i2 < len; i2++) {
          if (!this.isSimpleParameter(params[i2]))
            return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, {
            in: formalParameters,
            binding: BIND_VAR,
            checkClashes,
            strictModeChanged
          });
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, {
              at: this.state.curPosition(),
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name = this.state.value;
        } else {
          throw this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(130);
          }
        } else {
          this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, {
              at: startLoc
            });
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, {
              at: startLoc
            });
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
              at: startLoc
            });
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError({
            at: startLoc
          });
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, {
              at: startLoc
            });
            return;
          }
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, {
            at: startLoc,
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, {
            at: startLoc,
            reservedWord: word
          });
        }
      }
      isAwaitAllowed() {
        if (this.prodParam.hasAwait)
          return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
          return true;
        }
        return false;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
          at: node
        });
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, {
            at: node
          });
        }
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak())
          return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 101 && !this.state.containsEsc || type === 135 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
          at: node
        });
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 137:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating)
                break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, {
              at: leftStartLoc
            });
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, {
            at: this.state.startLoc
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, {
            at: startLoc
          });
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = PARAM_IN & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | PARAM_IN);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = PARAM_IN & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~PARAM_IN);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program3 = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program3, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: "loop"
    };
    var switchLabel = {
      kind: "switch"
    };
    var ParseFunctionFlag = {
      Expression: 0,
      Declaration: 1,
      HangingDeclaration: 2,
      NullableId: 4,
      Async: 8
    };
    var ParseStatementFlag = {
      StatementOnly: 0,
      AllowImportExport: 1,
      AllowDeclaration: 2,
      AllowFunctionDeclaration: 4,
      AllowLabeledFunction: 8
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input) {
      for (let i2 = 0; i2 < tokens.length; i2++) {
        const token = tokens[i2];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 136) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i2, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(130),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i2++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i2, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i2 += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program3) {
        file.program = this.parseProgram(program3);
        file.comments = this.state.comments;
        if (this.options.tokens) {
          file.tokens = babel7CompatTokens(this.tokens, this.input);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program3, end = 137, sourceType = this.options.sourceType) {
        program3.sourceType = sourceType;
        program3.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program3, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
            this.raise(Errors.ModuleExportUndefined, {
              at,
              localName
            });
          }
        }
        let finishedProgram;
        if (end === 137) {
          finishedProgram = this.finishNode(program3, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program3, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(99)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasFollowingBindingIdentifier() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const lookahead = this.lookahead();
        if (lookahead.type === 101 && !lookahead.containsEsc) {
          return false;
        } else {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      parseModuleItem() {
        return this.parseStatementLike(ParseStatementFlag.AllowImportExport | ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | ParseStatementFlag.AllowLabeledFunction);
      }
      parseStatementListItem() {
        return this.parseStatementLike(ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | ParseStatementFlag.AllowLabeledFunction);
      }
      parseStatementOrFunctionDeclaration(disallowLabeledFunction) {
        return this.parseStatementLike(ParseStatementFlag.AllowFunctionDeclaration | (disallowLabeledFunction ? 0 : ParseStatementFlag.AllowLabeledFunction));
      }
      parseStatement() {
        return this.parseStatementLike(ParseStatementFlag.StatementOnly);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const starttype = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);
        const allowFunctionDeclaration = !!(flags & ParseStatementFlag.AllowFunctionDeclaration);
        const topLevel = flags & ParseStatementFlag.AllowImportExport;
        switch (starttype) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46)
              break;
            if (!allowDeclaration) {
              if (this.state.strict) {
                this.raise(Errors.StrictFunction, {
                  at: this.state.startLoc
                });
              } else if (!allowFunctionDeclaration) {
                this.raise(Errors.SloppyFunction, {
                  at: this.state.startLoc
                });
              }
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration)
              this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 105:
            if (this.hasFollowingLineBreak() || this.state.containsEsc || !this.hasFollowingBindingIdentifier()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, {
                at: this.state.startLoc
              });
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, {
                at: this.state.startLoc
              });
            }
            return this.parseVarStatement(node, "using");
          case 99: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak())
                break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, {
                at: this.state.startLoc
              });
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, {
                at: this.state.startLoc
              });
            }
            this.next();
            let result;
            if (starttype === 83) {
              result = this.parseImport(node);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node, decorators);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                  at: this.state.startLoc
                });
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(
            node,
            maybeName,
            expr,
            flags
          );
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, {
            at: node
          });
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy"))
          return true;
        return this.hasPlugin("decorators") && !!this.getPluginOption("decorators", "decoratorsBeforeExport");
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          classNode.decorators = maybeDecorators;
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode)
            this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, {
              at: this.state.startLoc
            });
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, {
            at: this.state.startLoc
          });
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
                at: paramsStartLoc
              });
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(136)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.eat(10)) {
          const node = this.startNodeAtNode(expr);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11, false);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i2;
        for (i2 = 0; i2 < this.state.labels.length; ++i2) {
          const lab = this.state.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop"))
              break;
            if (node.label && isBreak)
              break;
          }
        }
        if (i2 === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, {
            at: node,
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isAwaitAllowed() && this.eatContextual(96)) {
          awaitAt = this.state.lastTokStartLoc;
        }
        this.scope.enter(SCOPE_OTHER);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(99);
        const startsWithUsing = this.isContextual(105) && !this.hasFollowingLineBreak();
        const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || startsWithUsing && this.hasFollowingBindingIdentifier() && this.startsUsingForOf();
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          const initNode = this.startNode();
          const kind = this.state.value;
          this.next();
          this.parseVar(initNode, true, kind);
          const init4 = this.finishNode(initNode, "VariableDeclaration");
          const isForIn = this.match(58);
          if (isForIn && startsWithUsing) {
            this.raise(Errors.ForInUsing, {
              at: init4
            });
          }
          if ((isForIn || this.isContextual(101)) && init4.declarations.length === 1) {
            return this.parseForIn(node, init4, awaitAt);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init4);
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init3 = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(101);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, {
              at: init3
            });
          }
          if (awaitAt === null && startsWithAsync && init3.type === "Identifier") {
            this.raise(Errors.ForOfAsync, {
              at: init3
            });
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init3, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init3, {
            in: {
              type
            }
          });
          return this.parseForIn(
            node,
            init3,
            awaitAt
          );
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init3);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, ParseFunctionFlag.Declaration | (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) | (isAsync ? ParseFunctionFlag.Async : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrFunctionDeclaration(
          true
        );
        node.alternate = this.eat(66) ? this.parseStatementOrFunctionDeclaration(true) : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(Errors.IllegalReturn, {
            at: this.state.startLoc
          });
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(SCOPE_OTHER);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur)
              this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, {
                  at: this.state.lastTokStartLoc
                });
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur)
          this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, {
            at: this.state.lastTokEndLoc
          });
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        const simple = param.type === "Identifier";
        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(param, {
          in: {
            type: "CatchClause"
          },
          binding: BIND_LEXICAL,
          allowingSloppyLetBinding: true
        });
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(SCOPE_OTHER);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, {
            at: node
          });
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, {
            at: this.state.startLoc
          });
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, {
              at: expr,
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
        for (let i2 = this.state.labels.length - 1; i2 >= 0; i2--) {
          const label = this.state.labels[i2];
          if (label.statementStart === node.start) {
            label.statementStart = this.state.start;
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.state.start
        });
        node.body = flags & ParseStatementFlag.AllowLabeledFunction ? this.parseStatementOrFunctionDeclaration(false) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(SCOPE_OTHER);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        if (afterBlockParse) {
          afterBlockParse.call(this, hasStrictModeDirective);
        }
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init3) {
        node.init = init3;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init3, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null)
            this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init3.type === "VariableDeclaration" && init3.declarations[0].init != null && (!isForIn || this.state.strict || init3.kind !== "var" || init3.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, {
            at: init3,
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init3.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, {
            at: init3,
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init3;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
              this.raise(Errors.DeclarationMissingInitializer, {
                at: this.state.lastTokEndLoc,
                kind: "destructuring"
              });
            } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
              this.raise(Errors.DeclarationMissingInitializer, {
                at: this.state.lastTokEndLoc,
                kind: "const"
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12))
            break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        this.checkLVal(id, {
          in: {
            type: "VariableDeclarator"
          },
          binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
        });
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, ParseFunctionFlag.Async);
      }
      parseFunction(node, flags = ParseFunctionFlag.Expression) {
        const hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;
        const isDeclaration = !!(flags & ParseFunctionFlag.Declaration);
        const requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);
        const isAsync = !!(flags & ParseFunctionFlag.Async);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, {
              at: this.state.startLoc
            });
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(SCOPE_FUNCTION);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, allowModifiers) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, false, allowModifiers);
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id)
          return;
        this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, {
                  at: this.state.lastTokEndLoc
                });
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, {
                at: member
              });
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, {
            at: this.state.startLoc
          });
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(104);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(136);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, {
              at: publicMethod.key
            });
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
        const isPrivate = this.match(136);
        const key = this.parseClassElementName(member);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, {
                at: key
              });
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, {
                at: key
              });
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(136);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = key.name;
          const isPrivate2 = this.match(136);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(136);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 130 || type === 131) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, {
            at: this.state.startLoc
          });
        }
        if (type === 136) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, {
              at: this.state.startLoc
            });
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        return this.parsePropertyName(member);
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(PARAM);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, {
            at: member
          });
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
          this.raise(Errors.ConstructorClassField, {
            at: prop.key
          });
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed) {
          const key = prop.key;
          if (key.name === "constructor" || key.value === "constructor") {
            this.raise(Errors.ConstructorClassField, {
              at: key
            });
          }
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(PARAM);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, {
              at: this.state.startLoc
            });
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const hasDefault = this.maybeParseExportDefaultSpecifier(
          node
        );
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(
          node
        );
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(
          node
        );
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault)
            this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(
          node
        );
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
          throw this.unexpected(null, 5);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
          this.checkExport(node2, true, true);
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        throw this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node) {
        if (this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = this.parseIdentifier(true);
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          if (!node.specifiers)
            node.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          if (!node.specifiers)
            node.specifiers = [];
          const isTypeExport = node.exportKind === "type";
          node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node.source = null;
          node.declaration = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95))
          return false;
        const next = this.nextTokenStart();
        return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId | ParseFunctionFlag.Async);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(Errors.DecoratorBeforeExport, {
              at: this.state.startLoc
            });
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(Errors.UnsupportedDefaultExport, {
            at: this.state.startLoc
          });
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 99) {
            return false;
          }
          if ((type === 128 || type === 127) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(97)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
            this.checkJSONModuleImport(node);
          }
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              throw this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            return true;
          }
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, {
                  at: declaration
                });
              }
            }
          } else if (node.specifiers && node.specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, {
                    at: specifier,
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
              const id = node.declaration.id;
              if (!id)
                throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (node.declaration.type === "VariableDeclaration") {
              for (const declaration of node.declaration.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, {
              at: node
            });
          } else {
            this.raise(Errors.DuplicateExport, {
              at: node,
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8))
              break;
          }
          const isMaybeTypeOnly = this.isContextual(128);
          const isString = this.match(131);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(131)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = result.value.match(loneSurrogate);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
              at: result,
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key,
            value
          }) => {
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        if (node.module) {
          var _node$assertions;
          if (node.specifiers.length !== 1 || node.specifiers[0].type !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, {
              at: node.specifiers[0].loc.start
            });
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, {
              at: node.specifiers[0].loc.start
            });
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, {
                at: nonDefaultNamedSpecifier.loc.start
              });
            }
          }
        }
      }
      parseMaybeImportReflection(node) {
        let isImportReflection = false;
        if (this.isContextual(125)) {
          const lookahead = this.lookahead();
          const nextType = lookahead.type;
          if (tokenIsIdentifier(nextType)) {
            if (nextType !== 97) {
              isImportReflection = true;
            } else {
              const nextNextTokenFirstChar = this.input.charCodeAt(this.nextTokenStartSince(lookahead.end));
              if (nextNextTokenFirstChar === 102) {
                isImportReflection = true;
              }
            }
          } else if (nextType !== 12) {
            isImportReflection = true;
          }
        }
        if (isImportReflection) {
          this.expectPlugin("importReflection");
          this.next();
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
      }
      parseImport(node) {
        node.specifiers = [];
        if (!this.match(131)) {
          this.parseMaybeImportReflection(node);
          const hasDefault = this.maybeParseDefaultImportSpecifier(node);
          const parseNext = !hasDefault || this.eat(12);
          const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
          if (parseNext && !hasStar)
            this.parseNamedImportSpecifiers(node);
          this.expectContextual(97);
        }
        node.source = this.parseImportSource();
        const assertions = this.maybeParseImportAssertions();
        if (assertions) {
          node.assertions = assertions;
        } else {
          const attributes = this.maybeParseModuleAttributes();
          if (attributes) {
            node.attributes = attributes;
          }
        }
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(131))
          this.unexpected();
        return this.parseExprAtom();
      }
      shouldParseDefaultImport(node) {
        return tokenIsIdentifier(this.state.type);
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = BIND_LEXICAL) {
        this.checkLVal(specifier.local, {
          in: specifier,
          binding: bindingType
        });
        return this.finishNode(specifier, type);
      }
      parseAssertEntries() {
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
              at: this.state.startLoc,
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(131)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(131)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, {
              at: this.state.startLoc
            });
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseModuleAttributes() {
        if (this.match(76) && !this.hasPrecedingLineBreak()) {
          this.expectPlugin("moduleAttributes");
          this.next();
        } else {
          if (this.hasPlugin("moduleAttributes"))
            return [];
          return null;
        }
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, {
              at: node.key
            });
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
              at: node.key,
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(131)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, {
              at: this.state.startLoc
            });
          }
          node.value = this.parseStringLiteral(this.state.value);
          this.finishNode(node, "ImportAttribute");
          attrs.push(node);
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAssertions() {
        if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          this.expectPlugin("importAssertions");
          this.next();
        } else {
          if (this.hasPlugin("importAssertions"))
            return [];
          return null;
        }
        this.eat(5);
        const attrs = this.parseAssertEntries();
        this.eat(8);
        return attrs;
      }
      maybeParseDefaultImportSpecifier(node) {
        if (this.shouldParseDefaultImport(node)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, {
                at: this.state.startLoc
              });
            }
            this.expect(12);
            if (this.eat(8))
              break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(131);
          const isMaybeTypeOnly = this.isContextual(128);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, {
              at: specifier,
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options.sourceFilename;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program3 = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program3);
        file.errors = this.state.errors;
        return file;
      }
    };
    function pluginsMap(plugins) {
      const pluginMap = /* @__PURE__ */ new Map();
      for (const plugin2 of plugins) {
        const [name, options] = Array.isArray(plugin2) ? plugin2 : [plugin2, {}];
        if (!pluginMap.has(name))
          pluginMap.set(name, options || {});
      }
      return pluginMap;
    }
    function parse12(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes2 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      if (options != null && options.plugins) {
        validatePlugins2(options.plugins);
        cls = getParserClass(options.plugins);
      }
      return new cls(options, input);
    }
    var parserClassCache = {};
    function getParserClass(pluginsFromOptions) {
      const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
      const key = pluginList.join("/");
      let cls = parserClassCache[key];
      if (!cls) {
        cls = Parser;
        for (const plugin2 of pluginList) {
          cls = mixinPlugins[plugin2](cls);
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }
    exports.parse = parse12;
    exports.parseExpression = parseExpression;
    exports.tokTypes = tokTypes;
  }
});

// ../../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p3 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p3))
            d3[p3] = b2[p3];
      };
      __extends = function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s2 = arguments[i2];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t3[p3] = s2[p3];
        }
        return t3;
      };
      __rest = function(s2, e3) {
        var t3 = {};
        for (var p3 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p3) && e3.indexOf(p3) < 0)
            t3[p3] = s2[p3];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
            if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
              t3[p3[i2]] = s2[p3[i2]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d3 = decorators[i2])
              r3 = (c2 < 3 ? d3(r3) : c2 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c2 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f5) {
          if (f5 !== void 0 && typeof f5 !== "function")
            throw new TypeError("Function expected");
          return f5;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _3, done = false;
        for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
          var context = {};
          for (var p3 in contextIn)
            context[p3] = p3 === "access" ? {} : contextIn[p3];
          for (var p3 in contextIn.access)
            context.access[p3] = contextIn.access[p3];
          context.addInitializer = function(f5) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f5 || null));
          };
          var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_3 = accept(result.get))
              descriptor.get = _3;
            if (_3 = accept(result.set))
              descriptor.set = _3;
            if (_3 = accept(result.init))
              initializers.push(_3);
          } else if (_3 = accept(result)) {
            if (kind === "field")
              initializers.push(_3);
            else
              descriptor[key] = _3;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i2 = 0; i2 < initializers.length; i2++) {
          value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey = function(x3) {
        return typeof x3 === "symbol" ? x3 : "".concat(x3);
      };
      __setFunctionName = function(f5, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f5, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _3 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y3, t3, g3;
        return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
          return this;
        }), g3;
        function verb(n) {
          return function(v2) {
            return step([n, v2]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (g3 && (g3 = 0, op[0] && (_3 = 0)), _3)
            try {
              if (f5 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _3.label++;
                  return { value: op[1], done: false };
                case 5:
                  _3.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _3.ops.pop();
                  _3.trys.pop();
                  continue;
                default:
                  if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _3 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _3.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _3.label < t3[1]) {
                    _3.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _3.label < t3[2]) {
                    _3.label = t3[2];
                    _3.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _3.ops.pop();
                  _3.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _3);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m3, o2) {
        for (var p3 in m3)
          if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p3))
            __createBinding(o2, m3, p3);
      };
      __createBinding = Object.create ? function(o2, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m3[k3];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
        if (m3)
          return m3.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n) {
        var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m3)
          return o2;
        var i2 = m3.call(o2), r3, ar = [], e3;
        try {
          while ((n === void 0 || n-- > 0) && !(r3 = i2.next()).done)
            ar.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m3 = i2["return"]))
              m3.call(i2);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r3 = Array(s2), k3 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k3++)
            r3[k3] = a2[j2];
        return r3;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g3 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g3[n])
            i2[n] = function(v2) {
              return new Promise(function(a2, b2) {
                q3.push([n, v2, a2, b2]) > 1 || resume(n, v2);
              });
            };
        }
        function resume(n, v2) {
          try {
            step(g3[n](v2));
          } catch (e3) {
            settle(q3[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f5, v2) {
          if (f5(v2), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p3;
        return i2 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f5) {
          i2[n] = o2[n] ? function(v2) {
            return (p3 = !p3) ? { value: __await(o2[n](v2)), done: false } : f5 ? f5(v2) : v2;
          } : f5;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o2[Symbol.asyncIterator], i2;
        return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o2[n] && function(v2) {
            return new Promise(function(resolve2, reject) {
              v2 = o2[n](v2), settle(resolve2, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve2, reject, d3, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve2({ value: v3, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f5) {
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f5) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/shared.js
var require_shared = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maybeSetModuleExports = void 0;
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    function default_1(fork) {
      var types17 = fork.use(types_1.default);
      var Type = types17.Type;
      var builtin = types17.builtInTypes;
      var isNumber = builtin.number;
      function geq(than) {
        return Type.from(function(value) {
          return isNumber.check(value) && value >= than;
        }, isNumber + " >= " + than);
      }
      ;
      var defaults = {
        "null": function() {
          return null;
        },
        "emptyArray": function() {
          return [];
        },
        "false": function() {
          return false;
        },
        "true": function() {
          return true;
        },
        "undefined": function() {
        },
        "use strict": function() {
          return "use strict";
        }
      };
      var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
      var isPrimitive = Type.from(function(value) {
        if (value === null)
          return true;
        var type = typeof value;
        if (type === "object" || type === "function") {
          return false;
        }
        return true;
      }, naiveIsPrimitive.toString());
      return {
        geq,
        defaults,
        isPrimitive
      };
    }
    exports.default = default_1;
    function maybeSetModuleExports(moduleGetter) {
      try {
        var nodeModule = moduleGetter();
        var originalExports = nodeModule.exports;
        var defaultExport = originalExports["default"];
      } catch (_a) {
        return;
      }
      if (defaultExport && defaultExport !== originalExports && typeof originalExports === "object") {
        Object.assign(defaultExport, originalExports, { "default": defaultExport });
        if (originalExports.__esModule) {
          Object.defineProperty(defaultExport, "__esModule", { value: true });
        }
        nodeModule.exports = defaultExport;
      }
    }
    exports.maybeSetModuleExports = maybeSetModuleExports;
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/types.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Def = void 0;
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var Op = Object.prototype;
    var objToStr = Op.toString;
    var hasOwn = Op.hasOwnProperty;
    var BaseType = function() {
      function BaseType2() {
      }
      BaseType2.prototype.assert = function(value, deep) {
        if (!this.check(value, deep)) {
          var str = shallowStringify(value);
          throw new Error(str + " does not match type " + this);
        }
        return true;
      };
      BaseType2.prototype.arrayOf = function() {
        var elemType = this;
        return new ArrayType(elemType);
      };
      return BaseType2;
    }();
    var ArrayType = function(_super) {
      tslib_1.__extends(ArrayType2, _super);
      function ArrayType2(elemType) {
        var _this = _super.call(this) || this;
        _this.elemType = elemType;
        _this.kind = "ArrayType";
        return _this;
      }
      ArrayType2.prototype.toString = function() {
        return "[" + this.elemType + "]";
      };
      ArrayType2.prototype.check = function(value, deep) {
        var _this = this;
        return Array.isArray(value) && value.every(function(elem) {
          return _this.elemType.check(elem, deep);
        });
      };
      return ArrayType2;
    }(BaseType);
    var IdentityType = function(_super) {
      tslib_1.__extends(IdentityType2, _super);
      function IdentityType2(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.kind = "IdentityType";
        return _this;
      }
      IdentityType2.prototype.toString = function() {
        return String(this.value);
      };
      IdentityType2.prototype.check = function(value, deep) {
        var result = value === this.value;
        if (!result && typeof deep === "function") {
          deep(this, value);
        }
        return result;
      };
      return IdentityType2;
    }(BaseType);
    var ObjectType = function(_super) {
      tslib_1.__extends(ObjectType2, _super);
      function ObjectType2(fields) {
        var _this = _super.call(this) || this;
        _this.fields = fields;
        _this.kind = "ObjectType";
        return _this;
      }
      ObjectType2.prototype.toString = function() {
        return "{ " + this.fields.join(", ") + " }";
      };
      ObjectType2.prototype.check = function(value, deep) {
        return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
          return field.type.check(value[field.name], deep);
        });
      };
      return ObjectType2;
    }(BaseType);
    var OrType = function(_super) {
      tslib_1.__extends(OrType2, _super);
      function OrType2(types17) {
        var _this = _super.call(this) || this;
        _this.types = types17;
        _this.kind = "OrType";
        return _this;
      }
      OrType2.prototype.toString = function() {
        return this.types.join(" | ");
      };
      OrType2.prototype.check = function(value, deep) {
        if (this.types.some(function(type) {
          return type.check(value, !!deep);
        })) {
          return true;
        }
        if (typeof deep === "function") {
          deep(this, value);
        }
        return false;
      };
      return OrType2;
    }(BaseType);
    var PredicateType = function(_super) {
      tslib_1.__extends(PredicateType2, _super);
      function PredicateType2(name, predicate) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.predicate = predicate;
        _this.kind = "PredicateType";
        return _this;
      }
      PredicateType2.prototype.toString = function() {
        return this.name;
      };
      PredicateType2.prototype.check = function(value, deep) {
        var result = this.predicate(value, deep);
        if (!result && typeof deep === "function") {
          deep(this, value);
        }
        return result;
      };
      return PredicateType2;
    }(BaseType);
    var Def = function() {
      function Def2(type, typeName) {
        this.type = type;
        this.typeName = typeName;
        this.baseNames = [];
        this.ownFields = /* @__PURE__ */ Object.create(null);
        this.allSupertypes = /* @__PURE__ */ Object.create(null);
        this.supertypeList = [];
        this.allFields = /* @__PURE__ */ Object.create(null);
        this.fieldNames = [];
        this.finalized = false;
        this.buildable = false;
        this.buildParams = [];
      }
      Def2.prototype.isSupertypeOf = function(that) {
        if (that instanceof Def2) {
          if (this.finalized !== true || that.finalized !== true) {
            throw new Error("");
          }
          return hasOwn.call(that.allSupertypes, this.typeName);
        } else {
          throw new Error(that + " is not a Def");
        }
      };
      Def2.prototype.checkAllFields = function(value, deep) {
        var allFields = this.allFields;
        if (this.finalized !== true) {
          throw new Error("" + this.typeName);
        }
        function checkFieldByName(name) {
          var field = allFields[name];
          var type = field.type;
          var child = field.getValue(value);
          return type.check(child, deep);
        }
        return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
      };
      Def2.prototype.bases = function() {
        var supertypeNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          supertypeNames[_i] = arguments[_i];
        }
        var bases = this.baseNames;
        if (this.finalized) {
          if (supertypeNames.length !== bases.length) {
            throw new Error("");
          }
          for (var i2 = 0; i2 < supertypeNames.length; i2++) {
            if (supertypeNames[i2] !== bases[i2]) {
              throw new Error("");
            }
          }
          return this;
        }
        supertypeNames.forEach(function(baseName) {
          if (bases.indexOf(baseName) < 0) {
            bases.push(baseName);
          }
        });
        return this;
      };
      return Def2;
    }();
    exports.Def = Def;
    var Field = function() {
      function Field2(name, type, defaultFn, hidden4) {
        this.name = name;
        this.type = type;
        this.defaultFn = defaultFn;
        this.hidden = !!hidden4;
      }
      Field2.prototype.toString = function() {
        return JSON.stringify(this.name) + ": " + this.type;
      };
      Field2.prototype.getValue = function(obj) {
        var value = obj[this.name];
        if (typeof value !== "undefined") {
          return value;
        }
        if (typeof this.defaultFn === "function") {
          value = this.defaultFn.call(obj);
        }
        return value;
      };
      return Field2;
    }();
    function shallowStringify(value) {
      if (Array.isArray(value)) {
        return "[" + value.map(shallowStringify).join(", ") + "]";
      }
      if (value && typeof value === "object") {
        return "{ " + Object.keys(value).map(function(key) {
          return key + ": " + value[key];
        }).join(", ") + " }";
      }
      return JSON.stringify(value);
    }
    function typesPlugin(_fork) {
      var Type = {
        or: function() {
          var types17 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            types17[_i] = arguments[_i];
          }
          return new OrType(types17.map(function(type) {
            return Type.from(type);
          }));
        },
        from: function(value, name) {
          if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {
            return value;
          }
          if (value instanceof Def) {
            return value.type;
          }
          if (isArray.check(value)) {
            if (value.length !== 1) {
              throw new Error("only one element type is permitted for typed arrays");
            }
            return new ArrayType(Type.from(value[0]));
          }
          if (isObject2.check(value)) {
            return new ObjectType(Object.keys(value).map(function(name2) {
              return new Field(name2, Type.from(value[name2], name2));
            }));
          }
          if (typeof value === "function") {
            var bicfIndex = builtInCtorFns.indexOf(value);
            if (bicfIndex >= 0) {
              return builtInCtorTypes[bicfIndex];
            }
            if (typeof name !== "string") {
              throw new Error("missing name");
            }
            return new PredicateType(name, value);
          }
          return new IdentityType(value);
        },
        def: function(typeName) {
          return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
        },
        hasDef: function(typeName) {
          return hasOwn.call(defCache, typeName);
        }
      };
      var builtInCtorFns = [];
      var builtInCtorTypes = [];
      function defBuiltInType(name, example) {
        var objStr = objToStr.call(example);
        var type = new PredicateType(name, function(value) {
          return objToStr.call(value) === objStr;
        });
        if (example && typeof example.constructor === "function") {
          builtInCtorFns.push(example.constructor);
          builtInCtorTypes.push(type);
        }
        return type;
      }
      var isString = defBuiltInType("string", "truthy");
      var isFunction = defBuiltInType("function", function() {
      });
      var isArray = defBuiltInType("array", []);
      var isObject2 = defBuiltInType("object", {});
      var isRegExp = defBuiltInType("RegExp", /./);
      var isDate = defBuiltInType("Date", new Date());
      var isNumber = defBuiltInType("number", 3);
      var isBoolean = defBuiltInType("boolean", true);
      var isNull = defBuiltInType("null", null);
      var isUndefined = defBuiltInType("undefined", void 0);
      var isBigInt = typeof BigInt === "function" ? defBuiltInType("BigInt", BigInt(1234)) : new PredicateType("BigInt", function() {
        return false;
      });
      var builtInTypes = {
        string: isString,
        function: isFunction,
        array: isArray,
        object: isObject2,
        RegExp: isRegExp,
        Date: isDate,
        number: isNumber,
        boolean: isBoolean,
        null: isNull,
        undefined: isUndefined,
        BigInt: isBigInt
      };
      var defCache = /* @__PURE__ */ Object.create(null);
      function defFromValue(value) {
        if (value && typeof value === "object") {
          var type = value.type;
          if (typeof type === "string" && hasOwn.call(defCache, type)) {
            var d3 = defCache[type];
            if (d3.finalized) {
              return d3;
            }
          }
        }
        return null;
      }
      var DefImpl = function(_super) {
        tslib_1.__extends(DefImpl2, _super);
        function DefImpl2(typeName) {
          var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
            return _this.check(value, deep);
          }), typeName) || this;
          return _this;
        }
        DefImpl2.prototype.check = function(value, deep) {
          if (this.finalized !== true) {
            throw new Error("prematurely checking unfinalized type " + this.typeName);
          }
          if (value === null || typeof value !== "object") {
            return false;
          }
          var vDef = defFromValue(value);
          if (!vDef) {
            if (this.typeName === "SourceLocation" || this.typeName === "Position") {
              return this.checkAllFields(value, deep);
            }
            return false;
          }
          if (deep && vDef === this) {
            return this.checkAllFields(value, deep);
          }
          if (!this.isSupertypeOf(vDef)) {
            return false;
          }
          if (!deep) {
            return true;
          }
          return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
        };
        DefImpl2.prototype.build = function() {
          var _this = this;
          var buildParams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            buildParams[_i] = arguments[_i];
          }
          this.buildParams = buildParams;
          if (this.buildable) {
            return this;
          }
          this.field("type", String, function() {
            return _this.typeName;
          });
          this.buildable = true;
          var addParam = function(built, param, arg, isArgAvailable) {
            if (hasOwn.call(built, param))
              return;
            var all = _this.allFields;
            if (!hasOwn.call(all, param)) {
              throw new Error("" + param);
            }
            var field = all[param];
            var type = field.type;
            var value;
            if (isArgAvailable) {
              value = arg;
            } else if (field.defaultFn) {
              value = field.defaultFn.call(built);
            } else {
              var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
                return all[name];
              }).join(", ") + ")";
              throw new Error(message);
            }
            if (!type.check(value)) {
              throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
            }
            built[param] = value;
          };
          var builder = function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            var argc = args.length;
            if (!_this.finalized) {
              throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
            }
            var built = Object.create(nodePrototype);
            _this.buildParams.forEach(function(param, i2) {
              if (i2 < argc) {
                addParam(built, param, args[i2], true);
              } else {
                addParam(built, param, null, false);
              }
            });
            Object.keys(_this.allFields).forEach(function(param) {
              addParam(built, param, null, false);
            });
            if (built.type !== _this.typeName) {
              throw new Error("");
            }
            return built;
          };
          builder.from = function(obj) {
            if (!_this.finalized) {
              throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
            }
            var built = Object.create(nodePrototype);
            Object.keys(_this.allFields).forEach(function(param) {
              if (hasOwn.call(obj, param)) {
                addParam(built, param, obj[param], true);
              } else {
                addParam(built, param, null, false);
              }
            });
            if (built.type !== _this.typeName) {
              throw new Error("");
            }
            return built;
          };
          Object.defineProperty(builders, getBuilderName(this.typeName), {
            enumerable: true,
            value: builder
          });
          return this;
        };
        DefImpl2.prototype.field = function(name, type, defaultFn, hidden4) {
          if (this.finalized) {
            console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName));
            return this;
          }
          this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden4);
          return this;
        };
        DefImpl2.prototype.finalize = function() {
          var _this = this;
          if (!this.finalized) {
            var allFields = this.allFields;
            var allSupertypes = this.allSupertypes;
            this.baseNames.forEach(function(name) {
              var def = defCache[name];
              if (def instanceof Def) {
                def.finalize();
                extend(allFields, def.allFields);
                extend(allSupertypes, def.allSupertypes);
              } else {
                var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
                throw new Error(message);
              }
            });
            extend(allFields, this.ownFields);
            allSupertypes[this.typeName] = this;
            this.fieldNames.length = 0;
            for (var fieldName in allFields) {
              if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                this.fieldNames.push(fieldName);
              }
            }
            Object.defineProperty(namedTypes, this.typeName, {
              enumerable: true,
              value: this.type
            });
            this.finalized = true;
            populateSupertypeList(this.typeName, this.supertypeList);
            if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) {
              wrapExpressionBuilderWithStatement(this.typeName);
            }
          }
        };
        return DefImpl2;
      }(Def);
      function getSupertypeNames(typeName) {
        if (!hasOwn.call(defCache, typeName)) {
          throw new Error("");
        }
        var d3 = defCache[typeName];
        if (d3.finalized !== true) {
          throw new Error("");
        }
        return d3.supertypeList.slice(1);
      }
      function computeSupertypeLookupTable(candidates) {
        var table = {};
        var typeNames = Object.keys(defCache);
        var typeNameCount = typeNames.length;
        for (var i2 = 0; i2 < typeNameCount; ++i2) {
          var typeName = typeNames[i2];
          var d3 = defCache[typeName];
          if (d3.finalized !== true) {
            throw new Error("" + typeName);
          }
          for (var j2 = 0; j2 < d3.supertypeList.length; ++j2) {
            var superTypeName = d3.supertypeList[j2];
            if (hasOwn.call(candidates, superTypeName)) {
              table[typeName] = superTypeName;
              break;
            }
          }
        }
        return table;
      }
      var builders = /* @__PURE__ */ Object.create(null);
      var nodePrototype = {};
      function defineMethod(name, func) {
        var old = nodePrototype[name];
        if (isUndefined.check(func)) {
          delete nodePrototype[name];
        } else {
          isFunction.assert(func);
          Object.defineProperty(nodePrototype, name, {
            enumerable: true,
            configurable: true,
            value: func
          });
        }
        return old;
      }
      function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
          var len = upperCasePrefix.length;
          switch (len) {
            case 0:
              return "";
            case 1:
              return upperCasePrefix.toLowerCase();
            default:
              return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
          }
        });
      }
      function getStatementBuilderName(typeName) {
        typeName = getBuilderName(typeName);
        return typeName.replace(/(Expression)?$/, "Statement");
      }
      var namedTypes = {};
      function getFieldNames(object) {
        var d3 = defFromValue(object);
        if (d3) {
          return d3.fieldNames.slice(0);
        }
        if ("type" in object) {
          throw new Error("did not recognize object of type " + JSON.stringify(object.type));
        }
        return Object.keys(object);
      }
      function getFieldValue(object, fieldName) {
        var d3 = defFromValue(object);
        if (d3) {
          var field = d3.allFields[fieldName];
          if (field) {
            return field.getValue(object);
          }
        }
        return object && object[fieldName];
      }
      function eachField(object, callback, context) {
        getFieldNames(object).forEach(function(name) {
          callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function someField(object, callback, context) {
        return getFieldNames(object).some(function(name) {
          return callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);
        if (builders[wrapperName])
          return;
        var wrapped = builders[getBuilderName(typeName)];
        if (!wrapped)
          return;
        var builder = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return builders.expressionStatement(wrapped.apply(builders, args));
        };
        builder.from = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return builders.expressionStatement(wrapped.from.apply(builders, args));
        };
        builders[wrapperName] = builder;
      }
      function populateSupertypeList(typeName, list) {
        list.length = 0;
        list.push(typeName);
        var lastSeen = /* @__PURE__ */ Object.create(null);
        for (var pos = 0; pos < list.length; ++pos) {
          typeName = list[pos];
          var d3 = defCache[typeName];
          if (d3.finalized !== true) {
            throw new Error("");
          }
          if (hasOwn.call(lastSeen, typeName)) {
            delete list[lastSeen[typeName]];
          }
          lastSeen[typeName] = pos;
          list.push.apply(list, d3.baseNames);
        }
        for (var to = 0, from = to, len = list.length; from < len; ++from) {
          if (hasOwn.call(list, from)) {
            list[to++] = list[from];
          }
        }
        list.length = to;
      }
      function extend(into, from) {
        Object.keys(from).forEach(function(name) {
          into[name] = from[name];
        });
        return into;
      }
      function finalize() {
        Object.keys(defCache).forEach(function(name) {
          defCache[name].finalize();
        });
      }
      return {
        Type,
        builtInTypes,
        getSupertypeNames,
        computeSupertypeLookupTable,
        builders,
        defineMethod,
        getBuilderName,
        getStatementBuilderName,
        namedTypes,
        getFieldNames,
        getFieldValue,
        eachField,
        someField,
        finalize
      };
    }
    exports.default = typesPlugin;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/path.js
var require_path2 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/path.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var types_1 = tslib_1.__importDefault(require_types());
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    function pathPlugin(fork) {
      var types17 = fork.use(types_1.default);
      var isArray = types17.builtInTypes.array;
      var isNumber = types17.builtInTypes.number;
      var Path = function Path2(value, parentPath, name) {
        if (!(this instanceof Path2)) {
          throw new Error("Path constructor cannot be invoked without 'new'");
        }
        if (parentPath) {
          if (!(parentPath instanceof Path2)) {
            throw new Error("");
          }
        } else {
          parentPath = null;
          name = null;
        }
        this.value = value;
        this.parentPath = parentPath;
        this.name = name;
        this.__childCache = null;
      };
      var Pp = Path.prototype;
      function getChildCache(path3) {
        return path3.__childCache || (path3.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function getChildPath(path3, name) {
        var cache = getChildCache(path3);
        var actualChildValue = path3.getValueProperty(name);
        var childPath = cache[name];
        if (!hasOwn.call(cache, name) || childPath.value !== actualChildValue) {
          childPath = cache[name] = new path3.constructor(actualChildValue, path3, name);
        }
        return childPath;
      }
      Pp.getValueProperty = function getValueProperty(name) {
        return this.value[name];
      };
      Pp.get = function get() {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          names[_i] = arguments[_i];
        }
        var path3 = this;
        var count = names.length;
        for (var i2 = 0; i2 < count; ++i2) {
          path3 = getChildPath(path3, names[i2]);
        }
        return path3;
      };
      Pp.each = function each(callback, context) {
        var childPaths = [];
        var len = this.value.length;
        var i2 = 0;
        for (var i2 = 0; i2 < len; ++i2) {
          if (hasOwn.call(this.value, i2)) {
            childPaths[i2] = this.get(i2);
          }
        }
        context = context || this;
        for (i2 = 0; i2 < len; ++i2) {
          if (hasOwn.call(childPaths, i2)) {
            callback.call(context, childPaths[i2]);
          }
        }
      };
      Pp.map = function map(callback, context) {
        var result = [];
        this.each(function(childPath) {
          result.push(callback.call(this, childPath));
        }, context);
        return result;
      };
      Pp.filter = function filter(callback, context) {
        var result = [];
        this.each(function(childPath) {
          if (callback.call(this, childPath)) {
            result.push(childPath);
          }
        }, context);
        return result;
      };
      function emptyMoves() {
      }
      function getMoves(path3, offset, start, end) {
        isArray.assert(path3.value);
        if (offset === 0) {
          return emptyMoves;
        }
        var length = path3.value.length;
        if (length < 1) {
          return emptyMoves;
        }
        var argc = arguments.length;
        if (argc === 2) {
          start = 0;
          end = length;
        } else if (argc === 3) {
          start = Math.max(start, 0);
          end = length;
        } else {
          start = Math.max(start, 0);
          end = Math.min(end, length);
        }
        isNumber.assert(start);
        isNumber.assert(end);
        var moves = /* @__PURE__ */ Object.create(null);
        var cache = getChildCache(path3);
        for (var i2 = start; i2 < end; ++i2) {
          if (hasOwn.call(path3.value, i2)) {
            var childPath = path3.get(i2);
            if (childPath.name !== i2) {
              throw new Error("");
            }
            var newIndex = i2 + offset;
            childPath.name = newIndex;
            moves[newIndex] = childPath;
            delete cache[i2];
          }
        }
        delete cache.length;
        return function() {
          for (var newIndex2 in moves) {
            var childPath2 = moves[newIndex2];
            if (childPath2.name !== +newIndex2) {
              throw new Error("");
            }
            cache[newIndex2] = childPath2;
            path3.value[newIndex2] = childPath2.value;
          }
        };
      }
      Pp.shift = function shift() {
        var move = getMoves(this, -1);
        var result = this.value.shift();
        move();
        return result;
      };
      Pp.unshift = function unshift() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var move = getMoves(this, args.length);
        var result = this.value.unshift.apply(this.value, args);
        move();
        return result;
      };
      Pp.push = function push() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        isArray.assert(this.value);
        delete getChildCache(this).length;
        return this.value.push.apply(this.value, args);
      };
      Pp.pop = function pop() {
        isArray.assert(this.value);
        var cache = getChildCache(this);
        delete cache[this.value.length - 1];
        delete cache.length;
        return this.value.pop();
      };
      Pp.insertAt = function insertAt(index) {
        var argc = arguments.length;
        var move = getMoves(this, argc - 1, index);
        if (move === emptyMoves && argc <= 1) {
          return this;
        }
        index = Math.max(index, 0);
        for (var i2 = 1; i2 < argc; ++i2) {
          this.value[index + i2 - 1] = arguments[i2];
        }
        move();
        return this;
      };
      Pp.insertBefore = function insertBefore() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pp = this.parentPath;
        var argc = args.length;
        var insertAtArgs = [this.name];
        for (var i2 = 0; i2 < argc; ++i2) {
          insertAtArgs.push(args[i2]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      Pp.insertAfter = function insertAfter() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pp = this.parentPath;
        var argc = args.length;
        var insertAtArgs = [this.name + 1];
        for (var i2 = 0; i2 < argc; ++i2) {
          insertAtArgs.push(args[i2]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      function repairRelationshipWithParent(path3) {
        if (!(path3 instanceof Path)) {
          throw new Error("");
        }
        var pp = path3.parentPath;
        if (!pp) {
          return path3;
        }
        var parentValue = pp.value;
        var parentCache = getChildCache(pp);
        if (parentValue[path3.name] === path3.value) {
          parentCache[path3.name] = path3;
        } else if (isArray.check(parentValue)) {
          var i2 = parentValue.indexOf(path3.value);
          if (i2 >= 0) {
            parentCache[path3.name = i2] = path3;
          }
        } else {
          parentValue[path3.name] = path3.value;
          parentCache[path3.name] = path3;
        }
        if (parentValue[path3.name] !== path3.value) {
          throw new Error("");
        }
        if (path3.parentPath.get(path3.name) !== path3) {
          throw new Error("");
        }
        return path3;
      }
      Pp.replace = function replace(replacement) {
        var results = [];
        var parentValue = this.parentPath.value;
        var parentCache = getChildCache(this.parentPath);
        var count = arguments.length;
        repairRelationshipWithParent(this);
        if (isArray.check(parentValue)) {
          var originalLength = parentValue.length;
          var move = getMoves(this.parentPath, count - 1, this.name + 1);
          var spliceArgs = [this.name, 1];
          for (var i2 = 0; i2 < count; ++i2) {
            spliceArgs.push(arguments[i2]);
          }
          var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
          if (splicedOut[0] !== this.value) {
            throw new Error("");
          }
          if (parentValue.length !== originalLength - 1 + count) {
            throw new Error("");
          }
          move();
          if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;
          } else {
            if (parentValue[this.name] !== replacement) {
              throw new Error("");
            }
            if (this.value !== replacement) {
              this.value = replacement;
              this.__childCache = null;
            }
            for (i2 = 0; i2 < count; ++i2) {
              results.push(this.parentPath.get(this.name + i2));
            }
            if (results[0] !== this) {
              throw new Error("");
            }
          }
        } else if (count === 1) {
          if (this.value !== replacement) {
            this.__childCache = null;
          }
          this.value = parentValue[this.name] = replacement;
          results.push(this);
        } else if (count === 0) {
          delete parentValue[this.name];
          delete this.value;
          this.__childCache = null;
        } else {
          throw new Error("Could not replace path");
        }
        return results;
      };
      return Path;
    }
    exports.default = pathPlugin;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/scope.js
var require_scope = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/scope.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var types_1 = tslib_1.__importDefault(require_types());
    var hasOwn = Object.prototype.hasOwnProperty;
    function scopePlugin(fork) {
      var types17 = fork.use(types_1.default);
      var Type = types17.Type;
      var namedTypes = types17.namedTypes;
      var Node = namedTypes.Node;
      var Expression = namedTypes.Expression;
      var isArray = types17.builtInTypes.array;
      var b2 = types17.builders;
      var Scope = function Scope2(path3, parentScope) {
        if (!(this instanceof Scope2)) {
          throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        if (!TypeParameterScopeType.check(path3.value)) {
          ScopeType.assert(path3.value);
        }
        var depth;
        if (parentScope) {
          if (!(parentScope instanceof Scope2)) {
            throw new Error("");
          }
          depth = parentScope.depth + 1;
        } else {
          parentScope = null;
          depth = 0;
        }
        Object.defineProperties(this, {
          path: { value: path3 },
          node: { value: path3.value },
          isGlobal: { value: !parentScope, enumerable: true },
          depth: { value: depth },
          parent: { value: parentScope },
          bindings: { value: {} },
          types: { value: {} }
        });
      };
      var ScopeType = Type.or(
        namedTypes.Program,
        namedTypes.Function,
        namedTypes.CatchClause
      );
      var TypeParameterScopeType = Type.or(namedTypes.Function, namedTypes.ClassDeclaration, namedTypes.ClassExpression, namedTypes.InterfaceDeclaration, namedTypes.TSInterfaceDeclaration, namedTypes.TypeAlias, namedTypes.TSTypeAliasDeclaration);
      var FlowOrTSTypeParameterType = Type.or(namedTypes.TypeParameter, namedTypes.TSTypeParameter);
      Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node) || TypeParameterScopeType.check(node);
      };
      var Sp = Scope.prototype;
      Sp.didScan = false;
      Sp.declares = function(name) {
        this.scan();
        return hasOwn.call(this.bindings, name);
      };
      Sp.declaresType = function(name) {
        this.scan();
        return hasOwn.call(this.types, name);
      };
      Sp.declareTemporary = function(prefix) {
        if (prefix) {
          if (!/^[a-z$_]/i.test(prefix)) {
            throw new Error("");
          }
        } else {
          prefix = "t$";
        }
        prefix += this.depth.toString(36) + "$";
        this.scan();
        var index = 0;
        while (this.declares(prefix + index)) {
          ++index;
        }
        var name = prefix + index;
        return this.bindings[name] = types17.builders.identifier(name);
      };
      Sp.injectTemporary = function(identifier, init3) {
        identifier || (identifier = this.declareTemporary());
        var bodyPath = this.path.get("body");
        if (namedTypes.BlockStatement.check(bodyPath.value)) {
          bodyPath = bodyPath.get("body");
        }
        bodyPath.unshift(b2.variableDeclaration("var", [b2.variableDeclarator(identifier, init3 || null)]));
        return identifier;
      };
      Sp.scan = function(force) {
        if (force || !this.didScan) {
          for (var name in this.bindings) {
            delete this.bindings[name];
          }
          for (var name in this.types) {
            delete this.types[name];
          }
          scanScope(this.path, this.bindings, this.types);
          this.didScan = true;
        }
      };
      Sp.getBindings = function() {
        this.scan();
        return this.bindings;
      };
      Sp.getTypes = function() {
        this.scan();
        return this.types;
      };
      function scanScope(path3, bindings, scopeTypes) {
        var node = path3.value;
        if (TypeParameterScopeType.check(node)) {
          var params = path3.get("typeParameters", "params");
          if (isArray.check(params.value)) {
            params.each(function(childPath) {
              addTypeParameter(childPath, scopeTypes);
            });
          }
        }
        if (ScopeType.check(node)) {
          if (namedTypes.CatchClause.check(node)) {
            addPattern(path3.get("param"), bindings);
          } else {
            recursiveScanScope(path3, bindings, scopeTypes);
          }
        }
      }
      function recursiveScanScope(path3, bindings, scopeTypes) {
        var node = path3.value;
        if (path3.parent && namedTypes.FunctionExpression.check(path3.parent.node) && path3.parent.node.id) {
          addPattern(path3.parent.get("id"), bindings);
        }
        if (!node) {
        } else if (isArray.check(node)) {
          path3.each(function(childPath) {
            recursiveScanChild(childPath, bindings, scopeTypes);
          });
        } else if (namedTypes.Function.check(node)) {
          path3.get("params").each(function(paramPath) {
            addPattern(paramPath, bindings);
          });
          recursiveScanChild(path3.get("body"), bindings, scopeTypes);
          recursiveScanScope(path3.get("typeParameters"), bindings, scopeTypes);
        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {
          addTypePattern(path3.get("id"), scopeTypes);
        } else if (namedTypes.VariableDeclarator.check(node)) {
          addPattern(path3.get("id"), bindings);
          recursiveScanChild(path3.get("init"), bindings, scopeTypes);
        } else if (node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier") {
          addPattern(
            path3.get(node.local ? "local" : node.name ? "name" : "id"),
            bindings
          );
        } else if (Node.check(node) && !Expression.check(node)) {
          types17.eachField(node, function(name, child) {
            var childPath = path3.get(name);
            if (!pathHasValue(childPath, child)) {
              throw new Error("");
            }
            recursiveScanChild(childPath, bindings, scopeTypes);
          });
        }
      }
      function pathHasValue(path3, value) {
        if (path3.value === value) {
          return true;
        }
        if (Array.isArray(path3.value) && path3.value.length === 0 && Array.isArray(value) && value.length === 0) {
          return true;
        }
        return false;
      }
      function recursiveScanChild(path3, bindings, scopeTypes) {
        var node = path3.value;
        if (!node || Expression.check(node)) {
        } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {
          addPattern(path3.get("id"), bindings);
        } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node) && node.id !== null) {
          addPattern(path3.get("id"), bindings);
          recursiveScanScope(path3.get("typeParameters"), bindings, scopeTypes);
        } else if (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {
          addTypePattern(path3.get("id"), scopeTypes);
        } else if (ScopeType.check(node)) {
          if (namedTypes.CatchClause.check(node) && namedTypes.Identifier.check(node.param)) {
            var catchParamName = node.param.name;
            var hadBinding = hasOwn.call(bindings, catchParamName);
            recursiveScanScope(path3.get("body"), bindings, scopeTypes);
            if (!hadBinding) {
              delete bindings[catchParamName];
            }
          }
        } else {
          recursiveScanScope(path3, bindings, scopeTypes);
        }
      }
      function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);
        if (namedTypes.Identifier.check(pattern)) {
          if (hasOwn.call(bindings, pattern.name)) {
            bindings[pattern.name].push(patternPath);
          } else {
            bindings[pattern.name] = [patternPath];
          }
        } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {
          addPattern(patternPath.get("left"), bindings);
        } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {
          patternPath.get("properties").each(function(propertyPath) {
            var property = propertyPath.value;
            if (namedTypes.Pattern.check(property)) {
              addPattern(propertyPath, bindings);
            } else if (namedTypes.Property.check(property) || namedTypes.ObjectProperty && namedTypes.ObjectProperty.check(property)) {
              addPattern(propertyPath.get("value"), bindings);
            } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {
              addPattern(propertyPath.get("argument"), bindings);
            }
          });
        } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {
          patternPath.get("elements").each(function(elementPath) {
            var element = elementPath.value;
            if (namedTypes.Pattern.check(element)) {
              addPattern(elementPath, bindings);
            } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {
              addPattern(elementPath.get("argument"), bindings);
            }
          });
        } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {
          addPattern(patternPath.get("pattern"), bindings);
        } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.RestElement && namedTypes.RestElement.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {
          addPattern(patternPath.get("argument"), bindings);
        }
      }
      function addTypePattern(patternPath, types18) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);
        if (namedTypes.Identifier.check(pattern)) {
          if (hasOwn.call(types18, pattern.name)) {
            types18[pattern.name].push(patternPath);
          } else {
            types18[pattern.name] = [patternPath];
          }
        }
      }
      function addTypeParameter(parameterPath, types18) {
        var parameter = parameterPath.value;
        FlowOrTSTypeParameterType.assert(parameter);
        if (hasOwn.call(types18, parameter.name)) {
          types18[parameter.name].push(parameterPath);
        } else {
          types18[parameter.name] = [parameterPath];
        }
      }
      Sp.lookup = function(name) {
        for (var scope = this; scope; scope = scope.parent)
          if (scope.declares(name))
            break;
        return scope;
      };
      Sp.lookupType = function(name) {
        for (var scope = this; scope; scope = scope.parent)
          if (scope.declaresType(name))
            break;
        return scope;
      };
      Sp.getGlobalScope = function() {
        var scope = this;
        while (!scope.isGlobal)
          scope = scope.parent;
        return scope;
      };
      return Scope;
    }
    exports.default = scopePlugin;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/node-path.js
var require_node_path = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/node-path.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    var path_1 = tslib_1.__importDefault(require_path2());
    var scope_1 = tslib_1.__importDefault(require_scope());
    var shared_1 = require_shared();
    function nodePathPlugin(fork) {
      var types17 = fork.use(types_1.default);
      var n = types17.namedTypes;
      var b2 = types17.builders;
      var isNumber = types17.builtInTypes.number;
      var isArray = types17.builtInTypes.array;
      var Path = fork.use(path_1.default);
      var Scope = fork.use(scope_1.default);
      var NodePath = function NodePath2(value, parentPath, name) {
        if (!(this instanceof NodePath2)) {
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value, parentPath, name);
      };
      var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
          value: NodePath,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(NPp, {
        node: {
          get: function() {
            Object.defineProperty(this, "node", {
              configurable: true,
              value: this._computeNode()
            });
            return this.node;
          }
        },
        parent: {
          get: function() {
            Object.defineProperty(this, "parent", {
              configurable: true,
              value: this._computeParent()
            });
            return this.parent;
          }
        },
        scope: {
          get: function() {
            Object.defineProperty(this, "scope", {
              configurable: true,
              value: this._computeScope()
            });
            return this.scope;
          }
        }
      });
      NPp.replace = function() {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
      };
      NPp.prune = function() {
        var remainingNodePath = this.parent;
        this.replace();
        return cleanUpNodesAfterPrune(remainingNodePath);
      };
      NPp._computeNode = function() {
        var value = this.value;
        if (n.Node.check(value)) {
          return value;
        }
        var pp = this.parentPath;
        return pp && pp.node || null;
      };
      NPp._computeParent = function() {
        var value = this.value;
        var pp = this.parentPath;
        if (!n.Node.check(value)) {
          while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
          }
          if (pp) {
            pp = pp.parentPath;
          }
        }
        while (pp && !n.Node.check(pp.value)) {
          pp = pp.parentPath;
        }
        return pp || null;
      };
      NPp._computeScope = function() {
        var value = this.value;
        var pp = this.parentPath;
        var scope = pp && pp.scope;
        if (n.Node.check(value) && Scope.isEstablishedBy(value)) {
          scope = new Scope(this, scope);
        }
        return scope || null;
      };
      NPp.getValueProperty = function(name) {
        return types17.getFieldValue(this.value, name);
      };
      NPp.needsParens = function(assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
          return false;
        }
        var node = this.value;
        if (!n.Expression.check(node)) {
          return false;
        }
        if (node.type === "Identifier") {
          return false;
        }
        while (!n.Node.check(pp.value)) {
          pp = pp.parentPath;
          if (!pp) {
            return false;
          }
        }
        var parent2 = pp.value;
        switch (node.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent2.type === "MemberExpression" && this.name === "object" && parent2.object === node;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent2.type) {
              case "CallExpression":
                return this.name === "callee" && parent2.callee === node;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return true;
              case "MemberExpression":
                return this.name === "object" && parent2.object === node;
              case "BinaryExpression":
              case "LogicalExpression": {
                var n_1 = node;
                var po = parent2.operator;
                var pp_1 = PRECEDENCE[po];
                var no = n_1.operator;
                var np = PRECEDENCE[no];
                if (pp_1 > np) {
                  return true;
                }
                if (pp_1 === np && this.name === "right") {
                  if (parent2.right !== n_1) {
                    throw new Error("Nodes must be equal");
                  }
                  return true;
                }
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (parent2.type) {
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return true;
            }
          case "YieldExpression":
            switch (parent2.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return true;
              default:
                return false;
            }
          case "Literal":
            return parent2.type === "MemberExpression" && isNumber.check(node.value) && this.name === "object" && parent2.object === node;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent2.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return true;
              case "CallExpression":
                return this.name === "callee" && parent2.callee === node;
              case "ConditionalExpression":
                return this.name === "test" && parent2.test === node;
              case "MemberExpression":
                return this.name === "object" && parent2.object === node;
              default:
                return false;
            }
          default:
            if (parent2.type === "NewExpression" && this.name === "callee" && parent2.callee === node) {
              return containsCallExpression(node);
            }
        }
        if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
          return true;
        return false;
      };
      function isBinary(node) {
        return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
      }
      function isUnaryLike(node) {
        return n.UnaryExpression.check(node) || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(tier, i2) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i2;
        });
      });
      function containsCallExpression(node) {
        if (n.CallExpression.check(node)) {
          return true;
        }
        if (isArray.check(node)) {
          return node.some(containsCallExpression);
        }
        if (n.Node.check(node)) {
          return types17.someField(node, function(_name, child) {
            return containsCallExpression(child);
          });
        }
        return false;
      }
      NPp.canBeFirstInStatement = function() {
        var node = this.node;
        return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
      };
      NPp.firstInStatement = function() {
        return firstInStatement(this);
      };
      function firstInStatement(path3) {
        for (var node, parent2; path3.parent; path3 = path3.parent) {
          node = path3.node;
          parent2 = path3.parent.node;
          if (n.BlockStatement.check(parent2) && path3.parent.name === "body" && path3.name === 0) {
            if (parent2.body[0] !== node) {
              throw new Error("Nodes must be equal");
            }
            return true;
          }
          if (n.ExpressionStatement.check(parent2) && path3.name === "expression") {
            if (parent2.expression !== node) {
              throw new Error("Nodes must be equal");
            }
            return true;
          }
          if (n.SequenceExpression.check(parent2) && path3.parent.name === "expressions" && path3.name === 0) {
            if (parent2.expressions[0] !== node) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.CallExpression.check(parent2) && path3.name === "callee") {
            if (parent2.callee !== node) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.MemberExpression.check(parent2) && path3.name === "object") {
            if (parent2.object !== node) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.ConditionalExpression.check(parent2) && path3.name === "test") {
            if (parent2.test !== node) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (isBinary(parent2) && path3.name === "left") {
            if (parent2.left !== node) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.UnaryExpression.check(parent2) && !parent2.prefix && path3.name === "argument") {
            if (parent2.argument !== node) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          return false;
        }
        return true;
      }
      function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
          var declarations = remainingNodePath.get("declarations").value;
          if (!declarations || declarations.length === 0) {
            return remainingNodePath.prune();
          }
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
          if (!remainingNodePath.get("expression").value) {
            return remainingNodePath.prune();
          }
        } else if (n.IfStatement.check(remainingNodePath.node)) {
          cleanUpIfStatementAfterPrune(remainingNodePath);
        }
        return remainingNodePath;
      }
      function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get("test").value;
        var alternate = ifStatement.get("alternate").value;
        var consequent = ifStatement.get("consequent").value;
        if (!consequent && !alternate) {
          var testExpressionStatement = b2.expressionStatement(testExpression);
          ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
          var negatedTestExpression = b2.unaryExpression("!", testExpression, true);
          if (n.UnaryExpression.check(testExpression) && testExpression.operator === "!") {
            negatedTestExpression = testExpression.argument;
          }
          ifStatement.get("test").replace(negatedTestExpression);
          ifStatement.get("consequent").replace(alternate);
          ifStatement.get("alternate").replace();
        }
      }
      return NodePath;
    }
    exports.default = nodePathPlugin;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/path-visitor.js
var require_path_visitor = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/path-visitor.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    var node_path_1 = tslib_1.__importDefault(require_node_path());
    var shared_1 = require_shared();
    var hasOwn = Object.prototype.hasOwnProperty;
    function pathVisitorPlugin(fork) {
      var types17 = fork.use(types_1.default);
      var NodePath = fork.use(node_path_1.default);
      var isArray = types17.builtInTypes.array;
      var isObject2 = types17.builtInTypes.object;
      var isFunction = types17.builtInTypes.function;
      var undefined2;
      var PathVisitor = function PathVisitor2() {
        if (!(this instanceof PathVisitor2)) {
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        }
        this._reusableContextStack = [];
        this._methodNameTable = computeMethodNameTable(this);
        this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line");
        this.Context = makeContextConstructor(this);
        this._visiting = false;
        this._changeReported = false;
      };
      function computeMethodNameTable(visitor) {
        var typeNames = /* @__PURE__ */ Object.create(null);
        for (var methodName in visitor) {
          if (/^visit[A-Z]/.test(methodName)) {
            typeNames[methodName.slice("visit".length)] = true;
          }
        }
        var supertypeTable = types17.computeSupertypeLookupTable(typeNames);
        var methodNameTable = /* @__PURE__ */ Object.create(null);
        var typeNameKeys = Object.keys(supertypeTable);
        var typeNameCount = typeNameKeys.length;
        for (var i2 = 0; i2 < typeNameCount; ++i2) {
          var typeName = typeNameKeys[i2];
          methodName = "visit" + supertypeTable[typeName];
          if (isFunction.check(visitor[methodName])) {
            methodNameTable[typeName] = methodName;
          }
        }
        return methodNameTable;
      }
      PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
        if (methods instanceof PathVisitor) {
          return methods;
        }
        if (!isObject2.check(methods)) {
          return new PathVisitor();
        }
        var Visitor = function Visitor2() {
          if (!(this instanceof Visitor2)) {
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          }
          PathVisitor.call(this);
        };
        var Vp = Visitor.prototype = Object.create(PVp);
        Vp.constructor = Visitor;
        extend(Vp, methods);
        extend(Visitor, PathVisitor);
        isFunction.assert(Visitor.fromMethodsObject);
        isFunction.assert(Visitor.visit);
        return new Visitor();
      };
      function extend(target, source) {
        for (var property in source) {
          if (hasOwn.call(source, property)) {
            target[property] = source[property];
          }
        }
        return target;
      }
      PathVisitor.visit = function visit19(node, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node);
      };
      var PVp = PathVisitor.prototype;
      PVp.visit = function() {
        if (this._visiting) {
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        }
        this._visiting = true;
        this._changeReported = false;
        this._abortRequested = false;
        var argc = arguments.length;
        var args = new Array(argc);
        for (var i2 = 0; i2 < argc; ++i2) {
          args[i2] = arguments[i2];
        }
        if (!(args[0] instanceof NodePath)) {
          args[0] = new NodePath({ root: args[0] }).get("root");
        }
        this.reset.apply(this, args);
        var didNotThrow;
        try {
          var root = this.visitWithoutReset(args[0]);
          didNotThrow = true;
        } finally {
          this._visiting = false;
          if (!didNotThrow && this._abortRequested) {
            return args[0].value;
          }
        }
        return root;
      };
      PVp.AbortRequest = function AbortRequest() {
      };
      PVp.abort = function() {
        var visitor = this;
        visitor._abortRequested = true;
        var request = new visitor.AbortRequest();
        request.cancel = function() {
          visitor._abortRequested = false;
        };
        throw request;
      };
      PVp.reset = function(_path) {
      };
      PVp.visitWithoutReset = function(path3) {
        if (this instanceof this.Context) {
          return this.visitor.visitWithoutReset(path3);
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        var value = path3.value;
        var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
        if (methodName) {
          var context = this.acquireContext(path3);
          try {
            return context.invokeVisitorMethod(methodName);
          } finally {
            this.releaseContext(context);
          }
        } else {
          return visitChildren(path3, this);
        }
      };
      function visitChildren(path3, visitor) {
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(visitor instanceof PathVisitor)) {
          throw new Error("");
        }
        var value = path3.value;
        if (isArray.check(value)) {
          path3.each(visitor.visitWithoutReset, visitor);
        } else if (!isObject2.check(value)) {
        } else {
          var childNames = types17.getFieldNames(value);
          if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
            childNames.push("comments");
          }
          var childCount = childNames.length;
          var childPaths = [];
          for (var i2 = 0; i2 < childCount; ++i2) {
            var childName = childNames[i2];
            if (!hasOwn.call(value, childName)) {
              value[childName] = types17.getFieldValue(value, childName);
            }
            childPaths.push(path3.get(childName));
          }
          for (var i2 = 0; i2 < childCount; ++i2) {
            visitor.visitWithoutReset(childPaths[i2]);
          }
        }
        return path3.value;
      }
      PVp.acquireContext = function(path3) {
        if (this._reusableContextStack.length === 0) {
          return new this.Context(path3);
        }
        return this._reusableContextStack.pop().reset(path3);
      };
      PVp.releaseContext = function(context) {
        if (!(context instanceof this.Context)) {
          throw new Error("");
        }
        this._reusableContextStack.push(context);
        context.currentPath = null;
      };
      PVp.reportChanged = function() {
        this._changeReported = true;
      };
      PVp.wasChangeReported = function() {
        return this._changeReported;
      };
      function makeContextConstructor(visitor) {
        function Context(path3) {
          if (!(this instanceof Context)) {
            throw new Error("");
          }
          if (!(this instanceof PathVisitor)) {
            throw new Error("");
          }
          if (!(path3 instanceof NodePath)) {
            throw new Error("");
          }
          Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: false,
            enumerable: true,
            configurable: false
          });
          this.currentPath = path3;
          this.needToCallTraverse = true;
          Object.seal(this);
        }
        if (!(visitor instanceof PathVisitor)) {
          throw new Error("");
        }
        var Cp = Context.prototype = Object.create(visitor);
        Cp.constructor = Context;
        extend(Cp, sharedContextProtoMethods);
        return Context;
      }
      var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
      sharedContextProtoMethods.reset = function reset4(path3) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        this.currentPath = path3;
        this.needToCallTraverse = true;
        return this;
      };
      sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        var result = this.visitor[methodName].call(this, this.currentPath);
        if (result === false) {
          this.needToCallTraverse = false;
        } else if (result !== undefined2) {
          this.currentPath = this.currentPath.replace(result)[0];
          if (this.needToCallTraverse) {
            this.traverse(this.currentPath);
          }
        }
        if (this.needToCallTraverse !== false) {
          throw new Error("Must either call this.traverse or return false in " + methodName);
        }
        var path3 = this.currentPath;
        return path3 && path3.value;
      };
      sharedContextProtoMethods.traverse = function traverse(path3, newVisitor) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        this.needToCallTraverse = false;
        return visitChildren(path3, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
      };
      sharedContextProtoMethods.visit = function visit19(path3, newVisitor) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        this.needToCallTraverse = false;
        return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path3);
      };
      sharedContextProtoMethods.reportChanged = function reportChanged() {
        this.visitor.reportChanged();
      };
      sharedContextProtoMethods.abort = function abort() {
        this.needToCallTraverse = false;
        this.visitor.abort();
      };
      return PathVisitor;
    }
    exports.default = pathVisitorPlugin;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/equiv.js
var require_equiv = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/equiv.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var types_1 = tslib_1.__importDefault(require_types());
    function default_1(fork) {
      var types17 = fork.use(types_1.default);
      var getFieldNames = types17.getFieldNames;
      var getFieldValue = types17.getFieldValue;
      var isArray = types17.builtInTypes.array;
      var isObject2 = types17.builtInTypes.object;
      var isDate = types17.builtInTypes.Date;
      var isRegExp = types17.builtInTypes.RegExp;
      var hasOwn = Object.prototype.hasOwnProperty;
      function astNodesAreEquivalent(a2, b2, problemPath) {
        if (isArray.check(problemPath)) {
          problemPath.length = 0;
        } else {
          problemPath = null;
        }
        return areEquivalent(a2, b2, problemPath);
      }
      astNodesAreEquivalent.assert = function(a2, b2) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a2, b2, problemPath)) {
          if (problemPath.length === 0) {
            if (a2 !== b2) {
              throw new Error("Nodes must be equal");
            }
          } else {
            throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
          }
        }
      };
      function subscriptForProperty(property) {
        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
          return "." + property;
        }
        return "[" + JSON.stringify(property) + "]";
      }
      function areEquivalent(a2, b2, problemPath) {
        if (a2 === b2) {
          return true;
        }
        if (isArray.check(a2)) {
          return arraysAreEquivalent(a2, b2, problemPath);
        }
        if (isObject2.check(a2)) {
          return objectsAreEquivalent(a2, b2, problemPath);
        }
        if (isDate.check(a2)) {
          return isDate.check(b2) && +a2 === +b2;
        }
        if (isRegExp.check(a2)) {
          return isRegExp.check(b2) && (a2.source === b2.source && a2.global === b2.global && a2.multiline === b2.multiline && a2.ignoreCase === b2.ignoreCase);
        }
        return a2 == b2;
      }
      function arraysAreEquivalent(a2, b2, problemPath) {
        isArray.assert(a2);
        var aLength = a2.length;
        if (!isArray.check(b2) || b2.length !== aLength) {
          if (problemPath) {
            problemPath.push("length");
          }
          return false;
        }
        for (var i2 = 0; i2 < aLength; ++i2) {
          if (problemPath) {
            problemPath.push(i2);
          }
          if (i2 in a2 !== i2 in b2) {
            return false;
          }
          if (!areEquivalent(a2[i2], b2[i2], problemPath)) {
            return false;
          }
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== i2) {
              throw new Error("" + problemPathTail);
            }
          }
        }
        return true;
      }
      function objectsAreEquivalent(a2, b2, problemPath) {
        isObject2.assert(a2);
        if (!isObject2.check(b2)) {
          return false;
        }
        if (a2.type !== b2.type) {
          if (problemPath) {
            problemPath.push("type");
          }
          return false;
        }
        var aNames = getFieldNames(a2);
        var aNameCount = aNames.length;
        var bNames = getFieldNames(b2);
        var bNameCount = bNames.length;
        if (aNameCount === bNameCount) {
          for (var i2 = 0; i2 < aNameCount; ++i2) {
            var name = aNames[i2];
            var aChild = getFieldValue(a2, name);
            var bChild = getFieldValue(b2, name);
            if (problemPath) {
              problemPath.push(name);
            }
            if (!areEquivalent(aChild, bChild, problemPath)) {
              return false;
            }
            if (problemPath) {
              var problemPathTail = problemPath.pop();
              if (problemPathTail !== name) {
                throw new Error("" + problemPathTail);
              }
            }
          }
          return true;
        }
        if (!problemPath) {
          return false;
        }
        var seenNames = /* @__PURE__ */ Object.create(null);
        for (i2 = 0; i2 < aNameCount; ++i2) {
          seenNames[aNames[i2]] = true;
        }
        for (i2 = 0; i2 < bNameCount; ++i2) {
          name = bNames[i2];
          if (!hasOwn.call(seenNames, name)) {
            problemPath.push(name);
            return false;
          }
          delete seenNames[name];
        }
        for (name in seenNames) {
          problemPath.push(name);
          break;
        }
        return false;
      }
      return astNodesAreEquivalent;
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/fork.js
var require_fork = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/fork.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    var path_visitor_1 = tslib_1.__importDefault(require_path_visitor());
    var equiv_1 = tslib_1.__importDefault(require_equiv());
    var path_1 = tslib_1.__importDefault(require_path2());
    var node_path_1 = tslib_1.__importDefault(require_node_path());
    var shared_1 = require_shared();
    function default_1(plugins) {
      var fork = createFork();
      var types17 = fork.use(types_1.default);
      plugins.forEach(fork.use);
      types17.finalize();
      var PathVisitor = fork.use(path_visitor_1.default);
      return {
        Type: types17.Type,
        builtInTypes: types17.builtInTypes,
        namedTypes: types17.namedTypes,
        builders: types17.builders,
        defineMethod: types17.defineMethod,
        getFieldNames: types17.getFieldNames,
        getFieldValue: types17.getFieldValue,
        eachField: types17.eachField,
        someField: types17.someField,
        getSupertypeNames: types17.getSupertypeNames,
        getBuilderName: types17.getBuilderName,
        astNodesAreEquivalent: fork.use(equiv_1.default),
        finalize: types17.finalize,
        Path: fork.use(path_1.default),
        NodePath: fork.use(node_path_1.default),
        PathVisitor,
        use: fork.use,
        visit: PathVisitor.visit
      };
    }
    exports.default = default_1;
    function createFork() {
      var used = [];
      var usedResult = [];
      function use(plugin2) {
        var idx = used.indexOf(plugin2);
        if (idx === -1) {
          idx = used.length;
          used.push(plugin2);
          usedResult[idx] = plugin2(fork);
        }
        return usedResult[idx];
      }
      var fork = { use };
      return fork;
    }
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/core.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared_1 = require_shared();
    function default_1() {
      return {
        BinaryOperators: [
          "==",
          "!=",
          "===",
          "!==",
          "<",
          "<=",
          ">",
          ">=",
          "<<",
          ">>",
          ">>>",
          "+",
          "-",
          "*",
          "/",
          "%",
          "&",
          "|",
          "^",
          "in",
          "instanceof"
        ],
        AssignmentOperators: [
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "|=",
          "^=",
          "&="
        ],
        LogicalOperators: [
          "||",
          "&&"
        ]
      };
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/es2016.js
var require_es2016 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/es2016.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var core_1 = tslib_1.__importDefault(require_core());
    function default_1(fork) {
      var result = fork.use(core_1.default);
      if (result.BinaryOperators.indexOf("**") < 0) {
        result.BinaryOperators.push("**");
      }
      if (result.AssignmentOperators.indexOf("**=") < 0) {
        result.AssignmentOperators.push("**=");
      }
      return result;
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/es2020.js
var require_es2020 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/es2020.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var es2016_1 = tslib_1.__importDefault(require_es2016());
    function default_1(fork) {
      var result = fork.use(es2016_1.default);
      if (result.LogicalOperators.indexOf("??") < 0) {
        result.LogicalOperators.push("??");
      }
      return result;
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/es2021.js
var require_es2021 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/operators/es2021.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var shared_1 = require_shared();
    var es2020_1 = tslib_1.__importDefault(require_es2020());
    function default_1(fork) {
      var result = fork.use(es2020_1.default);
      result.LogicalOperators.forEach(function(op) {
        var assignOp = op + "=";
        if (result.AssignmentOperators.indexOf(assignOp) < 0) {
          result.AssignmentOperators.push(assignOp);
        }
      });
      return result;
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/core.js
var require_core2 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/core.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = tslib_1.__importDefault(require_core());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      var types17 = fork.use(types_1.default);
      var Type = types17.Type;
      var def = Type.def;
      var or = Type.or;
      var shared = fork.use(shared_1.default);
      var defaults = shared.defaults;
      var geq = shared.geq;
      var _a = fork.use(core_1.default), BinaryOperators = _a.BinaryOperators, AssignmentOperators = _a.AssignmentOperators, LogicalOperators = _a.LogicalOperators;
      def("Printable").field("loc", or(def("SourceLocation"), null), defaults["null"], true);
      def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults["null"], true);
      def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults["null"]);
      def("Position").field("line", geq(1)).field("column", geq(0));
      def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults["null"]);
      def("Program").bases("Node").build("body").field("body", [def("Statement")]);
      def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]);
      def("Statement").bases("Node");
      def("EmptyStatement").bases("Statement").build();
      def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
      def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
      def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults["null"]);
      def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
      def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
      def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
      def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
      def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults["false"]);
      def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
      def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
      def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, true).field("guardedHandlers", [def("CatchClause")], defaults.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults["null"]);
      def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults["null"]).field("body", def("BlockStatement"));
      def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
      def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
      def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
      def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
      def("DebuggerStatement").bases("Statement").build();
      def("Declaration").bases("Statement");
      def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
      def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
      def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
      def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults["null"]);
      def("Expression").bases("Node");
      def("ThisExpression").bases("Expression").build();
      def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
      def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
      def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
      var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
      def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults["true"]);
      var BinaryOperator = or.apply(void 0, BinaryOperators);
      def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
      var AssignmentOperator = or.apply(void 0, AssignmentOperators);
      def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
      var UpdateOperator = or("++", "--");
      def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
      var LogicalOperator = or.apply(void 0, LogicalOperators);
      def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
      def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
      def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
      def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
      def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
        var type = this.property.type;
        if (type === "Literal" || type === "MemberExpression" || type === "BinaryExpression") {
          return true;
        }
        return false;
      });
      def("Pattern").bases("Node");
      def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
      def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults["false"]);
      def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp, BigInt));
      def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults["true"]).field("trailing", Boolean, defaults["false"]);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es6.js
var require_es6 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es6.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = tslib_1.__importDefault(require_core2());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(core_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      def("Function").field("generator", Boolean, defaults["false"]).field("expression", Boolean, defaults["false"]).field("defaults", [or(def("Expression"), null)], defaults.emptyArray).field("rest", or(def("Identifier"), null), defaults["null"]);
      def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field(
        "typeAnnotation",
        or(def("TypeAnnotation"), def("TSTypeAnnotation"), null),
        defaults["null"]
      );
      def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
      def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def("Identifier"), null));
      def("FunctionExpression").build("id", "params", "body", "generator", "expression");
      def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults["false"]);
      def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
      def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults["false"]);
      def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
      def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
      def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
      def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults["false"]).field("shorthand", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]);
      def("ObjectProperty").field("shorthand", Boolean, defaults["false"]);
      def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults["false"]);
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
      def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
      def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
      def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
      def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
      def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
      def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
      def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("StaticBlock"));
      def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
      def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
      def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]);
      def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]);
      def("Super").bases("Expression").build();
      def("Specifier").bases("Node");
      def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults["null"]).field("id", or(def("Identifier"), null), defaults["null"]).field("name", or(def("Identifier"), null), defaults["null"]);
      def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
      def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
      def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
      def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
        return "value";
      });
      def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
      def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
      def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
      def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal"));
      def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
      def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
      def("TemplateElement").bases("Node").build("value", "tail").field("value", { "cooked": String, "raw": String }).field("tail", Boolean);
      def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2016.js
var require_es20162 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2016.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2016_1 = tslib_1.__importDefault(require_es2016());
    var es6_1 = tslib_1.__importDefault(require_es6());
    var shared_1 = require_shared();
    function default_1(fork) {
      fork.use(es2016_1.default);
      fork.use(es6_1.default);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2017.js
var require_es2017 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2017.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2016_1 = tslib_1.__importDefault(require_es20162());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es2016_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var defaults = fork.use(shared_1.default).defaults;
      def("Function").field("async", Boolean, defaults["false"]);
      def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2018.js
var require_es2018 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2018.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2017_1 = tslib_1.__importDefault(require_es2017());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es2017_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      def("ForOfStatement").field("await", Boolean, defaults["false"]);
      def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("ObjectExpression").field("properties", [or(
        def("Property"),
        def("SpreadProperty"),
        def("SpreadElement")
      )]);
      def("TemplateElement").field("value", { "cooked": or(String, null), "raw": String });
      def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
      def("ObjectPattern").field("properties", [or(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2019.js
var require_es2019 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2019.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2018_1 = tslib_1.__importDefault(require_es2018());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es2018_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      def("CatchClause").field("param", or(def("Pattern"), null), defaults["null"]);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2020.js
var require_es20202 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2020.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2020_1 = tslib_1.__importDefault(require_es2020());
    var es2019_1 = tslib_1.__importDefault(require_es2019());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es2020_1.default);
      fork.use(es2019_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var shared = fork.use(shared_1.default);
      var defaults = shared.defaults;
      def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
      def("ExportAllDeclaration").bases("Declaration").build("source", "exported").field("source", def("Literal")).field("exported", or(def("Identifier"), null, void 0), defaults["null"]);
      def("ChainElement").bases("Node").field("optional", Boolean, defaults["false"]);
      def("CallExpression").bases("Expression", "ChainElement");
      def("MemberExpression").bases("Expression", "ChainElement");
      def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement"));
      def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults["true"]);
      def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults["true"]);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2021.js
var require_es20212 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2021.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2021_1 = tslib_1.__importDefault(require_es2021());
    var es2020_1 = tslib_1.__importDefault(require_es20202());
    var shared_1 = require_shared();
    function default_1(fork) {
      fork.use(es2021_1.default);
      fork.use(es2020_1.default);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2022.js
var require_es2022 = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es2022.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es2021_1 = tslib_1.__importDefault(require_es20212());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = require_shared();
    function default_1(fork) {
      fork.use(es2021_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      def("StaticBlock").bases("Declaration").build("body").field("body", [def("Statement")]);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es-proposals.js
var require_es_proposals = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/es-proposals.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    var es2022_1 = tslib_1.__importDefault(require_es2022());
    function default_1(fork) {
      fork.use(es2022_1.default);
      var types17 = fork.use(types_1.default);
      var Type = types17.Type;
      var def = types17.Type.def;
      var or = Type.or;
      var shared = fork.use(shared_1.default);
      var defaults = shared.defaults;
      def("AwaitExpression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults["false"]);
      def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
      def("Property").field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
      def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults["null"]);
      def("ImportAttribute").bases("Node").build("key", "value").field("key", or(def("Identifier"), def("Literal"))).field("value", def("Expression"));
      [
        "ImportDeclaration",
        "ExportAllDeclaration",
        "ExportNamedDeclaration"
      ].forEach(function(decl) {
        def(decl).field("assertions", [def("ImportAttribute")], defaults.emptyArray);
      });
      def("RecordExpression").bases("Expression").build("properties").field("properties", [or(def("ObjectProperty"), def("ObjectMethod"), def("SpreadElement"))]);
      def("TupleExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), def("SpreadElement"), null)]);
      def("ModuleExpression").bases("Node").build("body").field("body", def("Program"));
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/jsx.js
var require_jsx = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/jsx.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es_proposals_1 = tslib_1.__importDefault(require_es_proposals());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es_proposals_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(
        def("Literal"),
        def("JSXExpressionContainer"),
        def("JSXElement"),
        def("JSXFragment"),
        null
      ), defaults["null"]);
      def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
      def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
      def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults.false);
      var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
      def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
      var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
      def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or(def("Expression"), def("JSXEmptyExpression")));
      var JSXChildren = [or(
        def("JSXText"),
        def("JSXExpressionContainer"),
        def("JSXSpreadChild"),
        def("JSXElement"),
        def("JSXFragment"),
        def("Literal")
      )];
      def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults["null"]).field("children", JSXChildren, defaults.emptyArray).field("name", JSXElementName, function() {
        return this.openingElement.name;
      }, true).field("selfClosing", Boolean, function() {
        return this.openingElement.selfClosing;
      }, true).field("attributes", JSXAttributes, function() {
        return this.openingElement.attributes;
      }, true);
      def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults.emptyArray).field("selfClosing", Boolean, defaults["false"]);
      def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
      def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults.emptyArray);
      def("JSXOpeningFragment").bases("Node").build();
      def("JSXClosingFragment").bases("Node").build();
      def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
        return this.value;
      });
      def("JSXEmptyExpression").bases("Node").build();
      def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/type-annotations.js
var require_type_annotations = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/type-annotations.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
      var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
      def("Identifier").field("typeAnnotation", TypeAnnotation, defaults["null"]);
      def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults["null"]);
      def("Function").field("returnType", TypeAnnotation, defaults["null"]).field("typeParameters", TypeParamDecl, defaults["null"]);
      def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults["false"]).field("typeAnnotation", TypeAnnotation, defaults["null"]);
      [
        "ClassDeclaration",
        "ClassExpression"
      ].forEach(function(typeName) {
        def(typeName).field("typeParameters", TypeParamDecl, defaults["null"]).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults["null"]).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults.emptyArray);
      });
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/flow.js
var require_flow = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/flow.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es_proposals_1 = tslib_1.__importDefault(require_es_proposals());
    var type_annotations_1 = tslib_1.__importDefault(require_type_annotations());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es_proposals_1.default);
      fork.use(type_annotations_1.default);
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      def("Flow").bases("Node");
      def("FlowType").bases("Flow");
      def("AnyTypeAnnotation").bases("FlowType").build();
      def("EmptyTypeAnnotation").bases("FlowType").build();
      def("MixedTypeAnnotation").bases("FlowType").build();
      def("VoidTypeAnnotation").bases("FlowType").build();
      def("SymbolTypeAnnotation").bases("FlowType").build();
      def("NumberTypeAnnotation").bases("FlowType").build();
      def("BigIntTypeAnnotation").bases("FlowType").build();
      def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
      def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
      def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String);
      def("StringTypeAnnotation").bases("FlowType").build();
      def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
      def("BooleanTypeAnnotation").bases("FlowType").build();
      def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
      def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
      def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
      def("NullLiteralTypeAnnotation").bases("FlowType").build();
      def("NullTypeAnnotation").bases("FlowType").build();
      def("ThisTypeAnnotation").bases("FlowType").build();
      def("ExistsTypeAnnotation").bases("FlowType").build();
      def("ExistentialTypeParam").bases("FlowType").build();
      def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
      def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
      def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
      def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
        or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))
      ]).field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray).field("inexact", or(Boolean, void 0), defaults["undefined"]).field("exact", Boolean, defaults["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults.emptyArray);
      def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
      var LegacyVariance = or(def("Variance"), "plus", "minus", null);
      def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults["null"]);
      def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults["null"]).field("static", Boolean, defaults["false"]);
      def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults["false"]);
      def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
      def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
      def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
      def("IndexedAccessType").bases("FlowType").build("objectType", "indexType").field("objectType", def("FlowType")).field("indexType", def("FlowType"));
      def("OptionalIndexedAccessType").bases("FlowType").build("objectType", "indexType", "optional").field("objectType", def("FlowType")).field("indexType", def("FlowType")).field("optional", Boolean);
      def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
      def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
      def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
      def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
      def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
      def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults["null"]).field("bound", or(def("TypeAnnotation"), null), defaults["null"]).field("default", or(def("FlowType"), null), defaults["null"]);
      def("ClassProperty").field("variance", LegacyVariance, defaults["null"]);
      def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults["null"]).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
      def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults["null"]);
      def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
      def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
      def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
      def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
      def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
      def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or(def("FlowType"), null));
      def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or(def("FlowType"), null));
      def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
      def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
      def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or(def("FlowPredicate"), null), defaults["null"]);
      def("DeclareClass").bases("InterfaceDeclaration").build("id");
      def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
      def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
      def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("FlowType"),
        def("TypeAlias"),
        def("DeclareOpaqueType"),
        def("InterfaceDeclaration"),
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
      def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults["null"]);
      def("ImportDeclaration").field("importKind", or("value", "type", "typeof"), function() {
        return "value";
      });
      def("FlowPredicate").bases("Flow");
      def("InferredPredicate").bases("FlowPredicate").build();
      def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
      def("Function").field("predicate", or(def("FlowPredicate"), null), defaults["null"]);
      def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults["null"]);
      def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults["null"]);
      def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody")));
      def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean);
      def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean);
      def("EnumStringBody").build("members", "explicitType").field("members", or([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean);
      def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]);
      def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or(def("Literal"), Boolean));
      def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
      def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal"));
      def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/esprima.js
var require_esprima = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/esprima.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es_proposals_1 = tslib_1.__importDefault(require_es_proposals());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(es_proposals_1.default);
      var types17 = fork.use(types_1.default);
      var defaults = fork.use(shared_1.default).defaults;
      var def = types17.Type.def;
      var or = types17.Type.or;
      def("VariableDeclaration").field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier")
      )]);
      def("Property").field("value", or(
        def("Expression"),
        def("Pattern")
      ));
      def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
      def("ObjectPattern").field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty")
      )]);
      def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
      def("ExportBatchSpecifier").bases("Specifier").build();
      def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("Declaration"),
        def("Expression"),
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
      def("Block").bases("Comment").build("value", "leading", "trailing");
      def("Line").bases("Comment").build("value", "leading", "trailing");
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/babel-core.js
var require_babel_core = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/babel-core.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var es_proposals_1 = tslib_1.__importDefault(require_es_proposals());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      var _a, _b, _c, _d, _e;
      fork.use(es_proposals_1.default);
      var types17 = fork.use(types_1.default);
      var defaults = fork.use(shared_1.default).defaults;
      var def = types17.Type.def;
      var or = types17.Type.or;
      var isUndefined = types17.builtInTypes.undefined;
      def("Noop").bases("Statement").build();
      def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
      def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
      def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
      def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
      def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
      def("CommentBlock").bases("Comment").build("value", "leading", "trailing");
      def("CommentLine").bases("Comment").build("value", "leading", "trailing");
      def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
      def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults["use strict"]);
      def("InterpreterDirective").bases("Node").build("value").field("value", String);
      def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray);
      def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults["null"]);
      function makeLiteralExtra(rawValueType, toRaw) {
        if (rawValueType === void 0) {
          rawValueType = String;
        }
        return [
          "extra",
          {
            rawValue: rawValueType,
            raw: String
          },
          function getDefault() {
            var value = types17.getFieldValue(this, "value");
            return {
              rawValue: value,
              raw: toRaw ? toRaw(value) : String(value)
            };
          }
        ];
      }
      (_a = def("StringLiteral").bases("Literal").build("value").field("value", String)).field.apply(_a, makeLiteralExtra(String, function(val) {
        return JSON.stringify(val);
      }));
      (_b = def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults["null"])).field.apply(_b, makeLiteralExtra(Number));
      (_c = def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number))).field.apply(_c, makeLiteralExtra(String, function(val) {
        return val + "n";
      }));
      (_d = def("DecimalLiteral").bases("Literal").build("value").field("value", String)).field.apply(_d, makeLiteralExtra(String, function(val) {
        return val + "m";
      }));
      def("NullLiteral").bases("Literal").build().field("value", null, defaults["null"]);
      def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
      (_e = def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
        return new RegExp(this.pattern, this.flags);
      })).field.apply(_e, makeLiteralExtra(or(RegExp, isUndefined), function(exp) {
        return "/".concat(exp.pattern, "/").concat(exp.flags || "");
      })).field("regex", {
        pattern: String,
        flags: String
      }, function() {
        return {
          pattern: this.pattern,
          flags: this.flags
        };
      });
      var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
      def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field(
        "accessibility",
        or(def("Literal"), null),
        defaults["null"]
      ).field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field(
        "accessibility",
        or(def("Literal"), null),
        defaults["null"]
      ).field("computed", Boolean, defaults["false"]);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("ClassAccessorProperty"), def("StaticBlock"));
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
      def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression")));
      def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
      def("ClassAccessorProperty").bases("Declaration").build("key", "value", "decorators", "computed", "static").field("key", or(
        def("Literal"),
        def("Identifier"),
        def("PrivateName"),
        def("Expression")
      )).field("value", or(def("Expression"), null), defaults["null"]);
      [
        "ClassMethod",
        "ClassPrivateMethod"
      ].forEach(function(typeName) {
        def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
          return "method";
        }).field("body", def("BlockStatement")).field("access", or("public", "private", "protected", null), defaults["null"]);
      });
      [
        "ClassMethod",
        "ClassPrivateMethod",
        "ClassAccessorProperty"
      ].forEach(function(typeName) {
        def(typeName).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]).field("abstract", Boolean, defaults["false"]).field("accessibility", or("public", "private", "protected", null), defaults["null"]).field("decorators", or([def("Decorator")], null), defaults["null"]).field("definite", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("override", Boolean, defaults["false"]).field("readonly", Boolean, defaults["false"]);
      });
      var ObjectPatternProperty = or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty"),
        def("ObjectProperty"),
        def("RestProperty"),
        def("RestElement")
      );
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
      def("Import").bases("Expression").build();
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/babel.js
var require_babel = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/babel.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var types_1 = tslib_1.__importDefault(require_types());
    var babel_core_1 = tslib_1.__importDefault(require_babel_core());
    var flow_1 = tslib_1.__importDefault(require_flow());
    var shared_1 = require_shared();
    function default_1(fork) {
      var types17 = fork.use(types_1.default);
      var def = types17.Type.def;
      fork.use(babel_core_1.default);
      fork.use(flow_1.default);
      def("V8IntrinsicIdentifier").bases("Expression").build("name").field("name", String);
      def("TopicReference").bases("Expression").build();
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/typescript.js
var require_typescript = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/def/typescript.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var babel_core_1 = tslib_1.__importDefault(require_babel_core());
    var type_annotations_1 = tslib_1.__importDefault(require_type_annotations());
    var types_1 = tslib_1.__importDefault(require_types());
    var shared_1 = tslib_1.__importStar(require_shared());
    function default_1(fork) {
      fork.use(babel_core_1.default);
      fork.use(type_annotations_1.default);
      var types17 = fork.use(types_1.default);
      var n = types17.namedTypes;
      var def = types17.Type.def;
      var or = types17.Type.or;
      var defaults = fork.use(shared_1.default).defaults;
      var StringLiteral = types17.Type.from(function(value, deep) {
        if (n.StringLiteral && n.StringLiteral.check(value, deep)) {
          return true;
        }
        if (n.Literal && n.Literal.check(value, deep) && typeof value.value === "string") {
          return true;
        }
        return false;
      }, "StringLiteral");
      def("TSType").bases("Node");
      var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
      def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
      def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults["null"]);
      def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults["null"]);
      def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults["null"]);
      def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
      def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults["null"]);
      def("TSTypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType"));
      def("TSSatisfiesExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType"));
      def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
      [
        "TSAnyKeyword",
        "TSBigIntKeyword",
        "TSBooleanKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword",
        "TSIntrinsicKeyword",
        "TSThisType"
      ].forEach(function(keywordType) {
        def(keywordType).bases("TSType").build();
      });
      def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
      def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression"), def("BigIntLiteral")));
      def("TemplateLiteral").field("expressions", or([def("Expression")], [def("TSType")]));
      [
        "TSUnionType",
        "TSIntersectionType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
      });
      def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
      def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
      def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
      [
        "TSFunctionType",
        "TSConstructorType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
      });
      def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("id", or(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        null
      ), defaults["null"]);
      def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults["false"]).field("accessibility", or("public", "private", "protected", void 0), defaults["undefined"]).field("static", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("key", or(
        def("Identifier"),
        def("StringLiteral"),
        def("NumericLiteral"),
        def("Expression")
      )).field("kind", or("get", "set", "method", "constructor"), function getDefault() {
        return "method";
      }).field(
        "access",
        or("public", "private", "protected", void 0),
        defaults["undefined"]
      ).field("decorators", or([def("Decorator")], null), defaults["null"]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        null
      ), defaults["null"]);
      def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults["false"]).field("typeAnnotation", or(def("TSType"), null), defaults["null"]);
      def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]);
      def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults["false"]).field("elementType", def("TSType"));
      def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
      def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
      def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation")));
      def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults["false"]);
      def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("readonly", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("initializer", or(def("Expression"), null), defaults["null"]);
      def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("parameters", ParametersType);
      def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults["null"]).field("asserts", Boolean, defaults["false"]);
      [
        "TSCallSignatureDeclaration",
        "TSConstructSignatureDeclaration"
      ].forEach(function(typeName) {
        def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
      });
      def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults["null"]);
      def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
      var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
      def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
      def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", or(def("Identifier"), String)).field("constraint", or(def("TSType"), void 0), defaults["undefined"]).field("default", or(def("TSType"), void 0), defaults["undefined"]);
      def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults["null"]);
      def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
      def("TSInstantiationExpression").bases("Expression", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", def("Expression"));
      def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
      def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults["false"]).field("declare", Boolean, defaults["false"]).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults["null"]);
      def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults["false"]).field("typeAnnotation", def("TSType"));
      def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
      def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults["false"]).field("global", Boolean, defaults["false"]).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults["null"]);
      def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults["undefined"]);
      def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults["false"]).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference")));
      def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
      def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
      def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
      def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
      def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
      def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults["false"]).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults["null"]).field("body", def("TSInterfaceBody"));
      def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults["undefined"]).field("readonly", Boolean, defaults["false"]).field("parameter", or(def("Identifier"), def("AssignmentPattern")));
      def("ClassProperty").field(
        "access",
        or("public", "private", "protected", void 0),
        defaults["undefined"]
      );
      def("ClassAccessorProperty").bases("Declaration", "TSHasOptionalTypeAnnotation");
      def("ClassBody").field("body", [or(
        def("MethodDefinition"),
        def("VariableDeclarator"),
        def("ClassPropertyDefinition"),
        def("ClassProperty"),
        def("ClassPrivateProperty"),
        def("ClassAccessorProperty"),
        def("ClassMethod"),
        def("ClassPrivateMethod"),
        def("StaticBlock"),
        def("TSDeclareMethod"),
        TSTypeMember
      )]);
    }
    exports.default = default_1;
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/gen/namedTypes.js
var require_namedTypes = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/gen/namedTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namedTypes = void 0;
    var namedTypes;
    (function(namedTypes2) {
    })(namedTypes = exports.namedTypes || (exports.namedTypes = {}));
  }
});

// ../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/ast-types@0.16.1/node_modules/ast-types/lib/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.visit = exports.use = exports.Type = exports.someField = exports.PathVisitor = exports.Path = exports.NodePath = exports.namedTypes = exports.getSupertypeNames = exports.getFieldValue = exports.getFieldNames = exports.getBuilderName = exports.finalize = exports.eachField = exports.defineMethod = exports.builtInTypes = exports.builders = exports.astNodesAreEquivalent = void 0;
    var tslib_1 = require_tslib();
    var fork_1 = tslib_1.__importDefault(require_fork());
    var es_proposals_1 = tslib_1.__importDefault(require_es_proposals());
    var jsx_1 = tslib_1.__importDefault(require_jsx());
    var flow_1 = tslib_1.__importDefault(require_flow());
    var esprima_1 = tslib_1.__importDefault(require_esprima());
    var babel_1 = tslib_1.__importDefault(require_babel());
    var typescript_1 = tslib_1.__importDefault(require_typescript());
    var namedTypes_1 = require_namedTypes();
    Object.defineProperty(exports, "namedTypes", { enumerable: true, get: function() {
      return namedTypes_1.namedTypes;
    } });
    var _a = (0, fork_1.default)([
      es_proposals_1.default,
      jsx_1.default,
      flow_1.default,
      esprima_1.default,
      babel_1.default,
      typescript_1.default
    ]);
    var astNodesAreEquivalent = _a.astNodesAreEquivalent;
    var builders = _a.builders;
    var builtInTypes = _a.builtInTypes;
    var defineMethod = _a.defineMethod;
    var eachField = _a.eachField;
    var finalize = _a.finalize;
    var getBuilderName = _a.getBuilderName;
    var getFieldNames = _a.getFieldNames;
    var getFieldValue = _a.getFieldValue;
    var getSupertypeNames = _a.getSupertypeNames;
    var n = _a.namedTypes;
    var NodePath = _a.NodePath;
    var Path = _a.Path;
    var PathVisitor = _a.PathVisitor;
    var someField = _a.someField;
    var Type = _a.Type;
    var use = _a.use;
    var visit19 = _a.visit;
    exports.astNodesAreEquivalent = astNodesAreEquivalent;
    exports.builders = builders;
    exports.builtInTypes = builtInTypes;
    exports.defineMethod = defineMethod;
    exports.eachField = eachField;
    exports.finalize = finalize;
    exports.getBuilderName = getBuilderName;
    exports.getFieldNames = getFieldNames;
    exports.getFieldValue = getFieldValue;
    exports.getSupertypeNames = getSupertypeNames;
    exports.NodePath = NodePath;
    exports.Path = Path;
    exports.PathVisitor = PathVisitor;
    exports.someField = someField;
    exports.Type = Type;
    exports.use = use;
    exports.visit = visit19;
    Object.assign(namedTypes_1.namedTypes, n);
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path3 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path3 = url.path;
      }
      var isAbsolute2 = exports.isAbsolute(path3);
      var parts = path3.split(/\/+/);
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path3 = parts.join("/");
      if (path3 === "") {
        path3 = isAbsolute2 ? "/" : ".";
      }
      if (url) {
        url.path = path3;
        return urlGenerate(url);
      }
      return path3;
    }
    exports.normalize = normalize;
    function join4(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join4;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative2;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join4(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set.add(aArray[i2], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x3, y3) {
      var temp = ary[x3];
      ary[x3] = ary[y3];
      ary[y3] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p3, r3) {
      if (p3 < r3) {
        var pivotIndex = randomIntInRange(p3, r3);
        var i2 = p3 - 1;
        swap(ary, pivotIndex, r3);
        var pivot = ary[r3];
        for (var j2 = p3; j2 < r3; j2++) {
          if (comparator(ary[j2], pivot) <= 0) {
            i2 += 1;
            swap(ary, i2, j2);
          }
        }
        swap(ary, i2 + 1, j2);
        var q3 = i2 + 1;
        doQuickSort(ary, comparator, p3, q3 - 1);
        doQuickSort(ary, comparator, q3 + 1, r3);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c2 = aStr.charAt(index);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
        if (this._absoluteSources[i2] == aSource) {
          return i2;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s2, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
            sources.push(this._sections[i2].consumer.sources[j2]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
          this.prepend(aChunk[i2]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        chunk = this.children[i2];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i2;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i2 = 0; i2 < len - 1; i2++) {
          newChildren.push(this.children[i2]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i2]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        if (this.children[i2][isSourceNode]) {
          this.children[i2].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i2 = 0, len = sources.length; i2 < len; i2++) {
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTrailingCommaEnabled = exports.getParentExportDeclaration = exports.isExportDeclaration = exports.fixFaultyLocations = exports.getTrueLoc = exports.composeSourceMaps = exports.copyPos = exports.comparePos = exports.getUnionOfKeys = exports.getOption = exports.isBrowser = exports.getLineTerminator = void 0;
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var types17 = tslib_1.__importStar(require_main());
    var n = types17.namedTypes;
    var source_map_1 = tslib_1.__importDefault(require_source_map());
    var SourceMapConsumer = source_map_1.default.SourceMapConsumer;
    var SourceMapGenerator = source_map_1.default.SourceMapGenerator;
    var hasOwn = Object.prototype.hasOwnProperty;
    function getLineTerminator() {
      return isBrowser() ? "\n" : require("os").EOL || "\n";
    }
    exports.getLineTerminator = getLineTerminator;
    function isBrowser() {
      return typeof window !== "undefined" && typeof window.document !== "undefined";
    }
    exports.isBrowser = isBrowser;
    function getOption(options, key, defaultValue) {
      if (options && hasOwn.call(options, key)) {
        return options[key];
      }
      return defaultValue;
    }
    exports.getOption = getOption;
    function getUnionOfKeys() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = {};
      var argc = args.length;
      for (var i2 = 0; i2 < argc; ++i2) {
        var keys2 = Object.keys(args[i2]);
        var keyCount = keys2.length;
        for (var j2 = 0; j2 < keyCount; ++j2) {
          result[keys2[j2]] = true;
        }
      }
      return result;
    }
    exports.getUnionOfKeys = getUnionOfKeys;
    function comparePos(pos1, pos2) {
      return pos1.line - pos2.line || pos1.column - pos2.column;
    }
    exports.comparePos = comparePos;
    function copyPos(pos) {
      return {
        line: pos.line,
        column: pos.column
      };
    }
    exports.copyPos = copyPos;
    function composeSourceMaps(formerMap, latterMap) {
      if (formerMap) {
        if (!latterMap) {
          return formerMap;
        }
      } else {
        return latterMap || null;
      }
      var smcFormer = new SourceMapConsumer(formerMap);
      var smcLatter = new SourceMapConsumer(latterMap);
      var smg = new SourceMapGenerator({
        file: latterMap.file,
        sourceRoot: latterMap.sourceRoot
      });
      var sourcesToContents = {};
      smcLatter.eachMapping(function(mapping) {
        var origPos = smcFormer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        var sourceName = origPos.source;
        if (sourceName === null) {
          return;
        }
        smg.addMapping({
          source: sourceName,
          original: copyPos(origPos),
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          },
          name: mapping.name
        });
        var sourceContent = smcFormer.sourceContentFor(sourceName);
        if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {
          sourcesToContents[sourceName] = sourceContent;
          smg.setSourceContent(sourceName, sourceContent);
        }
      });
      return smg.toJSON();
    }
    exports.composeSourceMaps = composeSourceMaps;
    function getTrueLoc(node, lines) {
      if (!node.loc) {
        return null;
      }
      var result = {
        start: node.loc.start,
        end: node.loc.end
      };
      function include(node2) {
        expandLoc(result, node2.loc);
      }
      if (node.declaration && node.declaration.decorators && isExportDeclaration(node)) {
        node.declaration.decorators.forEach(include);
      }
      if (comparePos(result.start, result.end) < 0) {
        result.start = copyPos(result.start);
        lines.skipSpaces(result.start, false, true);
        if (comparePos(result.start, result.end) < 0) {
          result.end = copyPos(result.end);
          lines.skipSpaces(result.end, true, true);
        }
      }
      if (node.comments) {
        node.comments.forEach(include);
      }
      return result;
    }
    exports.getTrueLoc = getTrueLoc;
    function expandLoc(parentLoc, childLoc) {
      if (parentLoc && childLoc) {
        if (comparePos(childLoc.start, parentLoc.start) < 0) {
          parentLoc.start = childLoc.start;
        }
        if (comparePos(parentLoc.end, childLoc.end) < 0) {
          parentLoc.end = childLoc.end;
        }
      }
    }
    function fixFaultyLocations(node, lines) {
      var loc = node.loc;
      if (loc) {
        if (loc.start.line < 1) {
          loc.start.line = 1;
        }
        if (loc.end.line < 1) {
          loc.end.line = 1;
        }
      }
      if (node.type === "File") {
        loc.start = lines.firstPos();
        loc.end = lines.lastPos();
      }
      fixForLoopHead(node, lines);
      fixTemplateLiteral(node, lines);
      if (loc && node.decorators) {
        node.decorators.forEach(function(decorator) {
          expandLoc(loc, decorator.loc);
        });
      } else if (node.declaration && isExportDeclaration(node)) {
        node.declaration.loc = null;
        var decorators = node.declaration.decorators;
        if (decorators) {
          decorators.forEach(function(decorator) {
            expandLoc(loc, decorator.loc);
          });
        }
      } else if (n.MethodDefinition && n.MethodDefinition.check(node) || n.Property.check(node) && (node.method || node.shorthand)) {
        node.value.loc = null;
        if (n.FunctionExpression.check(node.value)) {
          node.value.id = null;
        }
      } else if (node.type === "ObjectTypeProperty") {
        var loc_1 = node.loc;
        var end = loc_1 && loc_1.end;
        if (end) {
          end = copyPos(end);
          if (lines.prevPos(end) && lines.charAt(end) === ",") {
            if (end = lines.skipSpaces(end, true, true)) {
              loc_1.end = end;
            }
          }
        }
      }
    }
    exports.fixFaultyLocations = fixFaultyLocations;
    function fixForLoopHead(node, lines) {
      if (node.type !== "ForStatement") {
        return;
      }
      function fix(child) {
        var loc = child && child.loc;
        var start = loc && loc.start;
        var end = loc && copyPos(loc.end);
        while (start && end && comparePos(start, end) < 0) {
          lines.prevPos(end);
          if (lines.charAt(end) === ";") {
            loc.end.line = end.line;
            loc.end.column = end.column;
          } else {
            break;
          }
        }
      }
      fix(node.init);
      fix(node.test);
      fix(node.update);
    }
    function fixTemplateLiteral(node, lines) {
      if (node.type !== "TemplateLiteral") {
        return;
      }
      if (node.quasis.length === 0) {
        return;
      }
      if (node.loc) {
        var afterLeftBackTickPos = copyPos(node.loc.start);
        assert_1.default.strictEqual(lines.charAt(afterLeftBackTickPos), "`");
        assert_1.default.ok(lines.nextPos(afterLeftBackTickPos));
        var firstQuasi = node.quasis[0];
        if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
          firstQuasi.loc.start = afterLeftBackTickPos;
        }
        var rightBackTickPos = copyPos(node.loc.end);
        assert_1.default.ok(lines.prevPos(rightBackTickPos));
        assert_1.default.strictEqual(lines.charAt(rightBackTickPos), "`");
        var lastQuasi = node.quasis[node.quasis.length - 1];
        if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
          lastQuasi.loc.end = rightBackTickPos;
        }
      }
      node.expressions.forEach(function(expr, i2) {
        var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);
        if (lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === "{" && lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === "$") {
          var quasiBefore = node.quasis[i2];
          if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
            quasiBefore.loc.end = dollarCurlyPos;
          }
        }
        var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);
        if (lines.charAt(rightCurlyPos) === "}") {
          assert_1.default.ok(lines.nextPos(rightCurlyPos));
          var quasiAfter = node.quasis[i2 + 1];
          if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
            quasiAfter.loc.start = rightCurlyPos;
          }
        }
      });
    }
    function isExportDeclaration(node) {
      if (node)
        switch (node.type) {
          case "ExportDeclaration":
          case "ExportDefaultDeclaration":
          case "ExportDefaultSpecifier":
          case "DeclareExportDeclaration":
          case "ExportNamedDeclaration":
          case "ExportAllDeclaration":
            return true;
        }
      return false;
    }
    exports.isExportDeclaration = isExportDeclaration;
    function getParentExportDeclaration(path3) {
      var parentNode = path3.getParentNode();
      if (path3.getName() === "declaration" && isExportDeclaration(parentNode)) {
        return parentNode;
      }
      return null;
    }
    exports.getParentExportDeclaration = getParentExportDeclaration;
    function isTrailingCommaEnabled(options, context) {
      var trailingComma = options.trailingComma;
      if (typeof trailingComma === "object") {
        return !!trailingComma[context];
      }
      return !!trailingComma;
    }
    exports.isTrailingCommaEnabled = isTrailingCommaEnabled;
  }
});

// ../../node_modules/.pnpm/esprima@4.0.1/node_modules/esprima/dist/esprima.js
var require_esprima2 = __commonJS({
  "../../node_modules/.pnpm/esprima@4.0.1/node_modules/esprima/dist/esprima.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["esprima"] = factory();
      else
        root["esprima"] = factory();
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module3 = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.loaded = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var comment_handler_1 = __webpack_require__(1);
          var jsx_parser_1 = __webpack_require__(3);
          var parser_1 = __webpack_require__(8);
          var tokenizer_1 = __webpack_require__(15);
          function parse12(code, options, delegate) {
            var commentHandler = null;
            var proxyDelegate = function(node, metadata) {
              if (delegate) {
                delegate(node, metadata);
              }
              if (commentHandler) {
                commentHandler.visit(node, metadata);
              }
            };
            var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
            var collectComment3 = false;
            if (options) {
              collectComment3 = typeof options.comment === "boolean" && options.comment;
              var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
              if (collectComment3 || attachComment) {
                commentHandler = new comment_handler_1.CommentHandler();
                commentHandler.attach = attachComment;
                options.comment = true;
                parserDelegate = proxyDelegate;
              }
            }
            var isModule = false;
            if (options && typeof options.sourceType === "string") {
              isModule = options.sourceType === "module";
            }
            var parser;
            if (options && typeof options.jsx === "boolean" && options.jsx) {
              parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
            } else {
              parser = new parser_1.Parser(code, options, parserDelegate);
            }
            var program3 = isModule ? parser.parseModule() : parser.parseScript();
            var ast = program3;
            if (collectComment3 && commentHandler) {
              ast.comments = commentHandler.comments;
            }
            if (parser.config.tokens) {
              ast.tokens = parser.tokens;
            }
            if (parser.config.tolerant) {
              ast.errors = parser.errorHandler.errors;
            }
            return ast;
          }
          exports2.parse = parse12;
          function parseModule(code, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "module";
            return parse12(code, parsingOptions, delegate);
          }
          exports2.parseModule = parseModule;
          function parseScript(code, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "script";
            return parse12(code, parsingOptions, delegate);
          }
          exports2.parseScript = parseScript;
          function tokenize(code, options, delegate) {
            var tokenizer = new tokenizer_1.Tokenizer(code, options);
            var tokens;
            tokens = [];
            try {
              while (true) {
                var token = tokenizer.getNextToken();
                if (!token) {
                  break;
                }
                if (delegate) {
                  token = delegate(token);
                }
                tokens.push(token);
              }
            } catch (e3) {
              tokenizer.errorHandler.tolerate(e3);
            }
            if (tokenizer.errorHandler.tolerant) {
              tokens.errors = tokenizer.errors();
            }
            return tokens;
          }
          exports2.tokenize = tokenize;
          var syntax_1 = __webpack_require__(2);
          exports2.Syntax = syntax_1.Syntax;
          exports2.version = "4.0.1";
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var CommentHandler = function() {
            function CommentHandler2() {
              this.attach = false;
              this.comments = [];
              this.stack = [];
              this.leading = [];
              this.trailing = [];
            }
            CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
              if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                var innerComments = [];
                for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                  var entry = this.leading[i2];
                  if (metadata.end.offset >= entry.start) {
                    innerComments.unshift(entry.comment);
                    this.leading.splice(i2, 1);
                    this.trailing.splice(i2, 1);
                  }
                }
                if (innerComments.length) {
                  node.innerComments = innerComments;
                }
              }
            };
            CommentHandler2.prototype.findTrailingComments = function(metadata) {
              var trailingComments = [];
              if (this.trailing.length > 0) {
                for (var i2 = this.trailing.length - 1; i2 >= 0; --i2) {
                  var entry_1 = this.trailing[i2];
                  if (entry_1.start >= metadata.end.offset) {
                    trailingComments.unshift(entry_1.comment);
                  }
                }
                this.trailing.length = 0;
                return trailingComments;
              }
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.node.trailingComments) {
                var firstComment = entry.node.trailingComments[0];
                if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                  trailingComments = entry.node.trailingComments;
                  delete entry.node.trailingComments;
                }
              }
              return trailingComments;
            };
            CommentHandler2.prototype.findLeadingComments = function(metadata) {
              var leadingComments = [];
              var target;
              while (this.stack.length > 0) {
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.start >= metadata.start.offset) {
                  target = entry.node;
                  this.stack.pop();
                } else {
                  break;
                }
              }
              if (target) {
                var count = target.leadingComments ? target.leadingComments.length : 0;
                for (var i2 = count - 1; i2 >= 0; --i2) {
                  var comment = target.leadingComments[i2];
                  if (comment.range[1] <= metadata.start.offset) {
                    leadingComments.unshift(comment);
                    target.leadingComments.splice(i2, 1);
                  }
                }
                if (target.leadingComments && target.leadingComments.length === 0) {
                  delete target.leadingComments;
                }
                return leadingComments;
              }
              for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                var entry = this.leading[i2];
                if (entry.start <= metadata.start.offset) {
                  leadingComments.unshift(entry.comment);
                  this.leading.splice(i2, 1);
                }
              }
              return leadingComments;
            };
            CommentHandler2.prototype.visitNode = function(node, metadata) {
              if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                return;
              }
              this.insertInnerComments(node, metadata);
              var trailingComments = this.findTrailingComments(metadata);
              var leadingComments = this.findLeadingComments(metadata);
              if (leadingComments.length > 0) {
                node.leadingComments = leadingComments;
              }
              if (trailingComments.length > 0) {
                node.trailingComments = trailingComments;
              }
              this.stack.push({
                node,
                start: metadata.start.offset
              });
            };
            CommentHandler2.prototype.visitComment = function(node, metadata) {
              var type = node.type[0] === "L" ? "Line" : "Block";
              var comment = {
                type,
                value: node.value
              };
              if (node.range) {
                comment.range = node.range;
              }
              if (node.loc) {
                comment.loc = node.loc;
              }
              this.comments.push(comment);
              if (this.attach) {
                var entry = {
                  comment: {
                    type,
                    value: node.value,
                    range: [metadata.start.offset, metadata.end.offset]
                  },
                  start: metadata.start.offset
                };
                if (node.loc) {
                  entry.comment.loc = node.loc;
                }
                node.type = type;
                this.leading.push(entry);
                this.trailing.push(entry);
              }
            };
            CommentHandler2.prototype.visit = function(node, metadata) {
              if (node.type === "LineComment") {
                this.visitComment(node, metadata);
              } else if (node.type === "BlockComment") {
                this.visitComment(node, metadata);
              } else if (this.attach) {
                this.visitNode(node, metadata);
              }
            };
            return CommentHandler2;
          }();
          exports2.CommentHandler = CommentHandler;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Syntax = {
            AssignmentExpression: "AssignmentExpression",
            AssignmentPattern: "AssignmentPattern",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            AwaitExpression: "AwaitExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportAllDeclaration: "ExportAllDeclaration",
            ExportDefaultDeclaration: "ExportDefaultDeclaration",
            ExportNamedDeclaration: "ExportNamedDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForOfStatement: "ForOfStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportDeclaration: "ImportDeclaration",
            ImportDefaultSpecifier: "ImportDefaultSpecifier",
            ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
            ImportSpecifier: "ImportSpecifier",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MetaProperty: "MetaProperty",
            MethodDefinition: "MethodDefinition",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            RestElement: "RestElement",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            Super: "Super",
            SwitchCase: "SwitchCase",
            SwitchStatement: "SwitchStatement",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
              d3.__proto__ = b2;
            } || function(d3, b2) {
              for (var p3 in b2)
                if (b2.hasOwnProperty(p3))
                  d3[p3] = b2[p3];
            };
            return function(d3, b2) {
              extendStatics(d3, b2);
              function __() {
                this.constructor = d3;
              }
              d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports2, "__esModule", { value: true });
          var character_1 = __webpack_require__(4);
          var JSXNode = __webpack_require__(5);
          var jsx_syntax_1 = __webpack_require__(6);
          var Node = __webpack_require__(7);
          var parser_1 = __webpack_require__(8);
          var token_1 = __webpack_require__(13);
          var xhtml_entities_1 = __webpack_require__(14);
          token_1.TokenName[100] = "JSXIdentifier";
          token_1.TokenName[101] = "JSXText";
          function getQualifiedElementName(elementName) {
            var qualifiedName;
            switch (elementName.type) {
              case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                var id = elementName;
                qualifiedName = id.name;
                break;
              case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                var ns = elementName;
                qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                break;
              case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                var expr = elementName;
                qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                break;
              default:
                break;
            }
            return qualifiedName;
          }
          var JSXParser = function(_super) {
            __extends(JSXParser2, _super);
            function JSXParser2(code, options, delegate) {
              return _super.call(this, code, options, delegate) || this;
            }
            JSXParser2.prototype.parsePrimaryExpression = function() {
              return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
            };
            JSXParser2.prototype.startJSX = function() {
              this.scanner.index = this.startMarker.index;
              this.scanner.lineNumber = this.startMarker.line;
              this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
            };
            JSXParser2.prototype.finishJSX = function() {
              this.nextToken();
            };
            JSXParser2.prototype.reenterJSX = function() {
              this.startJSX();
              this.expectJSX("}");
              if (this.config.tokens) {
                this.tokens.pop();
              }
            };
            JSXParser2.prototype.createJSXNode = function() {
              this.collectComments();
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.createJSXChildNode = function() {
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.scanXHTMLEntity = function(quote) {
              var result = "&";
              var valid = true;
              var terminated = false;
              var numeric = false;
              var hex = false;
              while (!this.scanner.eof() && valid && !terminated) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === quote) {
                  break;
                }
                terminated = ch === ";";
                result += ch;
                ++this.scanner.index;
                if (!terminated) {
                  switch (result.length) {
                    case 2:
                      numeric = ch === "#";
                      break;
                    case 3:
                      if (numeric) {
                        hex = ch === "x";
                        valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                        numeric = numeric && !hex;
                      }
                      break;
                    default:
                      valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                      valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                      break;
                  }
                }
              }
              if (valid && terminated && result.length > 2) {
                var str = result.substr(1, result.length - 2);
                if (numeric && str.length > 1) {
                  result = String.fromCharCode(parseInt(str.substr(1), 10));
                } else if (hex && str.length > 2) {
                  result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                  result = xhtml_entities_1.XHTMLEntities[str];
                }
              }
              return result;
            };
            JSXParser2.prototype.lexJSX = function() {
              var cp = this.scanner.source.charCodeAt(this.scanner.index);
              if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                var value = this.scanner.source[this.scanner.index++];
                return {
                  type: 7,
                  value,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index - 1,
                  end: this.scanner.index
                };
              }
              if (cp === 34 || cp === 39) {
                var start = this.scanner.index;
                var quote = this.scanner.source[this.scanner.index++];
                var str = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index++];
                  if (ch === quote) {
                    break;
                  } else if (ch === "&") {
                    str += this.scanXHTMLEntity(quote);
                  } else {
                    str += ch;
                  }
                }
                return {
                  type: 8,
                  value: str,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 46) {
                var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                var value = n1 === 46 && n2 === 46 ? "..." : ".";
                var start = this.scanner.index;
                this.scanner.index += value.length;
                return {
                  type: 7,
                  value,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 96) {
                return {
                  type: 10,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index,
                  end: this.scanner.index
                };
              }
              if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                var start = this.scanner.index;
                ++this.scanner.index;
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source.charCodeAt(this.scanner.index);
                  if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                    ++this.scanner.index;
                  } else if (ch === 45) {
                    ++this.scanner.index;
                  } else {
                    break;
                  }
                }
                var id = this.scanner.source.slice(start, this.scanner.index);
                return {
                  type: 100,
                  value: id,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              return this.scanner.lex();
            };
            JSXParser2.prototype.nextJSXToken = function() {
              this.collectComments();
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = this.lexJSX();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              if (this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.nextJSXText = function() {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var start = this.scanner.index;
              var text = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === "{" || ch === "<") {
                  break;
                }
                ++this.scanner.index;
                text += ch;
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.scanner.lineNumber;
                  if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                    ++this.scanner.index;
                  }
                  this.scanner.lineStart = this.scanner.index;
                }
              }
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = {
                type: 101,
                value: text,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
              if (text.length > 0 && this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.peekJSXToken = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.lexJSX();
              this.scanner.restoreState(state);
              return next;
            };
            JSXParser2.prototype.expectJSX = function(value) {
              var token = this.nextJSXToken();
              if (token.type !== 7 || token.value !== value) {
                this.throwUnexpectedToken(token);
              }
            };
            JSXParser2.prototype.matchJSX = function(value) {
              var next = this.peekJSXToken();
              return next.type === 7 && next.value === value;
            };
            JSXParser2.prototype.parseJSXIdentifier = function() {
              var node = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 100) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
            };
            JSXParser2.prototype.parseJSXElementName = function() {
              var node = this.createJSXNode();
              var elementName = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = elementName;
                this.expectJSX(":");
                var name_1 = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
              } else if (this.matchJSX(".")) {
                while (this.matchJSX(".")) {
                  var object = elementName;
                  this.expectJSX(".");
                  var property = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                }
              }
              return elementName;
            };
            JSXParser2.prototype.parseJSXAttributeName = function() {
              var node = this.createJSXNode();
              var attributeName;
              var identifier = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = identifier;
                this.expectJSX(":");
                var name_2 = this.parseJSXIdentifier();
                attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
              } else {
                attributeName = identifier;
              }
              return attributeName;
            };
            JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
              var node = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 8) {
                this.throwUnexpectedToken(token);
              }
              var raw = this.getTokenRaw(token);
              return this.finalize(node, new Node.Literal(token.value, raw));
            };
            JSXParser2.prototype.parseJSXExpressionAttribute = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              this.finishJSX();
              if (this.match("}")) {
                this.tolerateError("JSX attributes must only be assigned a non-empty expression");
              }
              var expression = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXAttributeValue = function() {
              return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
            };
            JSXParser2.prototype.parseJSXNameValueAttribute = function() {
              var node = this.createJSXNode();
              var name = this.parseJSXAttributeName();
              var value = null;
              if (this.matchJSX("=")) {
                this.expectJSX("=");
                value = this.parseJSXAttributeValue();
              }
              return this.finalize(node, new JSXNode.JSXAttribute(name, value));
            };
            JSXParser2.prototype.parseJSXSpreadAttribute = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              this.expectJSX("...");
              this.finishJSX();
              var argument = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
            };
            JSXParser2.prototype.parseJSXAttributes = function() {
              var attributes = [];
              while (!this.matchJSX("/") && !this.matchJSX(">")) {
                var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                attributes.push(attribute);
              }
              return attributes;
            };
            JSXParser2.prototype.parseJSXOpeningElement = function() {
              var node = this.createJSXNode();
              this.expectJSX("<");
              var name = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXBoundaryElement = function() {
              var node = this.createJSXNode();
              this.expectJSX("<");
              if (this.matchJSX("/")) {
                this.expectJSX("/");
                var name_3 = this.parseJSXElementName();
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
              }
              var name = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXEmptyExpression = function() {
              var node = this.createJSXChildNode();
              this.collectComments();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              return this.finalize(node, new JSXNode.JSXEmptyExpression());
            };
            JSXParser2.prototype.parseJSXExpressionContainer = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              var expression;
              if (this.matchJSX("}")) {
                expression = this.parseJSXEmptyExpression();
                this.expectJSX("}");
              } else {
                this.finishJSX();
                expression = this.parseAssignmentExpression();
                this.reenterJSX();
              }
              return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXChildren = function() {
              var children = [];
              while (!this.scanner.eof()) {
                var node = this.createJSXChildNode();
                var token = this.nextJSXText();
                if (token.start < token.end) {
                  var raw = this.getTokenRaw(token);
                  var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                  children.push(child);
                }
                if (this.scanner.source[this.scanner.index] === "{") {
                  var container = this.parseJSXExpressionContainer();
                  children.push(container);
                } else {
                  break;
                }
              }
              return children;
            };
            JSXParser2.prototype.parseComplexJSXElement = function(el) {
              var stack = [];
              while (!this.scanner.eof()) {
                el.children = el.children.concat(this.parseJSXChildren());
                var node = this.createJSXChildNode();
                var element = this.parseJSXBoundaryElement();
                if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                  var opening = element;
                  if (opening.selfClosing) {
                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                    el.children.push(child);
                  } else {
                    stack.push(el);
                    el = { node, opening, closing: null, children: [] };
                  }
                }
                if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                  el.closing = element;
                  var open_1 = getQualifiedElementName(el.opening.name);
                  var close_1 = getQualifiedElementName(el.closing.name);
                  if (open_1 !== close_1) {
                    this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                  }
                  if (stack.length > 0) {
                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                    el = stack[stack.length - 1];
                    el.children.push(child);
                    stack.pop();
                  } else {
                    break;
                  }
                }
              }
              return el;
            };
            JSXParser2.prototype.parseJSXElement = function() {
              var node = this.createJSXNode();
              var opening = this.parseJSXOpeningElement();
              var children = [];
              var closing = null;
              if (!opening.selfClosing) {
                var el = this.parseComplexJSXElement({ node, opening, closing, children });
                children = el.children;
                closing = el.closing;
              }
              return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
            };
            JSXParser2.prototype.parseJSXRoot = function() {
              if (this.config.tokens) {
                this.tokens.pop();
              }
              this.startJSX();
              var element = this.parseJSXElement();
              this.finishJSX();
              return element;
            };
            JSXParser2.prototype.isStartOfExpression = function() {
              return _super.prototype.isStartOfExpression.call(this) || this.match("<");
            };
            return JSXParser2;
          }(parser_1.Parser);
          exports2.JSXParser = JSXParser;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Regex = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          };
          exports2.Character = {
            fromCodePoint: function(cp) {
              return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
            },
            isWhiteSpace: function(cp) {
              return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
            },
            isLineTerminator: function(cp) {
              return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
            },
            isIdentifierStart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
            },
            isIdentifierPart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
            },
            isDecimalDigit: function(cp) {
              return cp >= 48 && cp <= 57;
            },
            isHexDigit: function(cp) {
              return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
            },
            isOctalDigit: function(cp) {
              return cp >= 48 && cp <= 55;
            }
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var jsx_syntax_1 = __webpack_require__(6);
          var JSXClosingElement = function() {
            function JSXClosingElement2(name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
              this.name = name;
            }
            return JSXClosingElement2;
          }();
          exports2.JSXClosingElement = JSXClosingElement;
          var JSXElement = function() {
            function JSXElement2(openingElement, children, closingElement) {
              this.type = jsx_syntax_1.JSXSyntax.JSXElement;
              this.openingElement = openingElement;
              this.children = children;
              this.closingElement = closingElement;
            }
            return JSXElement2;
          }();
          exports2.JSXElement = JSXElement;
          var JSXEmptyExpression = function() {
            function JSXEmptyExpression2() {
              this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
            }
            return JSXEmptyExpression2;
          }();
          exports2.JSXEmptyExpression = JSXEmptyExpression;
          var JSXExpressionContainer = function() {
            function JSXExpressionContainer2(expression) {
              this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
              this.expression = expression;
            }
            return JSXExpressionContainer2;
          }();
          exports2.JSXExpressionContainer = JSXExpressionContainer;
          var JSXIdentifier = function() {
            function JSXIdentifier2(name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
              this.name = name;
            }
            return JSXIdentifier2;
          }();
          exports2.JSXIdentifier = JSXIdentifier;
          var JSXMemberExpression = function() {
            function JSXMemberExpression2(object, property) {
              this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
              this.object = object;
              this.property = property;
            }
            return JSXMemberExpression2;
          }();
          exports2.JSXMemberExpression = JSXMemberExpression;
          var JSXAttribute = function() {
            function JSXAttribute2(name, value) {
              this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
              this.name = name;
              this.value = value;
            }
            return JSXAttribute2;
          }();
          exports2.JSXAttribute = JSXAttribute;
          var JSXNamespacedName = function() {
            function JSXNamespacedName2(namespace, name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
              this.namespace = namespace;
              this.name = name;
            }
            return JSXNamespacedName2;
          }();
          exports2.JSXNamespacedName = JSXNamespacedName;
          var JSXOpeningElement = function() {
            function JSXOpeningElement2(name, selfClosing, attributes) {
              this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
              this.name = name;
              this.selfClosing = selfClosing;
              this.attributes = attributes;
            }
            return JSXOpeningElement2;
          }();
          exports2.JSXOpeningElement = JSXOpeningElement;
          var JSXSpreadAttribute = function() {
            function JSXSpreadAttribute2(argument) {
              this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
              this.argument = argument;
            }
            return JSXSpreadAttribute2;
          }();
          exports2.JSXSpreadAttribute = JSXSpreadAttribute;
          var JSXText = function() {
            function JSXText2(value, raw) {
              this.type = jsx_syntax_1.JSXSyntax.JSXText;
              this.value = value;
              this.raw = raw;
            }
            return JSXText2;
          }();
          exports2.JSXText = JSXText;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.JSXSyntax = {
            JSXAttribute: "JSXAttribute",
            JSXClosingElement: "JSXClosingElement",
            JSXElement: "JSXElement",
            JSXEmptyExpression: "JSXEmptyExpression",
            JSXExpressionContainer: "JSXExpressionContainer",
            JSXIdentifier: "JSXIdentifier",
            JSXMemberExpression: "JSXMemberExpression",
            JSXNamespacedName: "JSXNamespacedName",
            JSXOpeningElement: "JSXOpeningElement",
            JSXSpreadAttribute: "JSXSpreadAttribute",
            JSXText: "JSXText"
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var ArrayExpression = function() {
            function ArrayExpression2(elements) {
              this.type = syntax_1.Syntax.ArrayExpression;
              this.elements = elements;
            }
            return ArrayExpression2;
          }();
          exports2.ArrayExpression = ArrayExpression;
          var ArrayPattern = function() {
            function ArrayPattern2(elements) {
              this.type = syntax_1.Syntax.ArrayPattern;
              this.elements = elements;
            }
            return ArrayPattern2;
          }();
          exports2.ArrayPattern = ArrayPattern;
          var ArrowFunctionExpression = function() {
            function ArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = false;
            }
            return ArrowFunctionExpression2;
          }();
          exports2.ArrowFunctionExpression = ArrowFunctionExpression;
          var AssignmentExpression = function() {
            function AssignmentExpression2(operator, left, right) {
              this.type = syntax_1.Syntax.AssignmentExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return AssignmentExpression2;
          }();
          exports2.AssignmentExpression = AssignmentExpression;
          var AssignmentPattern = function() {
            function AssignmentPattern2(left, right) {
              this.type = syntax_1.Syntax.AssignmentPattern;
              this.left = left;
              this.right = right;
            }
            return AssignmentPattern2;
          }();
          exports2.AssignmentPattern = AssignmentPattern;
          var AsyncArrowFunctionExpression = function() {
            function AsyncArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = true;
            }
            return AsyncArrowFunctionExpression2;
          }();
          exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
          var AsyncFunctionDeclaration = function() {
            function AsyncFunctionDeclaration2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionDeclaration2;
          }();
          exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
          var AsyncFunctionExpression = function() {
            function AsyncFunctionExpression2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionExpression2;
          }();
          exports2.AsyncFunctionExpression = AsyncFunctionExpression;
          var AwaitExpression = function() {
            function AwaitExpression2(argument) {
              this.type = syntax_1.Syntax.AwaitExpression;
              this.argument = argument;
            }
            return AwaitExpression2;
          }();
          exports2.AwaitExpression = AwaitExpression;
          var BinaryExpression = function() {
            function BinaryExpression2(operator, left, right) {
              var logical = operator === "||" || operator === "&&";
              this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return BinaryExpression2;
          }();
          exports2.BinaryExpression = BinaryExpression;
          var BlockStatement = function() {
            function BlockStatement2(body) {
              this.type = syntax_1.Syntax.BlockStatement;
              this.body = body;
            }
            return BlockStatement2;
          }();
          exports2.BlockStatement = BlockStatement;
          var BreakStatement = function() {
            function BreakStatement2(label) {
              this.type = syntax_1.Syntax.BreakStatement;
              this.label = label;
            }
            return BreakStatement2;
          }();
          exports2.BreakStatement = BreakStatement;
          var CallExpression = function() {
            function CallExpression2(callee, args) {
              this.type = syntax_1.Syntax.CallExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return CallExpression2;
          }();
          exports2.CallExpression = CallExpression;
          var CatchClause = function() {
            function CatchClause2(param, body) {
              this.type = syntax_1.Syntax.CatchClause;
              this.param = param;
              this.body = body;
            }
            return CatchClause2;
          }();
          exports2.CatchClause = CatchClause;
          var ClassBody = function() {
            function ClassBody2(body) {
              this.type = syntax_1.Syntax.ClassBody;
              this.body = body;
            }
            return ClassBody2;
          }();
          exports2.ClassBody = ClassBody;
          var ClassDeclaration = function() {
            function ClassDeclaration2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassDeclaration;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassDeclaration2;
          }();
          exports2.ClassDeclaration = ClassDeclaration;
          var ClassExpression = function() {
            function ClassExpression2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassExpression;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassExpression2;
          }();
          exports2.ClassExpression = ClassExpression;
          var ComputedMemberExpression = function() {
            function ComputedMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = true;
              this.object = object;
              this.property = property;
            }
            return ComputedMemberExpression2;
          }();
          exports2.ComputedMemberExpression = ComputedMemberExpression;
          var ConditionalExpression = function() {
            function ConditionalExpression2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.ConditionalExpression;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return ConditionalExpression2;
          }();
          exports2.ConditionalExpression = ConditionalExpression;
          var ContinueStatement = function() {
            function ContinueStatement2(label) {
              this.type = syntax_1.Syntax.ContinueStatement;
              this.label = label;
            }
            return ContinueStatement2;
          }();
          exports2.ContinueStatement = ContinueStatement;
          var DebuggerStatement = function() {
            function DebuggerStatement2() {
              this.type = syntax_1.Syntax.DebuggerStatement;
            }
            return DebuggerStatement2;
          }();
          exports2.DebuggerStatement = DebuggerStatement;
          var Directive = function() {
            function Directive2(expression, directive) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
              this.directive = directive;
            }
            return Directive2;
          }();
          exports2.Directive = Directive;
          var DoWhileStatement = function() {
            function DoWhileStatement2(body, test) {
              this.type = syntax_1.Syntax.DoWhileStatement;
              this.body = body;
              this.test = test;
            }
            return DoWhileStatement2;
          }();
          exports2.DoWhileStatement = DoWhileStatement;
          var EmptyStatement = function() {
            function EmptyStatement2() {
              this.type = syntax_1.Syntax.EmptyStatement;
            }
            return EmptyStatement2;
          }();
          exports2.EmptyStatement = EmptyStatement;
          var ExportAllDeclaration = function() {
            function ExportAllDeclaration2(source) {
              this.type = syntax_1.Syntax.ExportAllDeclaration;
              this.source = source;
            }
            return ExportAllDeclaration2;
          }();
          exports2.ExportAllDeclaration = ExportAllDeclaration;
          var ExportDefaultDeclaration = function() {
            function ExportDefaultDeclaration2(declaration) {
              this.type = syntax_1.Syntax.ExportDefaultDeclaration;
              this.declaration = declaration;
            }
            return ExportDefaultDeclaration2;
          }();
          exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
          var ExportNamedDeclaration = function() {
            function ExportNamedDeclaration2(declaration, specifiers, source) {
              this.type = syntax_1.Syntax.ExportNamedDeclaration;
              this.declaration = declaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ExportNamedDeclaration2;
          }();
          exports2.ExportNamedDeclaration = ExportNamedDeclaration;
          var ExportSpecifier = function() {
            function ExportSpecifier2(local, exported) {
              this.type = syntax_1.Syntax.ExportSpecifier;
              this.exported = exported;
              this.local = local;
            }
            return ExportSpecifier2;
          }();
          exports2.ExportSpecifier = ExportSpecifier;
          var ExpressionStatement = function() {
            function ExpressionStatement2(expression) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
            }
            return ExpressionStatement2;
          }();
          exports2.ExpressionStatement = ExpressionStatement;
          var ForInStatement = function() {
            function ForInStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForInStatement;
              this.left = left;
              this.right = right;
              this.body = body;
              this.each = false;
            }
            return ForInStatement2;
          }();
          exports2.ForInStatement = ForInStatement;
          var ForOfStatement = function() {
            function ForOfStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForOfStatement;
              this.left = left;
              this.right = right;
              this.body = body;
            }
            return ForOfStatement2;
          }();
          exports2.ForOfStatement = ForOfStatement;
          var ForStatement = function() {
            function ForStatement2(init3, test, update, body) {
              this.type = syntax_1.Syntax.ForStatement;
              this.init = init3;
              this.test = test;
              this.update = update;
              this.body = body;
            }
            return ForStatement2;
          }();
          exports2.ForStatement = ForStatement;
          var FunctionDeclaration = function() {
            function FunctionDeclaration2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionDeclaration2;
          }();
          exports2.FunctionDeclaration = FunctionDeclaration;
          var FunctionExpression = function() {
            function FunctionExpression2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionExpression2;
          }();
          exports2.FunctionExpression = FunctionExpression;
          var Identifier = function() {
            function Identifier2(name) {
              this.type = syntax_1.Syntax.Identifier;
              this.name = name;
            }
            return Identifier2;
          }();
          exports2.Identifier = Identifier;
          var IfStatement = function() {
            function IfStatement2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.IfStatement;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return IfStatement2;
          }();
          exports2.IfStatement = IfStatement;
          var ImportDeclaration = function() {
            function ImportDeclaration2(specifiers, source) {
              this.type = syntax_1.Syntax.ImportDeclaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ImportDeclaration2;
          }();
          exports2.ImportDeclaration = ImportDeclaration;
          var ImportDefaultSpecifier = function() {
            function ImportDefaultSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportDefaultSpecifier;
              this.local = local;
            }
            return ImportDefaultSpecifier2;
          }();
          exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
          var ImportNamespaceSpecifier = function() {
            function ImportNamespaceSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
              this.local = local;
            }
            return ImportNamespaceSpecifier2;
          }();
          exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          var ImportSpecifier = function() {
            function ImportSpecifier2(local, imported) {
              this.type = syntax_1.Syntax.ImportSpecifier;
              this.local = local;
              this.imported = imported;
            }
            return ImportSpecifier2;
          }();
          exports2.ImportSpecifier = ImportSpecifier;
          var LabeledStatement = function() {
            function LabeledStatement2(label, body) {
              this.type = syntax_1.Syntax.LabeledStatement;
              this.label = label;
              this.body = body;
            }
            return LabeledStatement2;
          }();
          exports2.LabeledStatement = LabeledStatement;
          var Literal = function() {
            function Literal2(value, raw) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value;
              this.raw = raw;
            }
            return Literal2;
          }();
          exports2.Literal = Literal;
          var MetaProperty = function() {
            function MetaProperty2(meta, property) {
              this.type = syntax_1.Syntax.MetaProperty;
              this.meta = meta;
              this.property = property;
            }
            return MetaProperty2;
          }();
          exports2.MetaProperty = MetaProperty;
          var MethodDefinition = function() {
            function MethodDefinition2(key, computed, value, kind, isStatic) {
              this.type = syntax_1.Syntax.MethodDefinition;
              this.key = key;
              this.computed = computed;
              this.value = value;
              this.kind = kind;
              this.static = isStatic;
            }
            return MethodDefinition2;
          }();
          exports2.MethodDefinition = MethodDefinition;
          var Module = function() {
            function Module2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "module";
            }
            return Module2;
          }();
          exports2.Module = Module;
          var NewExpression = function() {
            function NewExpression2(callee, args) {
              this.type = syntax_1.Syntax.NewExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return NewExpression2;
          }();
          exports2.NewExpression = NewExpression;
          var ObjectExpression = function() {
            function ObjectExpression2(properties) {
              this.type = syntax_1.Syntax.ObjectExpression;
              this.properties = properties;
            }
            return ObjectExpression2;
          }();
          exports2.ObjectExpression = ObjectExpression;
          var ObjectPattern = function() {
            function ObjectPattern2(properties) {
              this.type = syntax_1.Syntax.ObjectPattern;
              this.properties = properties;
            }
            return ObjectPattern2;
          }();
          exports2.ObjectPattern = ObjectPattern;
          var Property = function() {
            function Property2(kind, key, computed, value, method, shorthand) {
              this.type = syntax_1.Syntax.Property;
              this.key = key;
              this.computed = computed;
              this.value = value;
              this.kind = kind;
              this.method = method;
              this.shorthand = shorthand;
            }
            return Property2;
          }();
          exports2.Property = Property;
          var RegexLiteral = function() {
            function RegexLiteral2(value, raw, pattern, flags) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value;
              this.raw = raw;
              this.regex = { pattern, flags };
            }
            return RegexLiteral2;
          }();
          exports2.RegexLiteral = RegexLiteral;
          var RestElement = function() {
            function RestElement2(argument) {
              this.type = syntax_1.Syntax.RestElement;
              this.argument = argument;
            }
            return RestElement2;
          }();
          exports2.RestElement = RestElement;
          var ReturnStatement = function() {
            function ReturnStatement2(argument) {
              this.type = syntax_1.Syntax.ReturnStatement;
              this.argument = argument;
            }
            return ReturnStatement2;
          }();
          exports2.ReturnStatement = ReturnStatement;
          var Script = function() {
            function Script2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "script";
            }
            return Script2;
          }();
          exports2.Script = Script;
          var SequenceExpression = function() {
            function SequenceExpression2(expressions) {
              this.type = syntax_1.Syntax.SequenceExpression;
              this.expressions = expressions;
            }
            return SequenceExpression2;
          }();
          exports2.SequenceExpression = SequenceExpression;
          var SpreadElement = function() {
            function SpreadElement2(argument) {
              this.type = syntax_1.Syntax.SpreadElement;
              this.argument = argument;
            }
            return SpreadElement2;
          }();
          exports2.SpreadElement = SpreadElement;
          var StaticMemberExpression = function() {
            function StaticMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = false;
              this.object = object;
              this.property = property;
            }
            return StaticMemberExpression2;
          }();
          exports2.StaticMemberExpression = StaticMemberExpression;
          var Super = function() {
            function Super2() {
              this.type = syntax_1.Syntax.Super;
            }
            return Super2;
          }();
          exports2.Super = Super;
          var SwitchCase = function() {
            function SwitchCase2(test, consequent) {
              this.type = syntax_1.Syntax.SwitchCase;
              this.test = test;
              this.consequent = consequent;
            }
            return SwitchCase2;
          }();
          exports2.SwitchCase = SwitchCase;
          var SwitchStatement = function() {
            function SwitchStatement2(discriminant, cases) {
              this.type = syntax_1.Syntax.SwitchStatement;
              this.discriminant = discriminant;
              this.cases = cases;
            }
            return SwitchStatement2;
          }();
          exports2.SwitchStatement = SwitchStatement;
          var TaggedTemplateExpression = function() {
            function TaggedTemplateExpression2(tag, quasi) {
              this.type = syntax_1.Syntax.TaggedTemplateExpression;
              this.tag = tag;
              this.quasi = quasi;
            }
            return TaggedTemplateExpression2;
          }();
          exports2.TaggedTemplateExpression = TaggedTemplateExpression;
          var TemplateElement = function() {
            function TemplateElement2(value, tail) {
              this.type = syntax_1.Syntax.TemplateElement;
              this.value = value;
              this.tail = tail;
            }
            return TemplateElement2;
          }();
          exports2.TemplateElement = TemplateElement;
          var TemplateLiteral = function() {
            function TemplateLiteral2(quasis, expressions) {
              this.type = syntax_1.Syntax.TemplateLiteral;
              this.quasis = quasis;
              this.expressions = expressions;
            }
            return TemplateLiteral2;
          }();
          exports2.TemplateLiteral = TemplateLiteral;
          var ThisExpression = function() {
            function ThisExpression2() {
              this.type = syntax_1.Syntax.ThisExpression;
            }
            return ThisExpression2;
          }();
          exports2.ThisExpression = ThisExpression;
          var ThrowStatement = function() {
            function ThrowStatement2(argument) {
              this.type = syntax_1.Syntax.ThrowStatement;
              this.argument = argument;
            }
            return ThrowStatement2;
          }();
          exports2.ThrowStatement = ThrowStatement;
          var TryStatement = function() {
            function TryStatement2(block3, handler, finalizer) {
              this.type = syntax_1.Syntax.TryStatement;
              this.block = block3;
              this.handler = handler;
              this.finalizer = finalizer;
            }
            return TryStatement2;
          }();
          exports2.TryStatement = TryStatement;
          var UnaryExpression = function() {
            function UnaryExpression2(operator, argument) {
              this.type = syntax_1.Syntax.UnaryExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = true;
            }
            return UnaryExpression2;
          }();
          exports2.UnaryExpression = UnaryExpression;
          var UpdateExpression = function() {
            function UpdateExpression2(operator, argument, prefix) {
              this.type = syntax_1.Syntax.UpdateExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = prefix;
            }
            return UpdateExpression2;
          }();
          exports2.UpdateExpression = UpdateExpression;
          var VariableDeclaration = function() {
            function VariableDeclaration2(declarations, kind) {
              this.type = syntax_1.Syntax.VariableDeclaration;
              this.declarations = declarations;
              this.kind = kind;
            }
            return VariableDeclaration2;
          }();
          exports2.VariableDeclaration = VariableDeclaration;
          var VariableDeclarator = function() {
            function VariableDeclarator2(id, init3) {
              this.type = syntax_1.Syntax.VariableDeclarator;
              this.id = id;
              this.init = init3;
            }
            return VariableDeclarator2;
          }();
          exports2.VariableDeclarator = VariableDeclarator;
          var WhileStatement = function() {
            function WhileStatement2(test, body) {
              this.type = syntax_1.Syntax.WhileStatement;
              this.test = test;
              this.body = body;
            }
            return WhileStatement2;
          }();
          exports2.WhileStatement = WhileStatement;
          var WithStatement = function() {
            function WithStatement2(object, body) {
              this.type = syntax_1.Syntax.WithStatement;
              this.object = object;
              this.body = body;
            }
            return WithStatement2;
          }();
          exports2.WithStatement = WithStatement;
          var YieldExpression = function() {
            function YieldExpression2(argument, delegate) {
              this.type = syntax_1.Syntax.YieldExpression;
              this.argument = argument;
              this.delegate = delegate;
            }
            return YieldExpression2;
          }();
          exports2.YieldExpression = YieldExpression;
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var assert_1 = __webpack_require__(9);
          var error_handler_1 = __webpack_require__(10);
          var messages_1 = __webpack_require__(11);
          var Node = __webpack_require__(7);
          var scanner_1 = __webpack_require__(12);
          var syntax_1 = __webpack_require__(2);
          var token_1 = __webpack_require__(13);
          var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
          var Parser = function() {
            function Parser2(code, options, delegate) {
              if (options === void 0) {
                options = {};
              }
              this.config = {
                range: typeof options.range === "boolean" && options.range,
                loc: typeof options.loc === "boolean" && options.loc,
                source: null,
                tokens: typeof options.tokens === "boolean" && options.tokens,
                comment: typeof options.comment === "boolean" && options.comment,
                tolerant: typeof options.tolerant === "boolean" && options.tolerant
              };
              if (this.config.loc && options.source && options.source !== null) {
                this.config.source = String(options.source);
              }
              this.delegate = delegate;
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = this.config.tolerant;
              this.scanner = new scanner_1.Scanner(code, this.errorHandler);
              this.scanner.trackComment = this.config.comment;
              this.operatorPrecedence = {
                ")": 0,
                ";": 0,
                ",": 0,
                "=": 0,
                "]": 0,
                "||": 1,
                "&&": 2,
                "|": 3,
                "^": 4,
                "&": 5,
                "==": 6,
                "!=": 6,
                "===": 6,
                "!==": 6,
                "<": 7,
                ">": 7,
                "<=": 7,
                ">=": 7,
                "<<": 8,
                ">>": 8,
                ">>>": 8,
                "+": 9,
                "-": 9,
                "*": 11,
                "/": 11,
                "%": 11
              };
              this.lookahead = {
                type: 2,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: 0,
                start: 0,
                end: 0
              };
              this.hasLineTerminator = false;
              this.context = {
                isModule: false,
                await: false,
                allowIn: true,
                allowStrictDirective: true,
                allowYield: true,
                firstCoverInitializedNameError: null,
                isAssignmentTarget: false,
                isBindingElement: false,
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                labelSet: {},
                strict: false
              };
              this.tokens = [];
              this.startMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.lastMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.nextToken();
              this.lastMarker = {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }
            Parser2.prototype.throwError = function(messageFormat) {
              var values = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
              }
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_1.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              throw this.errorHandler.createError(index, line, column, msg);
            };
            Parser2.prototype.tolerateError = function(messageFormat) {
              var values = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
              }
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_1.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index = this.lastMarker.index;
              var line = this.scanner.lineNumber;
              var column = this.lastMarker.column + 1;
              this.errorHandler.tolerateError(index, line, column, msg);
            };
            Parser2.prototype.unexpectedTokenError = function(token, message) {
              var msg = message || messages_1.Messages.UnexpectedToken;
              var value;
              if (token) {
                if (!message) {
                  msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                  if (token.type === 4) {
                    if (this.scanner.isFutureReservedWord(token.value)) {
                      msg = messages_1.Messages.UnexpectedReserved;
                    } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                      msg = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                value = token.value;
              } else {
                value = "ILLEGAL";
              }
              msg = msg.replace("%0", value);
              if (token && typeof token.lineNumber === "number") {
                var index = token.start;
                var line = token.lineNumber;
                var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                var column = token.start - lastMarkerLineStart + 1;
                return this.errorHandler.createError(index, line, column, msg);
              } else {
                var index = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                return this.errorHandler.createError(index, line, column, msg);
              }
            };
            Parser2.prototype.throwUnexpectedToken = function(token, message) {
              throw this.unexpectedTokenError(token, message);
            };
            Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
              this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
            };
            Parser2.prototype.collectComments = function() {
              if (!this.config.comment) {
                this.scanner.scanComments();
              } else {
                var comments = this.scanner.scanComments();
                if (comments.length > 0 && this.delegate) {
                  for (var i2 = 0; i2 < comments.length; ++i2) {
                    var e3 = comments[i2];
                    var node = void 0;
                    node = {
                      type: e3.multiLine ? "BlockComment" : "LineComment",
                      value: this.scanner.source.slice(e3.slice[0], e3.slice[1])
                    };
                    if (this.config.range) {
                      node.range = e3.range;
                    }
                    if (this.config.loc) {
                      node.loc = e3.loc;
                    }
                    var metadata = {
                      start: {
                        line: e3.loc.start.line,
                        column: e3.loc.start.column,
                        offset: e3.range[0]
                      },
                      end: {
                        line: e3.loc.end.line,
                        column: e3.loc.end.column,
                        offset: e3.range[1]
                      }
                    };
                    this.delegate(node, metadata);
                  }
                }
              }
            };
            Parser2.prototype.getTokenRaw = function(token) {
              return this.scanner.source.slice(token.start, token.end);
            };
            Parser2.prototype.convertToken = function(token) {
              var t3 = {
                type: token_1.TokenName[token.type],
                value: this.getTokenRaw(token)
              };
              if (this.config.range) {
                t3.range = [token.start, token.end];
              }
              if (this.config.loc) {
                t3.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                };
              }
              if (token.type === 9) {
                var pattern = token.pattern;
                var flags = token.flags;
                t3.regex = { pattern, flags };
              }
              return t3;
            };
            Parser2.prototype.nextToken = function() {
              var token = this.lookahead;
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              this.collectComments();
              if (this.scanner.index !== this.startMarker.index) {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              }
              var next = this.scanner.lex();
              this.hasLineTerminator = token.lineNumber !== next.lineNumber;
              if (next && this.context.strict && next.type === 3) {
                if (this.scanner.isStrictModeReservedWord(next.value)) {
                  next.type = 4;
                }
              }
              this.lookahead = next;
              if (this.config.tokens && next.type !== 2) {
                this.tokens.push(this.convertToken(next));
              }
              return token;
            };
            Parser2.prototype.nextRegexToken = function() {
              this.collectComments();
              var token = this.scanner.scanRegExp();
              if (this.config.tokens) {
                this.tokens.pop();
                this.tokens.push(this.convertToken(token));
              }
              this.lookahead = token;
              this.nextToken();
              return token;
            };
            Parser2.prototype.createNode = function() {
              return {
                index: this.startMarker.index,
                line: this.startMarker.line,
                column: this.startMarker.column
              };
            };
            Parser2.prototype.startNode = function(token, lastLineStart) {
              if (lastLineStart === void 0) {
                lastLineStart = 0;
              }
              var column = token.start - token.lineStart;
              var line = token.lineNumber;
              if (column < 0) {
                column += lastLineStart;
                line--;
              }
              return {
                index: token.start,
                line,
                column
              };
            };
            Parser2.prototype.finalize = function(marker, node) {
              if (this.config.range) {
                node.range = [marker.index, this.lastMarker.index];
              }
              if (this.config.loc) {
                node.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                };
                if (this.config.source) {
                  node.loc.source = this.config.source;
                }
              }
              if (this.delegate) {
                var metadata = {
                  start: {
                    line: marker.line,
                    column: marker.column,
                    offset: marker.index
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                  }
                };
                this.delegate(node, metadata);
              }
              return node;
            };
            Parser2.prototype.expect = function(value) {
              var token = this.nextToken();
              if (token.type !== 7 || token.value !== value) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser2.prototype.expectCommaSeparator = function() {
              if (this.config.tolerant) {
                var token = this.lookahead;
                if (token.type === 7 && token.value === ",") {
                  this.nextToken();
                } else if (token.type === 7 && token.value === ";") {
                  this.nextToken();
                  this.tolerateUnexpectedToken(token);
                } else {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                }
              } else {
                this.expect(",");
              }
            };
            Parser2.prototype.expectKeyword = function(keyword) {
              var token = this.nextToken();
              if (token.type !== 4 || token.value !== keyword) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser2.prototype.match = function(value) {
              return this.lookahead.type === 7 && this.lookahead.value === value;
            };
            Parser2.prototype.matchKeyword = function(keyword) {
              return this.lookahead.type === 4 && this.lookahead.value === keyword;
            };
            Parser2.prototype.matchContextualKeyword = function(keyword) {
              return this.lookahead.type === 3 && this.lookahead.value === keyword;
            };
            Parser2.prototype.matchAssign = function() {
              if (this.lookahead.type !== 7) {
                return false;
              }
              var op = this.lookahead.value;
              return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
            };
            Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              if (this.context.firstCoverInitializedNameError !== null) {
                this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
              }
              this.context.isBindingElement = previousIsBindingElement;
              this.context.isAssignmentTarget = previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
              return result;
            };
            Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
              this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
              return result;
            };
            Parser2.prototype.consumeSemicolon = function() {
              if (this.match(";")) {
                this.nextToken();
              } else if (!this.hasLineTerminator) {
                if (this.lookahead.type !== 2 && !this.match("}")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.lastMarker.index = this.startMarker.index;
                this.lastMarker.line = this.startMarker.line;
                this.lastMarker.column = this.startMarker.column;
              }
            };
            Parser2.prototype.parsePrimaryExpression = function() {
              var node = this.createNode();
              var expr;
              var token, raw;
              switch (this.lookahead.type) {
                case 3:
                  if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                  break;
                case 6:
                case 8:
                  if (this.context.strict && this.lookahead.octal) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.Literal(token.value, raw));
                  break;
                case 1:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                  break;
                case 5:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.Literal(null, raw));
                  break;
                case 10:
                  expr = this.parseTemplateLiteral();
                  break;
                case 7:
                  switch (this.lookahead.value) {
                    case "(":
                      this.context.isBindingElement = false;
                      expr = this.inheritCoverGrammar(this.parseGroupExpression);
                      break;
                    case "[":
                      expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                      break;
                    case "{":
                      expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                      break;
                    case "/":
                    case "/=":
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.scanner.index = this.startMarker.index;
                      token = this.nextRegexToken();
                      raw = this.getTokenRaw(token);
                      expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                      break;
                    default:
                      expr = this.throwUnexpectedToken(this.nextToken());
                  }
                  break;
                case 4:
                  if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                    expr = this.parseIdentifierName();
                  } else if (!this.context.strict && this.matchKeyword("let")) {
                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                  } else {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    if (this.matchKeyword("function")) {
                      expr = this.parseFunctionExpression();
                    } else if (this.matchKeyword("this")) {
                      this.nextToken();
                      expr = this.finalize(node, new Node.ThisExpression());
                    } else if (this.matchKeyword("class")) {
                      expr = this.parseClassExpression();
                    } else {
                      expr = this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  break;
                default:
                  expr = this.throwUnexpectedToken(this.nextToken());
              }
              return expr;
            };
            Parser2.prototype.parseSpreadElement = function() {
              var node = this.createNode();
              this.expect("...");
              var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
              return this.finalize(node, new Node.SpreadElement(arg));
            };
            Parser2.prototype.parseArrayInitializer = function() {
              var node = this.createNode();
              var elements = [];
              this.expect("[");
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else if (this.match("...")) {
                  var element = this.parseSpreadElement();
                  if (!this.match("]")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.expect(",");
                  }
                  elements.push(element);
                } else {
                  elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node, new Node.ArrayExpression(elements));
            };
            Parser2.prototype.parsePropertyMethod = function(params) {
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = params.simple;
              var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
              if (this.context.strict && params.firstRestricted) {
                this.tolerateUnexpectedToken(params.firstRestricted, params.message);
              }
              if (this.context.strict && params.stricted) {
                this.tolerateUnexpectedToken(params.stricted, params.message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              return body;
            };
            Parser2.prototype.parsePropertyMethodFunction = function() {
              var isGenerator = false;
              var node = this.createNode();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
              var node = this.createNode();
              var previousAllowYield = this.context.allowYield;
              var previousAwait = this.context.await;
              this.context.allowYield = false;
              this.context.await = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              this.context.await = previousAwait;
              return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
            };
            Parser2.prototype.parseObjectPropertyKey = function() {
              var node = this.createNode();
              var token = this.nextToken();
              var key;
              switch (token.type) {
                case 8:
                case 6:
                  if (this.context.strict && token.octal) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                  }
                  var raw = this.getTokenRaw(token);
                  key = this.finalize(node, new Node.Literal(token.value, raw));
                  break;
                case 3:
                case 1:
                case 5:
                case 4:
                  key = this.finalize(node, new Node.Identifier(token.value));
                  break;
                case 7:
                  if (token.value === "[") {
                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.expect("]");
                  } else {
                    key = this.throwUnexpectedToken(token);
                  }
                  break;
                default:
                  key = this.throwUnexpectedToken(token);
              }
              return key;
            };
            Parser2.prototype.isPropertyKey = function(key, value) {
              return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
            };
            Parser2.prototype.parseObjectProperty = function(hasProto) {
              var node = this.createNode();
              var token = this.lookahead;
              var kind;
              var key = null;
              var value = null;
              var computed = false;
              var method = false;
              var shorthand = false;
              var isAsync = false;
              if (token.type === 3) {
                var id = token.value;
                this.nextToken();
                computed = this.match("[");
                isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
              } else if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value = this.parseGetterMethod();
              } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseSetterMethod();
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseGeneratorMethod();
                method = true;
              } else {
                if (!key) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                kind = "init";
                if (this.match(":") && !isAsync) {
                  if (!computed && this.isPropertyKey(key, "__proto__")) {
                    if (hasProto.value) {
                      this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                    }
                    hasProto.value = true;
                  }
                  this.nextToken();
                  value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                } else if (this.match("(")) {
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                } else if (token.type === 3) {
                  var id = this.finalize(node, new Node.Identifier(token.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead;
                    this.nextToken();
                    shorthand = true;
                    var init3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value = this.finalize(node, new Node.AssignmentPattern(id, init3));
                  } else {
                    shorthand = true;
                    value = id;
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
            };
            Parser2.prototype.parseObjectInitializer = function() {
              var node = this.createNode();
              this.expect("{");
              var properties = [];
              var hasProto = { value: false };
              while (!this.match("}")) {
                properties.push(this.parseObjectProperty(hasProto));
                if (!this.match("}")) {
                  this.expectCommaSeparator();
                }
              }
              this.expect("}");
              return this.finalize(node, new Node.ObjectExpression(properties));
            };
            Parser2.prototype.parseTemplateHead = function() {
              assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
              var node = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser2.prototype.parseTemplateElement = function() {
              if (this.lookahead.type !== 10) {
                this.throwUnexpectedToken();
              }
              var node = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser2.prototype.parseTemplateLiteral = function() {
              var node = this.createNode();
              var expressions = [];
              var quasis = [];
              var quasi = this.parseTemplateHead();
              quasis.push(quasi);
              while (!quasi.tail) {
                expressions.push(this.parseExpression());
                quasi = this.parseTemplateElement();
                quasis.push(quasi);
              }
              return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
            };
            Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                case syntax_1.Syntax.MemberExpression:
                case syntax_1.Syntax.RestElement:
                case syntax_1.Syntax.AssignmentPattern:
                  break;
                case syntax_1.Syntax.SpreadElement:
                  expr.type = syntax_1.Syntax.RestElement;
                  this.reinterpretExpressionAsPattern(expr.argument);
                  break;
                case syntax_1.Syntax.ArrayExpression:
                  expr.type = syntax_1.Syntax.ArrayPattern;
                  for (var i2 = 0; i2 < expr.elements.length; i2++) {
                    if (expr.elements[i2] !== null) {
                      this.reinterpretExpressionAsPattern(expr.elements[i2]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectExpression:
                  expr.type = syntax_1.Syntax.ObjectPattern;
                  for (var i2 = 0; i2 < expr.properties.length; i2++) {
                    this.reinterpretExpressionAsPattern(expr.properties[i2].value);
                  }
                  break;
                case syntax_1.Syntax.AssignmentExpression:
                  expr.type = syntax_1.Syntax.AssignmentPattern;
                  delete expr.operator;
                  this.reinterpretExpressionAsPattern(expr.left);
                  break;
                default:
                  break;
              }
            };
            Parser2.prototype.parseGroupExpression = function() {
              var expr;
              this.expect("(");
              if (this.match(")")) {
                this.nextToken();
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [],
                  async: false
                };
              } else {
                var startToken = this.lookahead;
                var params = [];
                if (this.match("...")) {
                  expr = this.parseRestElement(params);
                  this.expect(")");
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [expr],
                    async: false
                  };
                } else {
                  var arrow = false;
                  this.context.isBindingElement = true;
                  expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  if (this.match(",")) {
                    var expressions = [];
                    this.context.isAssignmentTarget = false;
                    expressions.push(expr);
                    while (this.lookahead.type !== 2) {
                      if (!this.match(",")) {
                        break;
                      }
                      this.nextToken();
                      if (this.match(")")) {
                        this.nextToken();
                        for (var i2 = 0; i2 < expressions.length; i2++) {
                          this.reinterpretExpressionAsPattern(expressions[i2]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else if (this.match("...")) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        expressions.push(this.parseRestElement(params));
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        this.context.isBindingElement = false;
                        for (var i2 = 0; i2 < expressions.length; i2++) {
                          this.reinterpretExpressionAsPattern(expressions[i2]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else {
                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      }
                      if (arrow) {
                        break;
                      }
                    }
                    if (!arrow) {
                      expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                  }
                  if (!arrow) {
                    this.expect(")");
                    if (this.match("=>")) {
                      if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: [expr],
                          async: false
                        };
                      }
                      if (!arrow) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                          for (var i2 = 0; i2 < expr.expressions.length; i2++) {
                            this.reinterpretExpressionAsPattern(expr.expressions[i2]);
                          }
                        } else {
                          this.reinterpretExpressionAsPattern(expr);
                        }
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: false
                        };
                      }
                    }
                    this.context.isBindingElement = false;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.isIdentifierName = function(token) {
              return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
            };
            Parser2.prototype.parseIdentifierName = function() {
              var node = this.createNode();
              var token = this.nextToken();
              if (!this.isIdentifierName(token)) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node, new Node.Identifier(token.value));
            };
            Parser2.prototype.parseNewExpression = function() {
              var node = this.createNode();
              var id = this.parseIdentifierName();
              assert_1.assert(id.name === "new", "New expression must start with `new`");
              var expr;
              if (this.match(".")) {
                this.nextToken();
                if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                  var property = this.parseIdentifierName();
                  expr = new Node.MetaProperty(id, property);
                } else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                var args = this.match("(") ? this.parseArguments() : [];
                expr = new Node.NewExpression(callee, args);
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return this.finalize(node, expr);
            };
            Parser2.prototype.parseAsyncArgument = function() {
              var arg = this.parseAssignmentExpression();
              this.context.firstCoverInitializedNameError = null;
              return arg;
            };
            Parser2.prototype.parseAsyncArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
              var startToken = this.lookahead;
              var maybeAsync = this.matchContextualKeyword("async");
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var expr;
              if (this.matchKeyword("super") && this.context.inFunctionBody) {
                expr = this.createNode();
                this.nextToken();
                expr = this.finalize(expr, new Node.Super());
                if (!this.match("(") && !this.match(".") && !this.match("[")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              }
              while (true) {
                if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                } else if (this.match("(")) {
                  var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = false;
                  var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                  expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                  if (asyncArrow && this.match("=>")) {
                    for (var i2 = 0; i2 < args.length; ++i2) {
                      this.reinterpretExpressionAsPattern(args[i2]);
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: args,
                      async: true
                    };
                  }
                } else if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              this.context.allowIn = previousAllowIn;
              return expr;
            };
            Parser2.prototype.parseSuper = function() {
              var node = this.createNode();
              this.expectKeyword("super");
              if (!this.match("[") && !this.match(".")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              return this.finalize(node, new Node.Super());
            };
            Parser2.prototype.parseLeftHandSideExpression = function() {
              assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
              var node = this.startNode(this.lookahead);
              var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              while (true) {
                if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                } else if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              return expr;
            };
            Parser2.prototype.parseUpdateExpression = function() {
              var expr;
              var startToken = this.lookahead;
              if (this.match("++") || this.match("--")) {
                var node = this.startNode(startToken);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                  this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                var prefix = true;
                expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else {
                expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                if (!this.hasLineTerminator && this.lookahead.type === 7) {
                  if (this.match("++") || this.match("--")) {
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                      this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                    }
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var operator = this.nextToken().value;
                    var prefix = false;
                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseAwaitExpression = function() {
              var node = this.createNode();
              this.nextToken();
              var argument = this.parseUnaryExpression();
              return this.finalize(node, new Node.AwaitExpression(argument));
            };
            Parser2.prototype.parseUnaryExpression = function() {
              var expr;
              if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                var node = this.startNode(this.lookahead);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                  this.tolerateError(messages_1.Messages.StrictDelete);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else if (this.context.await && this.matchContextualKeyword("await")) {
                expr = this.parseAwaitExpression();
              } else {
                expr = this.parseUpdateExpression();
              }
              return expr;
            };
            Parser2.prototype.parseExponentiationExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
              }
              return expr;
            };
            Parser2.prototype.binaryPrecedence = function(token) {
              var op = token.value;
              var precedence;
              if (token.type === 7) {
                precedence = this.operatorPrecedence[op] || 0;
              } else if (token.type === 4) {
                precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
              } else {
                precedence = 0;
              }
              return precedence;
            };
            Parser2.prototype.parseBinaryExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
              var token = this.lookahead;
              var prec = this.binaryPrecedence(token);
              if (prec > 0) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var markers = [startToken, this.lookahead];
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                var stack = [left, token.value, right];
                var precedences = [prec];
                while (true) {
                  prec = this.binaryPrecedence(this.lookahead);
                  if (prec <= 0) {
                    break;
                  }
                  while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                    right = stack.pop();
                    var operator = stack.pop();
                    precedences.pop();
                    left = stack.pop();
                    markers.pop();
                    var node = this.startNode(markers[markers.length - 1]);
                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                  }
                  stack.push(this.nextToken().value);
                  precedences.push(prec);
                  markers.push(this.lookahead);
                  stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                }
                var i2 = stack.length - 1;
                expr = stack[i2];
                var lastMarker = markers.pop();
                while (i2 > 1) {
                  var marker = markers.pop();
                  var lastLineStart = lastMarker && lastMarker.lineStart;
                  var node = this.startNode(marker, lastLineStart);
                  var operator = stack[i2 - 1];
                  expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i2 - 2], expr));
                  i2 -= 2;
                  lastMarker = marker;
                }
              }
              return expr;
            };
            Parser2.prototype.parseConditionalExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
              if (this.match("?")) {
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                this.expect(":");
                var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return expr;
            };
            Parser2.prototype.checkPatternParam = function(options, param) {
              switch (param.type) {
                case syntax_1.Syntax.Identifier:
                  this.validateParam(options, param, param.name);
                  break;
                case syntax_1.Syntax.RestElement:
                  this.checkPatternParam(options, param.argument);
                  break;
                case syntax_1.Syntax.AssignmentPattern:
                  this.checkPatternParam(options, param.left);
                  break;
                case syntax_1.Syntax.ArrayPattern:
                  for (var i2 = 0; i2 < param.elements.length; i2++) {
                    if (param.elements[i2] !== null) {
                      this.checkPatternParam(options, param.elements[i2]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectPattern:
                  for (var i2 = 0; i2 < param.properties.length; i2++) {
                    this.checkPatternParam(options, param.properties[i2].value);
                  }
                  break;
                default:
                  break;
              }
              options.simple = options.simple && param instanceof Node.Identifier;
            };
            Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
              var params = [expr];
              var options;
              var asyncArrow = false;
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                  break;
                case ArrowParameterPlaceHolder:
                  params = expr.params;
                  asyncArrow = expr.async;
                  break;
                default:
                  return null;
              }
              options = {
                simple: true,
                paramSet: {}
              };
              for (var i2 = 0; i2 < params.length; ++i2) {
                var param = params[i2];
                if (param.type === syntax_1.Syntax.AssignmentPattern) {
                  if (param.right.type === syntax_1.Syntax.YieldExpression) {
                    if (param.right.argument) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    param.right.type = syntax_1.Syntax.Identifier;
                    param.right.name = "yield";
                    delete param.right.argument;
                    delete param.right.delegate;
                  }
                } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.checkPatternParam(options, param);
                params[i2] = param;
              }
              if (this.context.strict || !this.context.allowYield) {
                for (var i2 = 0; i2 < params.length; ++i2) {
                  var param = params[i2];
                  if (param.type === syntax_1.Syntax.YieldExpression) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              }
              if (options.message === messages_1.Messages.StrictParamDupe) {
                var token = this.context.strict ? options.stricted : options.firstRestricted;
                this.throwUnexpectedToken(token, options.message);
              }
              return {
                simple: options.simple,
                params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser2.prototype.parseAssignmentExpression = function() {
              var expr;
              if (!this.context.allowYield && this.matchKeyword("yield")) {
                expr = this.parseYieldExpression();
              } else {
                var startToken = this.lookahead;
                var token = startToken;
                expr = this.parseConditionalExpression();
                if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                  if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg);
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: true
                    };
                  }
                }
                if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var isAsync = expr.async;
                  var list = this.reinterpretAsCoverFormalsList(expr);
                  if (list) {
                    if (this.hasLineTerminator) {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    this.context.firstCoverInitializedNameError = null;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = list.simple;
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = true;
                    this.context.await = isAsync;
                    var node = this.startNode(startToken);
                    this.expect("=>");
                    var body = void 0;
                    if (this.match("{")) {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      body = this.parseFunctionSourceElements();
                      this.context.allowIn = previousAllowIn;
                    } else {
                      body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
                    if (this.context.strict && list.firstRestricted) {
                      this.throwUnexpectedToken(list.firstRestricted, list.message);
                    }
                    if (this.context.strict && list.stricted) {
                      this.tolerateUnexpectedToken(list.stricted, list.message);
                    }
                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                  }
                } else {
                  if (this.matchAssign()) {
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                      }
                      if (this.scanner.isStrictModeReservedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      }
                    }
                    if (!this.match("=")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      this.reinterpretExpressionAsPattern(expr);
                    }
                    token = this.nextToken();
                    var operator = token.value;
                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                    this.context.firstCoverInitializedNameError = null;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseExpression = function() {
              var startToken = this.lookahead;
              var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var expressions = [];
                expressions.push(expr);
                while (this.lookahead.type !== 2) {
                  if (!this.match(",")) {
                    break;
                  }
                  this.nextToken();
                  expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                }
                expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
              }
              return expr;
            };
            Parser2.prototype.parseStatementListItem = function() {
              var statement;
              this.context.isAssignmentTarget = true;
              this.context.isBindingElement = true;
              if (this.lookahead.type === 4) {
                switch (this.lookahead.value) {
                  case "export":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                    }
                    statement = this.parseExportDeclaration();
                    break;
                  case "import":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                    }
                    statement = this.parseImportDeclaration();
                    break;
                  case "const":
                    statement = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    statement = this.parseClassDeclaration();
                    break;
                  case "let":
                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                  default:
                    statement = this.parseStatement();
                    break;
                }
              } else {
                statement = this.parseStatement();
              }
              return statement;
            };
            Parser2.prototype.parseBlock = function() {
              var node = this.createNode();
              this.expect("{");
              var block3 = [];
              while (true) {
                if (this.match("}")) {
                  break;
                }
                block3.push(this.parseStatementListItem());
              }
              this.expect("}");
              return this.finalize(node, new Node.BlockStatement(block3));
            };
            Parser2.prototype.parseLexicalBinding = function(kind, options) {
              var node = this.createNode();
              var params = [];
              var id = this.parsePattern(params, kind);
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init3 = null;
              if (kind === "const") {
                if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                  if (this.match("=")) {
                    this.nextToken();
                    init3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  } else {
                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                  }
                }
              } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                this.expect("=");
                init3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              }
              return this.finalize(node, new Node.VariableDeclarator(id, init3));
            };
            Parser2.prototype.parseBindingList = function(kind, options) {
              var list = [this.parseLexicalBinding(kind, options)];
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseLexicalBinding(kind, options));
              }
              return list;
            };
            Parser2.prototype.isLexicalDeclaration = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
            };
            Parser2.prototype.parseLexicalDeclaration = function(options) {
              var node = this.createNode();
              var kind = this.nextToken().value;
              assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
              var declarations = this.parseBindingList(kind, options);
              this.consumeSemicolon();
              return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
            };
            Parser2.prototype.parseBindingRestElement = function(params, kind) {
              var node = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params, kind);
              return this.finalize(node, new Node.RestElement(arg));
            };
            Parser2.prototype.parseArrayPattern = function(params, kind) {
              var node = this.createNode();
              this.expect("[");
              var elements = [];
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else {
                  if (this.match("...")) {
                    elements.push(this.parseBindingRestElement(params, kind));
                    break;
                  } else {
                    elements.push(this.parsePatternWithDefault(params, kind));
                  }
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node, new Node.ArrayPattern(elements));
            };
            Parser2.prototype.parsePropertyPattern = function(params, kind) {
              var node = this.createNode();
              var computed = false;
              var shorthand = false;
              var method = false;
              var key;
              var value;
              if (this.lookahead.type === 3) {
                var keyToken = this.lookahead;
                key = this.parseVariableIdentifier();
                var init3 = this.finalize(node, new Node.Identifier(keyToken.value));
                if (this.match("=")) {
                  params.push(keyToken);
                  shorthand = true;
                  this.nextToken();
                  var expr = this.parseAssignmentExpression();
                  value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init3, expr));
                } else if (!this.match(":")) {
                  params.push(keyToken);
                  shorthand = true;
                  value = init3;
                } else {
                  this.expect(":");
                  value = this.parsePatternWithDefault(params, kind);
                }
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.expect(":");
                value = this.parsePatternWithDefault(params, kind);
              }
              return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
            };
            Parser2.prototype.parseObjectPattern = function(params, kind) {
              var node = this.createNode();
              var properties = [];
              this.expect("{");
              while (!this.match("}")) {
                properties.push(this.parsePropertyPattern(params, kind));
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return this.finalize(node, new Node.ObjectPattern(properties));
            };
            Parser2.prototype.parsePattern = function(params, kind) {
              var pattern;
              if (this.match("[")) {
                pattern = this.parseArrayPattern(params, kind);
              } else if (this.match("{")) {
                pattern = this.parseObjectPattern(params, kind);
              } else {
                if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                }
                params.push(this.lookahead);
                pattern = this.parseVariableIdentifier(kind);
              }
              return pattern;
            };
            Parser2.prototype.parsePatternWithDefault = function(params, kind) {
              var startToken = this.lookahead;
              var pattern = this.parsePattern(params, kind);
              if (this.match("=")) {
                this.nextToken();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowYield = previousAllowYield;
                pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
              }
              return pattern;
            };
            Parser2.prototype.parseVariableIdentifier = function(kind) {
              var node = this.createNode();
              var token = this.nextToken();
              if (token.type === 4 && token.value === "yield") {
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else if (!this.context.allowYield) {
                  this.throwUnexpectedToken(token);
                }
              } else if (token.type !== 3) {
                if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else {
                  if (this.context.strict || token.value !== "let" || kind !== "var") {
                    this.throwUnexpectedToken(token);
                  }
                }
              } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                this.tolerateUnexpectedToken(token);
              }
              return this.finalize(node, new Node.Identifier(token.value));
            };
            Parser2.prototype.parseVariableDeclaration = function(options) {
              var node = this.createNode();
              var params = [];
              var id = this.parsePattern(params, "var");
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init3 = null;
              if (this.match("=")) {
                this.nextToken();
                init3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                this.expect("=");
              }
              return this.finalize(node, new Node.VariableDeclarator(id, init3));
            };
            Parser2.prototype.parseVariableDeclarationList = function(options) {
              var opt = { inFor: options.inFor };
              var list = [];
              list.push(this.parseVariableDeclaration(opt));
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseVariableDeclaration(opt));
              }
              return list;
            };
            Parser2.prototype.parseVariableStatement = function() {
              var node = this.createNode();
              this.expectKeyword("var");
              var declarations = this.parseVariableDeclarationList({ inFor: false });
              this.consumeSemicolon();
              return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
            };
            Parser2.prototype.parseEmptyStatement = function() {
              var node = this.createNode();
              this.expect(";");
              return this.finalize(node, new Node.EmptyStatement());
            };
            Parser2.prototype.parseExpressionStatement = function() {
              var node = this.createNode();
              var expr = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node, new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseIfClause = function() {
              if (this.context.strict && this.matchKeyword("function")) {
                this.tolerateError(messages_1.Messages.StrictFunction);
              }
              return this.parseStatement();
            };
            Parser2.prototype.parseIfStatement = function() {
              var node = this.createNode();
              var consequent;
              var alternate = null;
              this.expectKeyword("if");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                consequent = this.parseIfClause();
                if (this.matchKeyword("else")) {
                  this.nextToken();
                  alternate = this.parseIfClause();
                }
              }
              return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
            };
            Parser2.prototype.parseDoWhileStatement = function() {
              var node = this.createNode();
              this.expectKeyword("do");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              var body = this.parseStatement();
              this.context.inIteration = previousInIteration;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
              } else {
                this.expect(")");
                if (this.match(";")) {
                  this.nextToken();
                }
              }
              return this.finalize(node, new Node.DoWhileStatement(body, test));
            };
            Parser2.prototype.parseWhileStatement = function() {
              var node = this.createNode();
              var body;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.parseStatement();
                this.context.inIteration = previousInIteration;
              }
              return this.finalize(node, new Node.WhileStatement(test, body));
            };
            Parser2.prototype.parseForStatement = function() {
              var init3 = null;
              var test = null;
              var update = null;
              var forIn = true;
              var left, right;
              var node = this.createNode();
              this.expectKeyword("for");
              this.expect("(");
              if (this.match(";")) {
                this.nextToken();
              } else {
                if (this.matchKeyword("var")) {
                  init3 = this.createNode();
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseVariableDeclarationList({ inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                      this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                    }
                    init3 = this.finalize(init3, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init3;
                    right = this.parseExpression();
                    init3 = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init3 = this.finalize(init3, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init3;
                    right = this.parseAssignmentExpression();
                    init3 = null;
                    forIn = false;
                  } else {
                    init3 = this.finalize(init3, new Node.VariableDeclaration(declarations, "var"));
                    this.expect(";");
                  }
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init3 = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in") {
                    init3 = this.finalize(init3, new Node.Identifier(kind));
                    this.nextToken();
                    left = init3;
                    right = this.parseExpression();
                    init3 = null;
                  } else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseBindingList(kind, { inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                      init3 = this.finalize(init3, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init3;
                      right = this.parseExpression();
                      init3 = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init3 = this.finalize(init3, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init3;
                      right = this.parseAssignmentExpression();
                      init3 = null;
                      forIn = false;
                    } else {
                      this.consumeSemicolon();
                      init3 = this.finalize(init3, new Node.VariableDeclaration(declarations, kind));
                    }
                  }
                } else {
                  var initStartToken = this.lookahead;
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  init3 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  if (this.matchKeyword("in")) {
                    if (!this.context.isAssignmentTarget || init3.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init3);
                    left = init3;
                    right = this.parseExpression();
                    init3 = null;
                  } else if (this.matchContextualKeyword("of")) {
                    if (!this.context.isAssignmentTarget || init3.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init3);
                    left = init3;
                    right = this.parseAssignmentExpression();
                    init3 = null;
                    forIn = false;
                  } else {
                    if (this.match(",")) {
                      var initSeq = [init3];
                      while (this.match(",")) {
                        this.nextToken();
                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      init3 = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
              }
              if (typeof left === "undefined") {
                if (!this.match(";")) {
                  test = this.parseExpression();
                }
                this.expect(";");
                if (!this.match(")")) {
                  update = this.parseExpression();
                }
              }
              var body;
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.isolateCoverGrammar(this.parseStatement);
                this.context.inIteration = previousInIteration;
              }
              return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init3, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
            };
            Parser2.prototype.parseContinueStatement = function() {
              var node = this.createNode();
              this.expectKeyword("continue");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                label = id;
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration) {
                this.throwError(messages_1.Messages.IllegalContinue);
              }
              return this.finalize(node, new Node.ContinueStatement(label));
            };
            Parser2.prototype.parseBreakStatement = function() {
              var node = this.createNode();
              this.expectKeyword("break");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                label = id;
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                this.throwError(messages_1.Messages.IllegalBreak);
              }
              return this.finalize(node, new Node.BreakStatement(label));
            };
            Parser2.prototype.parseReturnStatement = function() {
              if (!this.context.inFunctionBody) {
                this.tolerateError(messages_1.Messages.IllegalReturn);
              }
              var node = this.createNode();
              this.expectKeyword("return");
              var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
              var argument = hasArgument ? this.parseExpression() : null;
              this.consumeSemicolon();
              return this.finalize(node, new Node.ReturnStatement(argument));
            };
            Parser2.prototype.parseWithStatement = function() {
              if (this.context.strict) {
                this.tolerateError(messages_1.Messages.StrictModeWith);
              }
              var node = this.createNode();
              var body;
              this.expectKeyword("with");
              this.expect("(");
              var object = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                body = this.parseStatement();
              }
              return this.finalize(node, new Node.WithStatement(object, body));
            };
            Parser2.prototype.parseSwitchCase = function() {
              var node = this.createNode();
              var test;
              if (this.matchKeyword("default")) {
                this.nextToken();
                test = null;
              } else {
                this.expectKeyword("case");
                test = this.parseExpression();
              }
              this.expect(":");
              var consequent = [];
              while (true) {
                if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                  break;
                }
                consequent.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.SwitchCase(test, consequent));
            };
            Parser2.prototype.parseSwitchStatement = function() {
              var node = this.createNode();
              this.expectKeyword("switch");
              this.expect("(");
              var discriminant = this.parseExpression();
              this.expect(")");
              var previousInSwitch = this.context.inSwitch;
              this.context.inSwitch = true;
              var cases = [];
              var defaultFound = false;
              this.expect("{");
              while (true) {
                if (this.match("}")) {
                  break;
                }
                var clause = this.parseSwitchCase();
                if (clause.test === null) {
                  if (defaultFound) {
                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                  }
                  defaultFound = true;
                }
                cases.push(clause);
              }
              this.expect("}");
              this.context.inSwitch = previousInSwitch;
              return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
            };
            Parser2.prototype.parseLabelledStatement = function() {
              var node = this.createNode();
              var expr = this.parseExpression();
              var statement;
              if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                this.nextToken();
                var id = expr;
                var key = "$" + id.name;
                if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                }
                this.context.labelSet[key] = true;
                var body = void 0;
                if (this.matchKeyword("class")) {
                  this.tolerateUnexpectedToken(this.lookahead);
                  body = this.parseClassDeclaration();
                } else if (this.matchKeyword("function")) {
                  var token = this.lookahead;
                  var declaration = this.parseFunctionDeclaration();
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                  } else if (declaration.generator) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                  }
                  body = declaration;
                } else {
                  body = this.parseStatement();
                }
                delete this.context.labelSet[key];
                statement = new Node.LabeledStatement(id, body);
              } else {
                this.consumeSemicolon();
                statement = new Node.ExpressionStatement(expr);
              }
              return this.finalize(node, statement);
            };
            Parser2.prototype.parseThrowStatement = function() {
              var node = this.createNode();
              this.expectKeyword("throw");
              if (this.hasLineTerminator) {
                this.throwError(messages_1.Messages.NewlineAfterThrow);
              }
              var argument = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node, new Node.ThrowStatement(argument));
            };
            Parser2.prototype.parseCatchClause = function() {
              var node = this.createNode();
              this.expectKeyword("catch");
              this.expect("(");
              if (this.match(")")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              var params = [];
              var param = this.parsePattern(params);
              var paramMap = {};
              for (var i2 = 0; i2 < params.length; i2++) {
                var key = "$" + params[i2].value;
                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                  this.tolerateError(messages_1.Messages.DuplicateBinding, params[i2].value);
                }
                paramMap[key] = true;
              }
              if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(param.name)) {
                  this.tolerateError(messages_1.Messages.StrictCatchVariable);
                }
              }
              this.expect(")");
              var body = this.parseBlock();
              return this.finalize(node, new Node.CatchClause(param, body));
            };
            Parser2.prototype.parseFinallyClause = function() {
              this.expectKeyword("finally");
              return this.parseBlock();
            };
            Parser2.prototype.parseTryStatement = function() {
              var node = this.createNode();
              this.expectKeyword("try");
              var block3 = this.parseBlock();
              var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
              var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
              if (!handler && !finalizer) {
                this.throwError(messages_1.Messages.NoCatchOrFinally);
              }
              return this.finalize(node, new Node.TryStatement(block3, handler, finalizer));
            };
            Parser2.prototype.parseDebuggerStatement = function() {
              var node = this.createNode();
              this.expectKeyword("debugger");
              this.consumeSemicolon();
              return this.finalize(node, new Node.DebuggerStatement());
            };
            Parser2.prototype.parseStatement = function() {
              var statement;
              switch (this.lookahead.type) {
                case 1:
                case 5:
                case 6:
                case 8:
                case 10:
                case 9:
                  statement = this.parseExpressionStatement();
                  break;
                case 7:
                  var value = this.lookahead.value;
                  if (value === "{") {
                    statement = this.parseBlock();
                  } else if (value === "(") {
                    statement = this.parseExpressionStatement();
                  } else if (value === ";") {
                    statement = this.parseEmptyStatement();
                  } else {
                    statement = this.parseExpressionStatement();
                  }
                  break;
                case 3:
                  statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                  break;
                case 4:
                  switch (this.lookahead.value) {
                    case "break":
                      statement = this.parseBreakStatement();
                      break;
                    case "continue":
                      statement = this.parseContinueStatement();
                      break;
                    case "debugger":
                      statement = this.parseDebuggerStatement();
                      break;
                    case "do":
                      statement = this.parseDoWhileStatement();
                      break;
                    case "for":
                      statement = this.parseForStatement();
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "if":
                      statement = this.parseIfStatement();
                      break;
                    case "return":
                      statement = this.parseReturnStatement();
                      break;
                    case "switch":
                      statement = this.parseSwitchStatement();
                      break;
                    case "throw":
                      statement = this.parseThrowStatement();
                      break;
                    case "try":
                      statement = this.parseTryStatement();
                      break;
                    case "var":
                      statement = this.parseVariableStatement();
                      break;
                    case "while":
                      statement = this.parseWhileStatement();
                      break;
                    case "with":
                      statement = this.parseWithStatement();
                      break;
                    default:
                      statement = this.parseExpressionStatement();
                      break;
                  }
                  break;
                default:
                  statement = this.throwUnexpectedToken(this.lookahead);
              }
              return statement;
            };
            Parser2.prototype.parseFunctionSourceElements = function() {
              var node = this.createNode();
              this.expect("{");
              var body = this.parseDirectivePrologues();
              var previousLabelSet = this.context.labelSet;
              var previousInIteration = this.context.inIteration;
              var previousInSwitch = this.context.inSwitch;
              var previousInFunctionBody = this.context.inFunctionBody;
              this.context.labelSet = {};
              this.context.inIteration = false;
              this.context.inSwitch = false;
              this.context.inFunctionBody = true;
              while (this.lookahead.type !== 2) {
                if (this.match("}")) {
                  break;
                }
                body.push(this.parseStatementListItem());
              }
              this.expect("}");
              this.context.labelSet = previousLabelSet;
              this.context.inIteration = previousInIteration;
              this.context.inSwitch = previousInSwitch;
              this.context.inFunctionBody = previousInFunctionBody;
              return this.finalize(node, new Node.BlockStatement(body));
            };
            Parser2.prototype.validateParam = function(options, param, name) {
              var key = "$" + name;
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(name)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamName;
                }
                if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              } else if (!options.firstRestricted) {
                if (this.scanner.isRestrictedWord(name)) {
                  options.firstRestricted = param;
                  options.message = messages_1.Messages.StrictParamName;
                } else if (this.scanner.isStrictModeReservedWord(name)) {
                  options.firstRestricted = param;
                  options.message = messages_1.Messages.StrictReservedWord;
                } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              }
              if (typeof Object.defineProperty === "function") {
                Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
              } else {
                options.paramSet[key] = true;
              }
            };
            Parser2.prototype.parseRestElement = function(params) {
              var node = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params);
              if (this.match("=")) {
                this.throwError(messages_1.Messages.DefaultRestParameter);
              }
              if (!this.match(")")) {
                this.throwError(messages_1.Messages.ParameterAfterRestParameter);
              }
              return this.finalize(node, new Node.RestElement(arg));
            };
            Parser2.prototype.parseFormalParameter = function(options) {
              var params = [];
              var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
              for (var i2 = 0; i2 < params.length; i2++) {
                this.validateParam(options, params[i2], params[i2].value);
              }
              options.simple = options.simple && param instanceof Node.Identifier;
              options.params.push(param);
            };
            Parser2.prototype.parseFormalParameters = function(firstRestricted) {
              var options;
              options = {
                simple: true,
                params: [],
                firstRestricted
              };
              this.expect("(");
              if (!this.match(")")) {
                options.paramSet = {};
                while (this.lookahead.type !== 2) {
                  this.parseFormalParameter(options);
                  if (this.match(")")) {
                    break;
                  }
                  this.expect(",");
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return {
                simple: options.simple,
                params: options.params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser2.prototype.matchAsyncFunction = function() {
              var match = this.matchContextualKeyword("async");
              if (match) {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state);
                match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
              }
              return match;
            };
            Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
              var node = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted = null;
              if (!identifierIsOptional || !this.match("(")) {
                var token = this.lookahead;
                id = this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
            };
            Parser2.prototype.parseFunctionExpression = function() {
              var node = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted;
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              if (!this.match("(")) {
                var token = this.lookahead;
                id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
            };
            Parser2.prototype.parseDirective = function() {
              var token = this.lookahead;
              var node = this.createNode();
              var expr = this.parseExpression();
              var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
              this.consumeSemicolon();
              return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseDirectivePrologues = function() {
              var firstRestricted = null;
              var body = [];
              while (true) {
                var token = this.lookahead;
                if (token.type !== 8) {
                  break;
                }
                var statement = this.parseDirective();
                body.push(statement);
                var directive = statement.directive;
                if (typeof directive !== "string") {
                  break;
                }
                if (directive === "use strict") {
                  this.context.strict = true;
                  if (firstRestricted) {
                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                  }
                  if (!this.context.allowStrictDirective) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                  }
                } else {
                  if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                  }
                }
              }
              return body;
            };
            Parser2.prototype.qualifiedPropertyName = function(token) {
              switch (token.type) {
                case 3:
                case 8:
                case 1:
                case 5:
                case 6:
                case 4:
                  return true;
                case 7:
                  return token.value === "[";
                default:
                  break;
              }
              return false;
            };
            Parser2.prototype.parseGetterMethod = function() {
              var node = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length > 0) {
                this.tolerateError(messages_1.Messages.BadGetterArity);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseSetterMethod = function() {
              var node = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length !== 1) {
                this.tolerateError(messages_1.Messages.BadSetterArity);
              } else if (formalParameters.params[0] instanceof Node.RestElement) {
                this.tolerateError(messages_1.Messages.BadSetterRestParameter);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseGeneratorMethod = function() {
              var node = this.createNode();
              var isGenerator = true;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              this.context.allowYield = false;
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.isStartOfExpression = function() {
              var start = true;
              var value = this.lookahead.value;
              switch (this.lookahead.type) {
                case 7:
                  start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                  break;
                case 4:
                  start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                  break;
                default:
                  break;
              }
              return start;
            };
            Parser2.prototype.parseYieldExpression = function() {
              var node = this.createNode();
              this.expectKeyword("yield");
              var argument = null;
              var delegate = false;
              if (!this.hasLineTerminator) {
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = false;
                delegate = this.match("*");
                if (delegate) {
                  this.nextToken();
                  argument = this.parseAssignmentExpression();
                } else if (this.isStartOfExpression()) {
                  argument = this.parseAssignmentExpression();
                }
                this.context.allowYield = previousAllowYield;
              }
              return this.finalize(node, new Node.YieldExpression(argument, delegate));
            };
            Parser2.prototype.parseClassElement = function(hasConstructor) {
              var token = this.lookahead;
              var node = this.createNode();
              var kind = "";
              var key = null;
              var value = null;
              var computed = false;
              var method = false;
              var isStatic = false;
              var isAsync = false;
              if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                var id = key;
                if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                  token = this.lookahead;
                  isStatic = true;
                  computed = this.match("[");
                  if (this.match("*")) {
                    this.nextToken();
                  } else {
                    key = this.parseObjectPropertyKey();
                  }
                }
                if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                  var punctuator = this.lookahead.value;
                  if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                    isAsync = true;
                    token = this.lookahead;
                    key = this.parseObjectPropertyKey();
                    if (token.type === 3 && token.value === "constructor") {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                    }
                  }
                }
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3) {
                if (token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value = this.parseGetterMethod();
                } else if (token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseSetterMethod();
                }
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseGeneratorMethod();
                method = true;
              }
              if (!kind && key && this.match("(")) {
                kind = "init";
                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              }
              if (!kind) {
                this.throwUnexpectedToken(this.lookahead);
              }
              if (kind === "init") {
                kind = "method";
              }
              if (!computed) {
                if (isStatic && this.isPropertyKey(key, "prototype")) {
                  this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                }
                if (!isStatic && this.isPropertyKey(key, "constructor")) {
                  if (kind !== "method" || !method || value && value.generator) {
                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                  }
                  if (hasConstructor.value) {
                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                  } else {
                    hasConstructor.value = true;
                  }
                  kind = "constructor";
                }
              }
              return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
            };
            Parser2.prototype.parseClassElementList = function() {
              var body = [];
              var hasConstructor = { value: false };
              this.expect("{");
              while (!this.match("}")) {
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  body.push(this.parseClassElement(hasConstructor));
                }
              }
              this.expect("}");
              return body;
            };
            Parser2.prototype.parseClassBody = function() {
              var node = this.createNode();
              var elementList = this.parseClassElementList();
              return this.finalize(node, new Node.ClassBody(elementList));
            };
            Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
              var node = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
            };
            Parser2.prototype.parseClassExpression = function() {
              var node = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
            };
            Parser2.prototype.parseModule = function() {
              this.context.strict = true;
              this.context.isModule = true;
              this.scanner.isModule = true;
              var node = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.Module(body));
            };
            Parser2.prototype.parseScript = function() {
              var node = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.Script(body));
            };
            Parser2.prototype.parseModuleSpecifier = function() {
              var node = this.createNode();
              if (this.lookahead.type !== 8) {
                this.throwError(messages_1.Messages.InvalidModuleSpecifier);
              }
              var token = this.nextToken();
              var raw = this.getTokenRaw(token);
              return this.finalize(node, new Node.Literal(token.value, raw));
            };
            Parser2.prototype.parseImportSpecifier = function() {
              var node = this.createNode();
              var imported;
              var local;
              if (this.lookahead.type === 3) {
                imported = this.parseVariableIdentifier();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                }
              } else {
                imported = this.parseIdentifierName();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node, new Node.ImportSpecifier(local, imported));
            };
            Parser2.prototype.parseNamedImports = function() {
              this.expect("{");
              var specifiers = [];
              while (!this.match("}")) {
                specifiers.push(this.parseImportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return specifiers;
            };
            Parser2.prototype.parseImportDefaultSpecifier = function() {
              var node = this.createNode();
              var local = this.parseIdentifierName();
              return this.finalize(node, new Node.ImportDefaultSpecifier(local));
            };
            Parser2.prototype.parseImportNamespaceSpecifier = function() {
              var node = this.createNode();
              this.expect("*");
              if (!this.matchContextualKeyword("as")) {
                this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
              }
              this.nextToken();
              var local = this.parseIdentifierName();
              return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
            };
            Parser2.prototype.parseImportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalImportDeclaration);
              }
              var node = this.createNode();
              this.expectKeyword("import");
              var src;
              var specifiers = [];
              if (this.lookahead.type === 8) {
                src = this.parseModuleSpecifier();
              } else {
                if (this.match("{")) {
                  specifiers = specifiers.concat(this.parseNamedImports());
                } else if (this.match("*")) {
                  specifiers.push(this.parseImportNamespaceSpecifier());
                } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                  specifiers.push(this.parseImportDefaultSpecifier());
                  if (this.match(",")) {
                    this.nextToken();
                    if (this.match("*")) {
                      specifiers.push(this.parseImportNamespaceSpecifier());
                    } else if (this.match("{")) {
                      specifiers = specifiers.concat(this.parseNamedImports());
                    } else {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                src = this.parseModuleSpecifier();
              }
              this.consumeSemicolon();
              return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
            };
            Parser2.prototype.parseExportSpecifier = function() {
              var node = this.createNode();
              var local = this.parseIdentifierName();
              var exported = local;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                exported = this.parseIdentifierName();
              }
              return this.finalize(node, new Node.ExportSpecifier(local, exported));
            };
            Parser2.prototype.parseExportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalExportDeclaration);
              }
              var node = this.createNode();
              this.expectKeyword("export");
              var exportDeclaration;
              if (this.matchKeyword("default")) {
                this.nextToken();
                if (this.matchKeyword("function")) {
                  var declaration = this.parseFunctionDeclaration(true);
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchKeyword("class")) {
                  var declaration = this.parseClassDeclaration(true);
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchContextualKeyword("async")) {
                  var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else {
                  if (this.matchContextualKeyword("from")) {
                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                  }
                  var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                }
              } else if (this.match("*")) {
                this.nextToken();
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                var src = this.parseModuleSpecifier();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
              } else if (this.lookahead.type === 4) {
                var declaration = void 0;
                switch (this.lookahead.value) {
                  case "let":
                  case "const":
                    declaration = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "var":
                  case "class":
                  case "function":
                    declaration = this.parseStatementListItem();
                    break;
                  default:
                    this.throwUnexpectedToken(this.lookahead);
                }
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
              } else if (this.matchAsyncFunction()) {
                var declaration = this.parseFunctionDeclaration();
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
              } else {
                var specifiers = [];
                var source = null;
                var isExportFromIdentifier = false;
                this.expect("{");
                while (!this.match("}")) {
                  isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                  specifiers.push(this.parseExportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                if (this.matchContextualKeyword("from")) {
                  this.nextToken();
                  source = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                } else if (isExportFromIdentifier) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                } else {
                  this.consumeSemicolon();
                }
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
              }
              return exportDeclaration;
            };
            return Parser2;
          }();
          exports2.Parser = Parser;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function assert(condition, message) {
            if (!condition) {
              throw new Error("ASSERT: " + message);
            }
          }
          exports2.assert = assert;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var ErrorHandler = function() {
            function ErrorHandler2() {
              this.errors = [];
              this.tolerant = false;
            }
            ErrorHandler2.prototype.recordError = function(error) {
              this.errors.push(error);
            };
            ErrorHandler2.prototype.tolerate = function(error) {
              if (this.tolerant) {
                this.recordError(error);
              } else {
                throw error;
              }
            };
            ErrorHandler2.prototype.constructError = function(msg, column) {
              var error = new Error(msg);
              try {
                throw error;
              } catch (base) {
                if (Object.create && Object.defineProperty) {
                  error = Object.create(base);
                  Object.defineProperty(error, "column", { value: column });
                }
              }
              return error;
            };
            ErrorHandler2.prototype.createError = function(index, line, col, description) {
              var msg = "Line " + line + ": " + description;
              var error = this.constructError(msg, col);
              error.index = index;
              error.lineNumber = line;
              error.description = description;
              return error;
            };
            ErrorHandler2.prototype.throwError = function(index, line, col, description) {
              throw this.createError(index, line, col, description);
            };
            ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
              var error = this.createError(index, line, col, description);
              if (this.tolerant) {
                this.recordError(error);
              } else {
                throw error;
              }
            };
            return ErrorHandler2;
          }();
          exports2.ErrorHandler = ErrorHandler;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Messages = {
            BadGetterArity: "Getter must not have any formal parameters",
            BadSetterArity: "Setter must have exactly one formal parameter",
            BadSetterRestParameter: "Setter function argument must not be a rest parameter",
            ConstructorIsAsync: "Class constructor may not be an async method",
            ConstructorSpecialMethod: "Class constructor may not be an accessor",
            DeclarationMissingInitializer: "Missing initializer in %0 declaration",
            DefaultRestParameter: "Unexpected token =",
            DuplicateBinding: "Duplicate binding %0",
            DuplicateConstructor: "A class may only have one constructor",
            DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
            ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
            GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
            IllegalBreak: "Illegal break statement",
            IllegalContinue: "Illegal continue statement",
            IllegalExportDeclaration: "Unexpected token",
            IllegalImportDeclaration: "Unexpected token",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "Illegal return statement",
            InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
            InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
            InvalidModuleSpecifier: "Unexpected token",
            InvalidRegExp: "Invalid regular expression",
            LetInLexicalBinding: "let is disallowed as a lexically bound name",
            MissingFromClause: "Unexpected token",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NewlineAfterThrow: "Illegal newline after throw",
            NoAsAfterImportNamespace: "Unexpected token",
            NoCatchOrFinally: "Missing catch or finally after try",
            ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
            Redeclaration: "%0 '%1' has already been declared",
            StaticPrototype: "Classes may not have static property named prototype",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
            UnexpectedEOS: "Unexpected end of input",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedNumber: "Unexpected number",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedString: "Unexpected string",
            UnexpectedTemplate: "Unexpected quasi %0",
            UnexpectedToken: "Unexpected token %0",
            UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
            UnknownLabel: "Undefined label '%0'",
            UnterminatedRegExp: "Invalid regular expression: missing /"
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var assert_1 = __webpack_require__(9);
          var character_1 = __webpack_require__(4);
          var messages_1 = __webpack_require__(11);
          function hexValue(ch) {
            return "0123456789abcdef".indexOf(ch.toLowerCase());
          }
          function octalValue(ch) {
            return "01234567".indexOf(ch);
          }
          var Scanner = function() {
            function Scanner2(code, handler) {
              this.source = code;
              this.errorHandler = handler;
              this.trackComment = false;
              this.isModule = false;
              this.length = code.length;
              this.index = 0;
              this.lineNumber = code.length > 0 ? 1 : 0;
              this.lineStart = 0;
              this.curlyStack = [];
            }
            Scanner2.prototype.saveState = function() {
              return {
                index: this.index,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart
              };
            };
            Scanner2.prototype.restoreState = function(state) {
              this.index = state.index;
              this.lineNumber = state.lineNumber;
              this.lineStart = state.lineStart;
            };
            Scanner2.prototype.eof = function() {
              return this.index >= this.length;
            };
            Scanner2.prototype.throwUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.tolerateUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.skipSingleLineComment = function(offset) {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - offset;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                ++this.index;
                if (character_1.Character.isLineTerminator(ch)) {
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 1
                    };
                    var entry = {
                      multiLine: false,
                      slice: [start + offset, this.index - 1],
                      range: [start, this.index - 1],
                      loc
                    };
                    comments.push(entry);
                  }
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  return comments;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: false,
                  slice: [start + offset, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              return comments;
            };
            Scanner2.prototype.skipMultiLineComment = function() {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - 2;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isLineTerminator(ch)) {
                  if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  ++this.index;
                  this.lineStart = this.index;
                } else if (ch === 42) {
                  if (this.source.charCodeAt(this.index + 1) === 47) {
                    this.index += 2;
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: true,
                        slice: [start + 2, this.index - 2],
                        range: [start, this.index],
                        loc
                      };
                      comments.push(entry);
                    }
                    return comments;
                  }
                  ++this.index;
                } else {
                  ++this.index;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: true,
                  slice: [start + 2, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              this.tolerateUnexpectedToken();
              return comments;
            };
            Scanner2.prototype.scanComments = function() {
              var comments;
              if (this.trackComment) {
                comments = [];
              }
              var start = this.index === 0;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isWhiteSpace(ch)) {
                  ++this.index;
                } else if (character_1.Character.isLineTerminator(ch)) {
                  ++this.index;
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  start = true;
                } else if (ch === 47) {
                  ch = this.source.charCodeAt(this.index + 1);
                  if (ch === 47) {
                    this.index += 2;
                    var comment = this.skipSingleLineComment(2);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                    start = true;
                  } else if (ch === 42) {
                    this.index += 2;
                    var comment = this.skipMultiLineComment();
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (start && ch === 45) {
                  if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                    this.index += 3;
                    var comment = this.skipSingleLineComment(3);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (ch === 60 && !this.isModule) {
                  if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                    this.index += 4;
                    var comment = this.skipSingleLineComment(4);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
              return comments;
            };
            Scanner2.prototype.isFutureReservedWord = function(id) {
              switch (id) {
                case "enum":
                case "export":
                case "import":
                case "super":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isStrictModeReservedWord = function(id) {
              switch (id) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "yield":
                case "let":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isRestrictedWord = function(id) {
              return id === "eval" || id === "arguments";
            };
            Scanner2.prototype.isKeyword = function(id) {
              switch (id.length) {
                case 2:
                  return id === "if" || id === "in" || id === "do";
                case 3:
                  return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                case 4:
                  return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                case 5:
                  return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                case 6:
                  return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                case 7:
                  return id === "default" || id === "finally" || id === "extends";
                case 8:
                  return id === "function" || id === "continue" || id === "debugger";
                case 10:
                  return id === "instanceof";
                default:
                  return false;
              }
            };
            Scanner2.prototype.codePointAt = function(i2) {
              var cp = this.source.charCodeAt(i2);
              if (cp >= 55296 && cp <= 56319) {
                var second = this.source.charCodeAt(i2 + 1);
                if (second >= 56320 && second <= 57343) {
                  var first = cp;
                  cp = (first - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return cp;
            };
            Scanner2.prototype.scanHexEscape = function(prefix) {
              var len = prefix === "u" ? 4 : 2;
              var code = 0;
              for (var i2 = 0; i2 < len; ++i2) {
                if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  code = code * 16 + hexValue(this.source[this.index++]);
                } else {
                  return null;
                }
              }
              return String.fromCharCode(code);
            };
            Scanner2.prototype.scanUnicodeCodePointEscape = function() {
              var ch = this.source[this.index];
              var code = 0;
              if (ch === "}") {
                this.throwUnexpectedToken();
              }
              while (!this.eof()) {
                ch = this.source[this.index++];
                if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                  break;
                }
                code = code * 16 + hexValue(ch);
              }
              if (code > 1114111 || ch !== "}") {
                this.throwUnexpectedToken();
              }
              return character_1.Character.fromCodePoint(code);
            };
            Scanner2.prototype.getIdentifier = function() {
              var start = this.index++;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (ch === 92) {
                  this.index = start;
                  return this.getComplexIdentifier();
                } else if (ch >= 55296 && ch < 57343) {
                  this.index = start;
                  return this.getComplexIdentifier();
                }
                if (character_1.Character.isIdentifierPart(ch)) {
                  ++this.index;
                } else {
                  break;
                }
              }
              return this.source.slice(start, this.index);
            };
            Scanner2.prototype.getComplexIdentifier = function() {
              var cp = this.codePointAt(this.index);
              var id = character_1.Character.fromCodePoint(cp);
              this.index += id.length;
              var ch;
              if (cp === 92) {
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id = ch;
              }
              while (!this.eof()) {
                cp = this.codePointAt(this.index);
                if (!character_1.Character.isIdentifierPart(cp)) {
                  break;
                }
                ch = character_1.Character.fromCodePoint(cp);
                id += ch;
                this.index += ch.length;
                if (cp === 92) {
                  id = id.substr(0, id.length - 1);
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id += ch;
                }
              }
              return id;
            };
            Scanner2.prototype.octalToDecimal = function(ch) {
              var octal = ch !== "0";
              var code = octalValue(ch);
              if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                octal = true;
                code = code * 8 + octalValue(this.source[this.index++]);
                if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  code = code * 8 + octalValue(this.source[this.index++]);
                }
              }
              return {
                code,
                octal
              };
            };
            Scanner2.prototype.scanIdentifier = function() {
              var type;
              var start = this.index;
              var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
              if (id.length === 1) {
                type = 3;
              } else if (this.isKeyword(id)) {
                type = 4;
              } else if (id === "null") {
                type = 5;
              } else if (id === "true" || id === "false") {
                type = 1;
              } else {
                type = 3;
              }
              if (type !== 3 && start + id.length !== this.index) {
                var restore = this.index;
                this.index = start;
                this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                this.index = restore;
              }
              return {
                type,
                value: id,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanPunctuator = function() {
              var start = this.index;
              var str = this.source[this.index];
              switch (str) {
                case "(":
                case "{":
                  if (str === "{") {
                    this.curlyStack.push("{");
                  }
                  ++this.index;
                  break;
                case ".":
                  ++this.index;
                  if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                    this.index += 2;
                    str = "...";
                  }
                  break;
                case "}":
                  ++this.index;
                  this.curlyStack.pop();
                  break;
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "?":
                case "~":
                  ++this.index;
                  break;
                default:
                  str = this.source.substr(this.index, 4);
                  if (str === ">>>=") {
                    this.index += 4;
                  } else {
                    str = str.substr(0, 3);
                    if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                      this.index += 3;
                    } else {
                      str = str.substr(0, 2);
                      if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                        this.index += 2;
                      } else {
                        str = this.source[this.index];
                        if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                          ++this.index;
                        }
                      }
                    }
                  }
              }
              if (this.index === start) {
                this.throwUnexpectedToken();
              }
              return {
                type: 7,
                value: str,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanHexLiteral = function(start) {
              var num = "";
              while (!this.eof()) {
                if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt("0x" + num, 16),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanBinaryLiteral = function(start) {
              var num = "";
              var ch;
              while (!this.eof()) {
                ch = this.source[this.index];
                if (ch !== "0" && ch !== "1") {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (!this.eof()) {
                ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                  this.throwUnexpectedToken();
                }
              }
              return {
                type: 6,
                value: parseInt(num, 2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
              var num = "";
              var octal = false;
              if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                octal = true;
                num = "0" + this.source[this.index++];
              } else {
                ++this.index;
              }
              while (!this.eof()) {
                if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (!octal && num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt(num, 8),
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.isImplicitOctalLiteral = function() {
              for (var i2 = this.index + 1; i2 < this.length; ++i2) {
                var ch = this.source[i2];
                if (ch === "8" || ch === "9") {
                  return false;
                }
                if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  return true;
                }
              }
              return true;
            };
            Scanner2.prototype.scanNumericLiteral = function() {
              var start = this.index;
              var ch = this.source[start];
              assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
              var num = "";
              if (ch !== ".") {
                num = this.source[this.index++];
                ch = this.source[this.index];
                if (num === "0") {
                  if (ch === "x" || ch === "X") {
                    ++this.index;
                    return this.scanHexLiteral(start);
                  }
                  if (ch === "b" || ch === "B") {
                    ++this.index;
                    return this.scanBinaryLiteral(start);
                  }
                  if (ch === "o" || ch === "O") {
                    return this.scanOctalLiteral(ch, start);
                  }
                  if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    if (this.isImplicitOctalLiteral()) {
                      return this.scanOctalLiteral(ch, start);
                    }
                  }
                }
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === ".") {
                num += this.source[this.index++];
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === "e" || ch === "E") {
                num += this.source[this.index++];
                ch = this.source[this.index];
                if (ch === "+" || ch === "-") {
                  num += this.source[this.index++];
                }
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                } else {
                  this.throwUnexpectedToken();
                }
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseFloat(num),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanStringLiteral = function() {
              var start = this.index;
              var quote = this.source[start];
              assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
              ++this.index;
              var octal = false;
              var str = "";
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === quote) {
                  quote = "";
                  break;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          str += this.scanUnicodeCodePointEscape();
                        } else {
                          var unescaped_1 = this.scanHexEscape(ch);
                          if (unescaped_1 === null) {
                            this.throwUnexpectedToken();
                          }
                          str += unescaped_1;
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        str += unescaped;
                        break;
                      case "n":
                        str += "\n";
                        break;
                      case "r":
                        str += "\r";
                        break;
                      case "t":
                        str += "	";
                        break;
                      case "b":
                        str += "\b";
                        break;
                      case "f":
                        str += "\f";
                        break;
                      case "v":
                        str += "\v";
                        break;
                      case "8":
                      case "9":
                        str += ch;
                        this.tolerateUnexpectedToken();
                        break;
                      default:
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          var octToDec = this.octalToDecimal(ch);
                          octal = octToDec.octal || octal;
                          str += String.fromCharCode(octToDec.code);
                        } else {
                          str += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  break;
                } else {
                  str += ch;
                }
              }
              if (quote !== "") {
                this.index = start;
                this.throwUnexpectedToken();
              }
              return {
                type: 8,
                value: str,
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanTemplate = function() {
              var cooked = "";
              var terminated = false;
              var start = this.index;
              var head = this.source[start] === "`";
              var tail = false;
              var rawOffset = 2;
              ++this.index;
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === "`") {
                  rawOffset = 1;
                  tail = true;
                  terminated = true;
                  break;
                } else if (ch === "$") {
                  if (this.source[this.index] === "{") {
                    this.curlyStack.push("${");
                    ++this.index;
                    terminated = true;
                    break;
                  }
                  cooked += ch;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "n":
                        cooked += "\n";
                        break;
                      case "r":
                        cooked += "\r";
                        break;
                      case "t":
                        cooked += "	";
                        break;
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          cooked += this.scanUnicodeCodePointEscape();
                        } else {
                          var restore = this.index;
                          var unescaped_2 = this.scanHexEscape(ch);
                          if (unescaped_2 !== null) {
                            cooked += unescaped_2;
                          } else {
                            this.index = restore;
                            cooked += ch;
                          }
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        cooked += unescaped;
                        break;
                      case "b":
                        cooked += "\b";
                        break;
                      case "f":
                        cooked += "\f";
                        break;
                      case "v":
                        cooked += "\v";
                        break;
                      default:
                        if (ch === "0") {
                          if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          }
                          cooked += "\0";
                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        } else {
                          cooked += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                  cooked += "\n";
                } else {
                  cooked += ch;
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken();
              }
              if (!head) {
                this.curlyStack.pop();
              }
              return {
                type: 10,
                value: this.source.slice(start + 1, this.index - rawOffset),
                cooked,
                head,
                tail,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.testRegExp = function(pattern, flags) {
              var astralSubstitute = "\uFFFF";
              var tmp = pattern;
              var self2 = this;
              if (flags.indexOf("u") >= 0) {
                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $22) {
                  var codePoint = parseInt($1 || $22, 16);
                  if (codePoint > 1114111) {
                    self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                  }
                  if (codePoint <= 65535) {
                    return String.fromCharCode(codePoint);
                  }
                  return astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
              }
              try {
                RegExp(tmp);
              } catch (e3) {
                this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
              }
              try {
                return new RegExp(pattern, flags);
              } catch (exception) {
                return null;
              }
            };
            Scanner2.prototype.scanRegExpBody = function() {
              var ch = this.source[this.index];
              assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
              var str = this.source[this.index++];
              var classMarker = false;
              var terminated = false;
              while (!this.eof()) {
                ch = this.source[this.index++];
                str += ch;
                if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  }
                  str += ch;
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                } else if (classMarker) {
                  if (ch === "]") {
                    classMarker = false;
                  }
                } else {
                  if (ch === "/") {
                    terminated = true;
                    break;
                  } else if (ch === "[") {
                    classMarker = true;
                  }
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              }
              return str.substr(1, str.length - 2);
            };
            Scanner2.prototype.scanRegExpFlags = function() {
              var str = "";
              var flags = "";
              while (!this.eof()) {
                var ch = this.source[this.index];
                if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                  break;
                }
                ++this.index;
                if (ch === "\\" && !this.eof()) {
                  ch = this.source[this.index];
                  if (ch === "u") {
                    ++this.index;
                    var restore = this.index;
                    var char = this.scanHexEscape("u");
                    if (char !== null) {
                      flags += char;
                      for (str += "\\u"; restore < this.index; ++restore) {
                        str += this.source[restore];
                      }
                    } else {
                      this.index = restore;
                      flags += "u";
                      str += "\\u";
                    }
                    this.tolerateUnexpectedToken();
                  } else {
                    str += "\\";
                    this.tolerateUnexpectedToken();
                  }
                } else {
                  flags += ch;
                  str += ch;
                }
              }
              return flags;
            };
            Scanner2.prototype.scanRegExp = function() {
              var start = this.index;
              var pattern = this.scanRegExpBody();
              var flags = this.scanRegExpFlags();
              var value = this.testRegExp(pattern, flags);
              return {
                type: 9,
                value: "",
                pattern,
                flags,
                regex: value,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.lex = function() {
              if (this.eof()) {
                return {
                  type: 2,
                  value: "",
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: this.index,
                  end: this.index
                };
              }
              var cp = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(cp)) {
                return this.scanIdentifier();
              }
              if (cp === 40 || cp === 41 || cp === 59) {
                return this.scanPunctuator();
              }
              if (cp === 39 || cp === 34) {
                return this.scanStringLiteral();
              }
              if (cp === 46) {
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                  return this.scanNumericLiteral();
                }
                return this.scanPunctuator();
              }
              if (character_1.Character.isDecimalDigit(cp)) {
                return this.scanNumericLiteral();
              }
              if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                return this.scanTemplate();
              }
              if (cp >= 55296 && cp < 57343) {
                if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                  return this.scanIdentifier();
                }
              }
              return this.scanPunctuator();
            };
            return Scanner2;
          }();
          exports2.Scanner = Scanner;
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TokenName = {};
          exports2.TokenName[1] = "Boolean";
          exports2.TokenName[2] = "<end>";
          exports2.TokenName[3] = "Identifier";
          exports2.TokenName[4] = "Keyword";
          exports2.TokenName[5] = "Null";
          exports2.TokenName[6] = "Numeric";
          exports2.TokenName[7] = "Punctuator";
          exports2.TokenName[8] = "String";
          exports2.TokenName[9] = "RegularExpression";
          exports2.TokenName[10] = "Template";
        },
        function(module3, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.XHTMLEntities = {
            quot: '"',
            amp: "&",
            apos: "'",
            gt: ">",
            nbsp: "\xA0",
            iexcl: "\xA1",
            cent: "\xA2",
            pound: "\xA3",
            curren: "\xA4",
            yen: "\xA5",
            brvbar: "\xA6",
            sect: "\xA7",
            uml: "\xA8",
            copy: "\xA9",
            ordf: "\xAA",
            laquo: "\xAB",
            not: "\xAC",
            shy: "\xAD",
            reg: "\xAE",
            macr: "\xAF",
            deg: "\xB0",
            plusmn: "\xB1",
            sup2: "\xB2",
            sup3: "\xB3",
            acute: "\xB4",
            micro: "\xB5",
            para: "\xB6",
            middot: "\xB7",
            cedil: "\xB8",
            sup1: "\xB9",
            ordm: "\xBA",
            raquo: "\xBB",
            frac14: "\xBC",
            frac12: "\xBD",
            frac34: "\xBE",
            iquest: "\xBF",
            Agrave: "\xC0",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Atilde: "\xC3",
            Auml: "\xC4",
            Aring: "\xC5",
            AElig: "\xC6",
            Ccedil: "\xC7",
            Egrave: "\xC8",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Euml: "\xCB",
            Igrave: "\xCC",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Iuml: "\xCF",
            ETH: "\xD0",
            Ntilde: "\xD1",
            Ograve: "\xD2",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Otilde: "\xD5",
            Ouml: "\xD6",
            times: "\xD7",
            Oslash: "\xD8",
            Ugrave: "\xD9",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Uuml: "\xDC",
            Yacute: "\xDD",
            THORN: "\xDE",
            szlig: "\xDF",
            agrave: "\xE0",
            aacute: "\xE1",
            acirc: "\xE2",
            atilde: "\xE3",
            auml: "\xE4",
            aring: "\xE5",
            aelig: "\xE6",
            ccedil: "\xE7",
            egrave: "\xE8",
            eacute: "\xE9",
            ecirc: "\xEA",
            euml: "\xEB",
            igrave: "\xEC",
            iacute: "\xED",
            icirc: "\xEE",
            iuml: "\xEF",
            eth: "\xF0",
            ntilde: "\xF1",
            ograve: "\xF2",
            oacute: "\xF3",
            ocirc: "\xF4",
            otilde: "\xF5",
            ouml: "\xF6",
            divide: "\xF7",
            oslash: "\xF8",
            ugrave: "\xF9",
            uacute: "\xFA",
            ucirc: "\xFB",
            uuml: "\xFC",
            yacute: "\xFD",
            thorn: "\xFE",
            yuml: "\xFF",
            OElig: "\u0152",
            oelig: "\u0153",
            Scaron: "\u0160",
            scaron: "\u0161",
            Yuml: "\u0178",
            fnof: "\u0192",
            circ: "\u02C6",
            tilde: "\u02DC",
            Alpha: "\u0391",
            Beta: "\u0392",
            Gamma: "\u0393",
            Delta: "\u0394",
            Epsilon: "\u0395",
            Zeta: "\u0396",
            Eta: "\u0397",
            Theta: "\u0398",
            Iota: "\u0399",
            Kappa: "\u039A",
            Lambda: "\u039B",
            Mu: "\u039C",
            Nu: "\u039D",
            Xi: "\u039E",
            Omicron: "\u039F",
            Pi: "\u03A0",
            Rho: "\u03A1",
            Sigma: "\u03A3",
            Tau: "\u03A4",
            Upsilon: "\u03A5",
            Phi: "\u03A6",
            Chi: "\u03A7",
            Psi: "\u03A8",
            Omega: "\u03A9",
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            iota: "\u03B9",
            kappa: "\u03BA",
            lambda: "\u03BB",
            mu: "\u03BC",
            nu: "\u03BD",
            xi: "\u03BE",
            omicron: "\u03BF",
            pi: "\u03C0",
            rho: "\u03C1",
            sigmaf: "\u03C2",
            sigma: "\u03C3",
            tau: "\u03C4",
            upsilon: "\u03C5",
            phi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            thetasym: "\u03D1",
            upsih: "\u03D2",
            piv: "\u03D6",
            ensp: "\u2002",
            emsp: "\u2003",
            thinsp: "\u2009",
            zwnj: "\u200C",
            zwj: "\u200D",
            lrm: "\u200E",
            rlm: "\u200F",
            ndash: "\u2013",
            mdash: "\u2014",
            lsquo: "\u2018",
            rsquo: "\u2019",
            sbquo: "\u201A",
            ldquo: "\u201C",
            rdquo: "\u201D",
            bdquo: "\u201E",
            dagger: "\u2020",
            Dagger: "\u2021",
            bull: "\u2022",
            hellip: "\u2026",
            permil: "\u2030",
            prime: "\u2032",
            Prime: "\u2033",
            lsaquo: "\u2039",
            rsaquo: "\u203A",
            oline: "\u203E",
            frasl: "\u2044",
            euro: "\u20AC",
            image: "\u2111",
            weierp: "\u2118",
            real: "\u211C",
            trade: "\u2122",
            alefsym: "\u2135",
            larr: "\u2190",
            uarr: "\u2191",
            rarr: "\u2192",
            darr: "\u2193",
            harr: "\u2194",
            crarr: "\u21B5",
            lArr: "\u21D0",
            uArr: "\u21D1",
            rArr: "\u21D2",
            dArr: "\u21D3",
            hArr: "\u21D4",
            forall: "\u2200",
            part: "\u2202",
            exist: "\u2203",
            empty: "\u2205",
            nabla: "\u2207",
            isin: "\u2208",
            notin: "\u2209",
            ni: "\u220B",
            prod: "\u220F",
            sum: "\u2211",
            minus: "\u2212",
            lowast: "\u2217",
            radic: "\u221A",
            prop: "\u221D",
            infin: "\u221E",
            ang: "\u2220",
            and: "\u2227",
            or: "\u2228",
            cap: "\u2229",
            cup: "\u222A",
            int: "\u222B",
            there4: "\u2234",
            sim: "\u223C",
            cong: "\u2245",
            asymp: "\u2248",
            ne: "\u2260",
            equiv: "\u2261",
            le: "\u2264",
            ge: "\u2265",
            sub: "\u2282",
            sup: "\u2283",
            nsub: "\u2284",
            sube: "\u2286",
            supe: "\u2287",
            oplus: "\u2295",
            otimes: "\u2297",
            perp: "\u22A5",
            sdot: "\u22C5",
            lceil: "\u2308",
            rceil: "\u2309",
            lfloor: "\u230A",
            rfloor: "\u230B",
            loz: "\u25CA",
            spades: "\u2660",
            clubs: "\u2663",
            hearts: "\u2665",
            diams: "\u2666",
            lang: "\u27E8",
            rang: "\u27E9"
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var error_handler_1 = __webpack_require__(10);
          var scanner_1 = __webpack_require__(12);
          var token_1 = __webpack_require__(13);
          var Reader = function() {
            function Reader2() {
              this.values = [];
              this.curly = this.paren = -1;
            }
            Reader2.prototype.beforeFunctionExpression = function(t3) {
              return [
                "(",
                "{",
                "[",
                "in",
                "typeof",
                "instanceof",
                "new",
                "return",
                "case",
                "delete",
                "throw",
                "void",
                "=",
                "+=",
                "-=",
                "*=",
                "**=",
                "/=",
                "%=",
                "<<=",
                ">>=",
                ">>>=",
                "&=",
                "|=",
                "^=",
                ",",
                "+",
                "-",
                "*",
                "**",
                "/",
                "%",
                "++",
                "--",
                "<<",
                ">>",
                ">>>",
                "&",
                "|",
                "^",
                "!",
                "~",
                "&&",
                "||",
                "?",
                ":",
                "===",
                "==",
                ">=",
                "<=",
                "<",
                ">",
                "!=",
                "!=="
              ].indexOf(t3) >= 0;
            };
            Reader2.prototype.isRegexStart = function() {
              var previous = this.values[this.values.length - 1];
              var regex = previous !== null;
              switch (previous) {
                case "this":
                case "]":
                  regex = false;
                  break;
                case ")":
                  var keyword = this.values[this.paren - 1];
                  regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                  break;
                case "}":
                  regex = false;
                  if (this.values[this.curly - 3] === "function") {
                    var check = this.values[this.curly - 4];
                    regex = check ? !this.beforeFunctionExpression(check) : false;
                  } else if (this.values[this.curly - 4] === "function") {
                    var check = this.values[this.curly - 5];
                    regex = check ? !this.beforeFunctionExpression(check) : true;
                  }
                  break;
                default:
                  break;
              }
              return regex;
            };
            Reader2.prototype.push = function(token) {
              if (token.type === 7 || token.type === 4) {
                if (token.value === "{") {
                  this.curly = this.values.length;
                } else if (token.value === "(") {
                  this.paren = this.values.length;
                }
                this.values.push(token.value);
              } else {
                this.values.push(null);
              }
            };
            return Reader2;
          }();
          var Tokenizer = function() {
            function Tokenizer2(code, config) {
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
              this.scanner = new scanner_1.Scanner(code, this.errorHandler);
              this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
              this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
              this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
              this.buffer = [];
              this.reader = new Reader();
            }
            Tokenizer2.prototype.errors = function() {
              return this.errorHandler.errors;
            };
            Tokenizer2.prototype.getNextToken = function() {
              if (this.buffer.length === 0) {
                var comments = this.scanner.scanComments();
                if (this.scanner.trackComment) {
                  for (var i2 = 0; i2 < comments.length; ++i2) {
                    var e3 = comments[i2];
                    var value = this.scanner.source.slice(e3.slice[0], e3.slice[1]);
                    var comment = {
                      type: e3.multiLine ? "BlockComment" : "LineComment",
                      value
                    };
                    if (this.trackRange) {
                      comment.range = e3.range;
                    }
                    if (this.trackLoc) {
                      comment.loc = e3.loc;
                    }
                    this.buffer.push(comment);
                  }
                }
                if (!this.scanner.eof()) {
                  var loc = void 0;
                  if (this.trackLoc) {
                    loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    };
                  }
                  var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                  var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                  this.reader.push(token);
                  var entry = {
                    type: token_1.TokenName[token.type],
                    value: this.scanner.source.slice(token.start, token.end)
                  };
                  if (this.trackRange) {
                    entry.range = [token.start, token.end];
                  }
                  if (this.trackLoc) {
                    loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                    entry.loc = loc;
                  }
                  if (token.type === 9) {
                    var pattern = token.pattern;
                    var flags = token.flags;
                    entry.regex = { pattern, flags };
                  }
                  this.buffer.push(entry);
                }
              }
              return this.buffer.shift();
            };
            return Tokenizer2;
          }();
          exports2.Tokenizer = Tokenizer;
        }
      ]);
    });
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/parsers/esprima.js
var require_esprima3 = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/parsers/esprima.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var util_1 = require_util2();
    function parse12(source, options) {
      var comments = [];
      var ast = require_esprima2().parse(source, {
        loc: true,
        locations: true,
        comment: true,
        onComment: comments,
        range: (0, util_1.getOption)(options, "range", false),
        tolerant: (0, util_1.getOption)(options, "tolerant", true),
        tokens: true,
        jsx: (0, util_1.getOption)(options, "jsx", false),
        sourceType: (0, util_1.getOption)(options, "sourceType", "module")
      });
      if (!Array.isArray(ast.comments)) {
        ast.comments = comments;
      }
      return ast;
    }
    exports.parse = parse12;
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/options.js
var require_options = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = void 0;
    var util_1 = require_util2();
    var defaults = {
      parser: require_esprima3(),
      tabWidth: 4,
      useTabs: false,
      reuseWhitespace: true,
      lineTerminator: (0, util_1.getLineTerminator)(),
      wrapColumn: 74,
      sourceFileName: null,
      sourceMapName: null,
      sourceRoot: null,
      inputSourceMap: null,
      range: false,
      tolerant: true,
      quote: null,
      trailingComma: false,
      arrayBracketSpacing: false,
      objectCurlySpacing: true,
      arrowParensAlways: false,
      flowObjectCommas: true,
      tokens: true
    };
    var hasOwn = defaults.hasOwnProperty;
    function normalize(opts) {
      var options = opts || defaults;
      function get(key) {
        return hasOwn.call(options, key) ? options[key] : defaults[key];
      }
      return {
        tabWidth: +get("tabWidth"),
        useTabs: !!get("useTabs"),
        reuseWhitespace: !!get("reuseWhitespace"),
        lineTerminator: get("lineTerminator"),
        wrapColumn: Math.max(get("wrapColumn"), 0),
        sourceFileName: get("sourceFileName"),
        sourceMapName: get("sourceMapName"),
        sourceRoot: get("sourceRoot"),
        inputSourceMap: get("inputSourceMap"),
        parser: get("esprima") || get("parser"),
        range: get("range"),
        tolerant: get("tolerant"),
        quote: get("quote"),
        trailingComma: get("trailingComma"),
        arrayBracketSpacing: get("arrayBracketSpacing"),
        objectCurlySpacing: get("objectCurlySpacing"),
        arrowParensAlways: get("arrowParensAlways"),
        flowObjectCommas: get("flowObjectCommas"),
        tokens: !!get("tokens")
      };
    }
    exports.normalize = normalize;
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/mapping.js
var require_mapping = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/mapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var util_1 = require_util2();
    var Mapping = function() {
      function Mapping2(sourceLines, sourceLoc, targetLoc) {
        if (targetLoc === void 0) {
          targetLoc = sourceLoc;
        }
        this.sourceLines = sourceLines;
        this.sourceLoc = sourceLoc;
        this.targetLoc = targetLoc;
      }
      Mapping2.prototype.slice = function(lines, start, end) {
        if (end === void 0) {
          end = lines.lastPos();
        }
        var sourceLines = this.sourceLines;
        var sourceLoc = this.sourceLoc;
        var targetLoc = this.targetLoc;
        function skip(name) {
          var sourceFromPos = sourceLoc[name];
          var targetFromPos = targetLoc[name];
          var targetToPos = start;
          if (name === "end") {
            targetToPos = end;
          } else {
            assert_1.default.strictEqual(name, "start");
          }
          return skipChars(sourceLines, sourceFromPos, lines, targetFromPos, targetToPos);
        }
        if ((0, util_1.comparePos)(start, targetLoc.start) <= 0) {
          if ((0, util_1.comparePos)(targetLoc.end, end) <= 0) {
            targetLoc = {
              start: subtractPos(targetLoc.start, start.line, start.column),
              end: subtractPos(targetLoc.end, start.line, start.column)
            };
          } else if ((0, util_1.comparePos)(end, targetLoc.start) <= 0) {
            return null;
          } else {
            sourceLoc = {
              start: sourceLoc.start,
              end: skip("end")
            };
            targetLoc = {
              start: subtractPos(targetLoc.start, start.line, start.column),
              end: subtractPos(end, start.line, start.column)
            };
          }
        } else {
          if ((0, util_1.comparePos)(targetLoc.end, start) <= 0) {
            return null;
          }
          if ((0, util_1.comparePos)(targetLoc.end, end) <= 0) {
            sourceLoc = {
              start: skip("start"),
              end: sourceLoc.end
            };
            targetLoc = {
              start: { line: 1, column: 0 },
              end: subtractPos(targetLoc.end, start.line, start.column)
            };
          } else {
            sourceLoc = {
              start: skip("start"),
              end: skip("end")
            };
            targetLoc = {
              start: { line: 1, column: 0 },
              end: subtractPos(end, start.line, start.column)
            };
          }
        }
        return new Mapping2(this.sourceLines, sourceLoc, targetLoc);
      };
      Mapping2.prototype.add = function(line, column) {
        return new Mapping2(this.sourceLines, this.sourceLoc, {
          start: addPos(this.targetLoc.start, line, column),
          end: addPos(this.targetLoc.end, line, column)
        });
      };
      Mapping2.prototype.subtract = function(line, column) {
        return new Mapping2(this.sourceLines, this.sourceLoc, {
          start: subtractPos(this.targetLoc.start, line, column),
          end: subtractPos(this.targetLoc.end, line, column)
        });
      };
      Mapping2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
        if (skipFirstLine === void 0) {
          skipFirstLine = false;
        }
        if (noNegativeColumns === void 0) {
          noNegativeColumns = false;
        }
        if (by === 0) {
          return this;
        }
        var targetLoc = this.targetLoc;
        var startLine = targetLoc.start.line;
        var endLine = targetLoc.end.line;
        if (skipFirstLine && startLine === 1 && endLine === 1) {
          return this;
        }
        targetLoc = {
          start: targetLoc.start,
          end: targetLoc.end
        };
        if (!skipFirstLine || startLine > 1) {
          var startColumn = targetLoc.start.column + by;
          targetLoc.start = {
            line: startLine,
            column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
          };
        }
        if (!skipFirstLine || endLine > 1) {
          var endColumn = targetLoc.end.column + by;
          targetLoc.end = {
            line: endLine,
            column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
          };
        }
        return new Mapping2(this.sourceLines, this.sourceLoc, targetLoc);
      };
      return Mapping2;
    }();
    exports.default = Mapping;
    function addPos(toPos, line, column) {
      return {
        line: toPos.line + line - 1,
        column: toPos.line === 1 ? toPos.column + column : toPos.column
      };
    }
    function subtractPos(fromPos, line, column) {
      return {
        line: fromPos.line - line + 1,
        column: fromPos.line === line ? fromPos.column - column : fromPos.column
      };
    }
    function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
      var targetComparison = (0, util_1.comparePos)(targetFromPos, targetToPos);
      if (targetComparison === 0) {
        return sourceFromPos;
      }
      var sourceCursor, targetCursor;
      if (targetComparison < 0) {
        sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
        targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
        var lineDiff = targetToPos.line - targetCursor.line;
        sourceCursor.line += lineDiff;
        targetCursor.line += lineDiff;
        if (lineDiff > 0) {
          sourceCursor.column = 0;
          targetCursor.column = 0;
        } else {
          assert_1.default.strictEqual(lineDiff, 0);
        }
        while ((0, util_1.comparePos)(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {
          assert_1.default.ok(sourceLines.nextPos(sourceCursor, true));
          assert_1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
        }
      } else {
        sourceCursor = sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
        targetCursor = targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
        var lineDiff = targetToPos.line - targetCursor.line;
        sourceCursor.line += lineDiff;
        targetCursor.line += lineDiff;
        if (lineDiff < 0) {
          sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
          targetCursor.column = targetLines.getLineLength(targetCursor.line);
        } else {
          assert_1.default.strictEqual(lineDiff, 0);
        }
        while ((0, util_1.comparePos)(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {
          assert_1.default.ok(sourceLines.prevPos(sourceCursor, true));
          assert_1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
        }
      }
      return sourceCursor;
    }
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/lines.js
var require_lines = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/lines.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var source_map_1 = tslib_1.__importDefault(require_source_map());
    var options_1 = require_options();
    var util_1 = require_util2();
    var mapping_1 = tslib_1.__importDefault(require_mapping());
    var Lines = function() {
      function Lines2(infos, sourceFileName) {
        if (sourceFileName === void 0) {
          sourceFileName = null;
        }
        this.infos = infos;
        this.mappings = [];
        this.cachedSourceMap = null;
        this.cachedTabWidth = void 0;
        assert_1.default.ok(infos.length > 0);
        this.length = infos.length;
        this.name = sourceFileName || null;
        if (this.name) {
          this.mappings.push(new mapping_1.default(this, {
            start: this.firstPos(),
            end: this.lastPos()
          }));
        }
      }
      Lines2.prototype.toString = function(options) {
        return this.sliceString(this.firstPos(), this.lastPos(), options);
      };
      Lines2.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
        if (!sourceMapName) {
          return null;
        }
        var targetLines = this;
        function updateJSON(json) {
          json = json || {};
          json.file = sourceMapName;
          if (sourceRoot) {
            json.sourceRoot = sourceRoot;
          }
          return json;
        }
        if (targetLines.cachedSourceMap) {
          return updateJSON(targetLines.cachedSourceMap.toJSON());
        }
        var smg = new source_map_1.default.SourceMapGenerator(updateJSON());
        var sourcesToContents = {};
        targetLines.mappings.forEach(function(mapping) {
          var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();
          var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();
          while ((0, util_1.comparePos)(sourceCursor, mapping.sourceLoc.end) < 0 && (0, util_1.comparePos)(targetCursor, mapping.targetLoc.end) < 0) {
            var sourceChar = mapping.sourceLines.charAt(sourceCursor);
            var targetChar = targetLines.charAt(targetCursor);
            assert_1.default.strictEqual(sourceChar, targetChar);
            var sourceName = mapping.sourceLines.name;
            smg.addMapping({
              source: sourceName,
              original: { line: sourceCursor.line, column: sourceCursor.column },
              generated: { line: targetCursor.line, column: targetCursor.column }
            });
            if (!hasOwn.call(sourcesToContents, sourceName)) {
              var sourceContent = mapping.sourceLines.toString();
              smg.setSourceContent(sourceName, sourceContent);
              sourcesToContents[sourceName] = sourceContent;
            }
            targetLines.nextPos(targetCursor, true);
            mapping.sourceLines.nextPos(sourceCursor, true);
          }
        });
        targetLines.cachedSourceMap = smg;
        return smg.toJSON();
      };
      Lines2.prototype.bootstrapCharAt = function(pos) {
        assert_1.default.strictEqual(typeof pos, "object");
        assert_1.default.strictEqual(typeof pos.line, "number");
        assert_1.default.strictEqual(typeof pos.column, "number");
        var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];
        if (typeof string === "undefined")
          return "";
        if (column === string.length && line < strings.length)
          return "\n";
        if (column >= string.length)
          return "";
        return string.charAt(column);
      };
      Lines2.prototype.charAt = function(pos) {
        assert_1.default.strictEqual(typeof pos, "object");
        assert_1.default.strictEqual(typeof pos.line, "number");
        assert_1.default.strictEqual(typeof pos.column, "number");
        var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c2 = column;
        if (typeof info === "undefined" || c2 < 0)
          return "";
        var indent3 = this.getIndentAt(line);
        if (c2 < indent3)
          return " ";
        c2 += info.sliceStart - indent3;
        if (c2 === info.sliceEnd && line < this.length)
          return "\n";
        if (c2 >= info.sliceEnd)
          return "";
        return info.line.charAt(c2);
      };
      Lines2.prototype.stripMargin = function(width, skipFirstLine) {
        if (width === 0)
          return this;
        assert_1.default.ok(width > 0, "negative margin: " + width);
        if (skipFirstLine && this.length === 1)
          return this;
        var lines = new Lines2(this.infos.map(function(info, i2) {
          if (info.line && (i2 > 0 || !skipFirstLine)) {
            info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: Math.max(0, info.indent - width) });
          }
          return info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_1 = lines.mappings;
          assert_1.default.strictEqual(newMappings_1.length, 0);
          this.mappings.forEach(function(mapping) {
            newMappings_1.push(mapping.indent(width, skipFirstLine, true));
          });
        }
        return lines;
      };
      Lines2.prototype.indent = function(by) {
        if (by === 0) {
          return this;
        }
        var lines = new Lines2(this.infos.map(function(info) {
          if (info.line && !info.locked) {
            info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });
          }
          return info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_2 = lines.mappings;
          assert_1.default.strictEqual(newMappings_2.length, 0);
          this.mappings.forEach(function(mapping) {
            newMappings_2.push(mapping.indent(by));
          });
        }
        return lines;
      };
      Lines2.prototype.indentTail = function(by) {
        if (by === 0) {
          return this;
        }
        if (this.length < 2) {
          return this;
        }
        var lines = new Lines2(this.infos.map(function(info, i2) {
          if (i2 > 0 && info.line && !info.locked) {
            info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });
          }
          return info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_3 = lines.mappings;
          assert_1.default.strictEqual(newMappings_3.length, 0);
          this.mappings.forEach(function(mapping) {
            newMappings_3.push(mapping.indent(by, true));
          });
        }
        return lines;
      };
      Lines2.prototype.lockIndentTail = function() {
        if (this.length < 2) {
          return this;
        }
        return new Lines2(this.infos.map(function(info, i2) {
          return tslib_1.__assign(tslib_1.__assign({}, info), { locked: i2 > 0 });
        }));
      };
      Lines2.prototype.getIndentAt = function(line) {
        assert_1.default.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
        return Math.max(this.infos[line - 1].indent, 0);
      };
      Lines2.prototype.guessTabWidth = function() {
        if (typeof this.cachedTabWidth === "number") {
          return this.cachedTabWidth;
        }
        var counts = [];
        var lastIndent = 0;
        for (var line = 1, last = this.length; line <= last; ++line) {
          var info = this.infos[line - 1];
          var sliced = info.line.slice(info.sliceStart, info.sliceEnd);
          if (isOnlyWhitespace(sliced)) {
            continue;
          }
          var diff = Math.abs(info.indent - lastIndent);
          counts[diff] = ~~counts[diff] + 1;
          lastIndent = info.indent;
        }
        var maxCount = -1;
        var result = 2;
        for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
          if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
            maxCount = counts[tabWidth];
            result = tabWidth;
          }
        }
        return this.cachedTabWidth = result;
      };
      Lines2.prototype.startsWithComment = function() {
        if (this.infos.length === 0) {
          return false;
        }
        var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
        return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
      };
      Lines2.prototype.isOnlyWhitespace = function() {
        return isOnlyWhitespace(this.toString());
      };
      Lines2.prototype.isPrecededOnlyByWhitespace = function(pos) {
        var info = this.infos[pos.line - 1];
        var indent3 = Math.max(info.indent, 0);
        var diff = pos.column - indent3;
        if (diff <= 0) {
          return true;
        }
        var start = info.sliceStart;
        var end = Math.min(start + diff, info.sliceEnd);
        var prefix = info.line.slice(start, end);
        return isOnlyWhitespace(prefix);
      };
      Lines2.prototype.getLineLength = function(line) {
        var info = this.infos[line - 1];
        return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
      };
      Lines2.prototype.nextPos = function(pos, skipSpaces) {
        if (skipSpaces === void 0) {
          skipSpaces = false;
        }
        var l2 = Math.max(pos.line, 0), c2 = Math.max(pos.column, 0);
        if (c2 < this.getLineLength(l2)) {
          pos.column += 1;
          return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
        }
        if (l2 < this.length) {
          pos.line += 1;
          pos.column = 0;
          return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
        }
        return false;
      };
      Lines2.prototype.prevPos = function(pos, skipSpaces) {
        if (skipSpaces === void 0) {
          skipSpaces = false;
        }
        var l2 = pos.line, c2 = pos.column;
        if (c2 < 1) {
          l2 -= 1;
          if (l2 < 1)
            return false;
          c2 = this.getLineLength(l2);
        } else {
          c2 = Math.min(c2 - 1, this.getLineLength(l2));
        }
        pos.line = l2;
        pos.column = c2;
        return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
      };
      Lines2.prototype.firstPos = function() {
        return { line: 1, column: 0 };
      };
      Lines2.prototype.lastPos = function() {
        return {
          line: this.length,
          column: this.getLineLength(this.length)
        };
      };
      Lines2.prototype.skipSpaces = function(pos, backward, modifyInPlace) {
        if (backward === void 0) {
          backward = false;
        }
        if (modifyInPlace === void 0) {
          modifyInPlace = false;
        }
        if (pos) {
          pos = modifyInPlace ? pos : {
            line: pos.line,
            column: pos.column
          };
        } else if (backward) {
          pos = this.lastPos();
        } else {
          pos = this.firstPos();
        }
        if (backward) {
          while (this.prevPos(pos)) {
            if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
              return pos;
            }
          }
          return null;
        } else {
          while (isOnlyWhitespace(this.charAt(pos))) {
            if (!this.nextPos(pos)) {
              return null;
            }
          }
          return pos;
        }
      };
      Lines2.prototype.trimLeft = function() {
        var pos = this.skipSpaces(this.firstPos(), false, true);
        return pos ? this.slice(pos) : emptyLines;
      };
      Lines2.prototype.trimRight = function() {
        var pos = this.skipSpaces(this.lastPos(), true, true);
        return pos ? this.slice(this.firstPos(), pos) : emptyLines;
      };
      Lines2.prototype.trim = function() {
        var start = this.skipSpaces(this.firstPos(), false, true);
        if (start === null) {
          return emptyLines;
        }
        var end = this.skipSpaces(this.lastPos(), true, true);
        if (end === null) {
          return emptyLines;
        }
        return this.slice(start, end);
      };
      Lines2.prototype.eachPos = function(callback, startPos, skipSpaces) {
        if (startPos === void 0) {
          startPos = this.firstPos();
        }
        if (skipSpaces === void 0) {
          skipSpaces = false;
        }
        var pos = this.firstPos();
        if (startPos) {
          pos.line = startPos.line, pos.column = startPos.column;
        }
        if (skipSpaces && !this.skipSpaces(pos, false, true)) {
          return;
        }
        do
          callback.call(this, pos);
        while (this.nextPos(pos, skipSpaces));
      };
      Lines2.prototype.bootstrapSlice = function(start, end) {
        var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);
        if (strings.length > 0) {
          strings.push(strings.pop().slice(0, end.column));
          strings[0] = strings[0].slice(start.column);
        }
        return fromString(strings.join("\n"));
      };
      Lines2.prototype.slice = function(start, end) {
        if (!end) {
          if (!start) {
            return this;
          }
          end = this.lastPos();
        }
        if (!start) {
          throw new Error("cannot slice with end but not start");
        }
        var sliced = this.infos.slice(start.line - 1, end.line);
        if (start.line === end.line) {
          sliced[0] = sliceInfo(sliced[0], start.column, end.column);
        } else {
          assert_1.default.ok(start.line < end.line);
          sliced[0] = sliceInfo(sliced[0], start.column);
          sliced.push(sliceInfo(sliced.pop(), 0, end.column));
        }
        var lines = new Lines2(sliced);
        if (this.mappings.length > 0) {
          var newMappings_4 = lines.mappings;
          assert_1.default.strictEqual(newMappings_4.length, 0);
          this.mappings.forEach(function(mapping) {
            var sliced2 = mapping.slice(this, start, end);
            if (sliced2) {
              newMappings_4.push(sliced2);
            }
          }, this);
        }
        return lines;
      };
      Lines2.prototype.bootstrapSliceString = function(start, end, options) {
        return this.slice(start, end).toString(options);
      };
      Lines2.prototype.sliceString = function(start, end, options) {
        if (start === void 0) {
          start = this.firstPos();
        }
        if (end === void 0) {
          end = this.lastPos();
        }
        var _a = (0, options_1.normalize)(options), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;
        var parts = [];
        for (var line = start.line; line <= end.line; ++line) {
          var info = this.infos[line - 1];
          if (line === start.line) {
            if (line === end.line) {
              info = sliceInfo(info, start.column, end.column);
            } else {
              info = sliceInfo(info, start.column);
            }
          } else if (line === end.line) {
            info = sliceInfo(info, 0, end.column);
          }
          var indent3 = Math.max(info.indent, 0);
          var before_1 = info.line.slice(0, info.sliceStart);
          if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent3) {
            parts.push(info.line.slice(0, info.sliceEnd));
            continue;
          }
          var tabs = 0;
          var spaces = indent3;
          if (useTabs) {
            tabs = Math.floor(indent3 / tabWidth);
            spaces -= tabs * tabWidth;
          }
          var result = "";
          if (tabs > 0) {
            result += new Array(tabs + 1).join("	");
          }
          if (spaces > 0) {
            result += new Array(spaces + 1).join(" ");
          }
          result += info.line.slice(info.sliceStart, info.sliceEnd);
          parts.push(result);
        }
        return parts.join(lineTerminator);
      };
      Lines2.prototype.isEmpty = function() {
        return this.length < 2 && this.getLineLength(1) < 1;
      };
      Lines2.prototype.join = function(elements) {
        var separator = this;
        var infos = [];
        var mappings = [];
        var prevInfo;
        function appendLines(linesOrNull) {
          if (linesOrNull === null) {
            return;
          }
          if (prevInfo) {
            var info = linesOrNull.infos[0];
            var indent3 = new Array(info.indent + 1).join(" ");
            var prevLine_1 = infos.length;
            var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
            prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent3 + info.line.slice(info.sliceStart, info.sliceEnd);
            prevInfo.locked = prevInfo.locked || info.locked;
            prevInfo.sliceEnd = prevInfo.line.length;
            if (linesOrNull.mappings.length > 0) {
              linesOrNull.mappings.forEach(function(mapping) {
                mappings.push(mapping.add(prevLine_1, prevColumn_1));
              });
            }
          } else if (linesOrNull.mappings.length > 0) {
            mappings.push.apply(mappings, linesOrNull.mappings);
          }
          linesOrNull.infos.forEach(function(info2, i2) {
            if (!prevInfo || i2 > 0) {
              prevInfo = tslib_1.__assign({}, info2);
              infos.push(prevInfo);
            }
          });
        }
        function appendWithSeparator(linesOrNull, i2) {
          if (i2 > 0)
            appendLines(separator);
          appendLines(linesOrNull);
        }
        elements.map(function(elem) {
          var lines2 = fromString(elem);
          if (lines2.isEmpty())
            return null;
          return lines2;
        }).forEach(function(linesOrNull, i2) {
          if (separator.isEmpty()) {
            appendLines(linesOrNull);
          } else {
            appendWithSeparator(linesOrNull, i2);
          }
        });
        if (infos.length < 1)
          return emptyLines;
        var lines = new Lines2(infos);
        lines.mappings = mappings;
        return lines;
      };
      Lines2.prototype.concat = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var list = [this];
        list.push.apply(list, args);
        assert_1.default.strictEqual(list.length, args.length + 1);
        return emptyLines.join(list);
      };
      return Lines2;
    }();
    exports.Lines = Lines;
    var fromStringCache = {};
    var hasOwn = fromStringCache.hasOwnProperty;
    var maxCacheKeyLen = 10;
    function countSpaces(spaces, tabWidth) {
      var count = 0;
      var len = spaces.length;
      for (var i2 = 0; i2 < len; ++i2) {
        switch (spaces.charCodeAt(i2)) {
          case 9: {
            assert_1.default.strictEqual(typeof tabWidth, "number");
            assert_1.default.ok(tabWidth > 0);
            var next = Math.ceil(count / tabWidth) * tabWidth;
            if (next === count) {
              count += tabWidth;
            } else {
              count = next;
            }
            break;
          }
          case 11:
          case 12:
          case 13:
          case 65279:
            break;
          case 32:
          default:
            count += 1;
            break;
        }
      }
      return count;
    }
    exports.countSpaces = countSpaces;
    var leadingSpaceExp = /^\s*/;
    var lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
    function fromString(string, options) {
      if (string instanceof Lines)
        return string;
      string += "";
      var tabWidth = options && options.tabWidth;
      var tabless = string.indexOf("	") < 0;
      var cacheable = !options && tabless && string.length <= maxCacheKeyLen;
      assert_1.default.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
      if (cacheable && hasOwn.call(fromStringCache, string))
        return fromStringCache[string];
      var lines = new Lines(string.split(lineTerminatorSeqExp).map(function(line) {
        var spaces = leadingSpaceExp.exec(line)[0];
        return {
          line,
          indent: countSpaces(spaces, tabWidth),
          locked: false,
          sliceStart: spaces.length,
          sliceEnd: line.length
        };
      }), (0, options_1.normalize)(options).sourceFileName);
      if (cacheable)
        fromStringCache[string] = lines;
      return lines;
    }
    exports.fromString = fromString;
    function isOnlyWhitespace(string) {
      return !/\S/.test(string);
    }
    function sliceInfo(info, startCol, endCol) {
      var sliceStart = info.sliceStart;
      var sliceEnd = info.sliceEnd;
      var indent3 = Math.max(info.indent, 0);
      var lineLength = indent3 + sliceEnd - sliceStart;
      if (typeof endCol === "undefined") {
        endCol = lineLength;
      }
      startCol = Math.max(startCol, 0);
      endCol = Math.min(endCol, lineLength);
      endCol = Math.max(endCol, startCol);
      if (endCol < indent3) {
        indent3 = endCol;
        sliceEnd = sliceStart;
      } else {
        sliceEnd -= lineLength - endCol;
      }
      lineLength = endCol;
      lineLength -= startCol;
      if (startCol < indent3) {
        indent3 -= startCol;
      } else {
        startCol -= indent3;
        indent3 = 0;
        sliceStart += startCol;
      }
      assert_1.default.ok(indent3 >= 0);
      assert_1.default.ok(sliceStart <= sliceEnd);
      assert_1.default.strictEqual(lineLength, indent3 + sliceEnd - sliceStart);
      if (info.indent === indent3 && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {
        return info;
      }
      return {
        line: info.line,
        indent: indent3,
        locked: false,
        sliceStart,
        sliceEnd
      };
    }
    function concat(elements) {
      return emptyLines.join(elements);
    }
    exports.concat = concat;
    var emptyLines = fromString("");
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/comments.js
var require_comments = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/comments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printComments = exports.attach = void 0;
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var types17 = tslib_1.__importStar(require_main());
    var n = types17.namedTypes;
    var isArray = types17.builtInTypes.array;
    var isObject2 = types17.builtInTypes.object;
    var lines_1 = require_lines();
    var util_1 = require_util2();
    var childNodesCache = /* @__PURE__ */ new WeakMap();
    function getSortedChildNodes(node, lines, resultArray) {
      if (!node) {
        return resultArray;
      }
      (0, util_1.fixFaultyLocations)(node, lines);
      if (resultArray) {
        if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
          var i2 = resultArray.length - 1;
          for (; i2 >= 0; --i2) {
            var child = resultArray[i2];
            if (child && child.loc && (0, util_1.comparePos)(child.loc.end, node.loc.start) <= 0) {
              break;
            }
          }
          resultArray.splice(i2 + 1, 0, node);
          return resultArray;
        }
      } else {
        var childNodes = childNodesCache.get(node);
        if (childNodes) {
          return childNodes;
        }
      }
      var names;
      if (isArray.check(node)) {
        names = Object.keys(node);
      } else if (isObject2.check(node)) {
        names = types17.getFieldNames(node);
      } else {
        return resultArray;
      }
      if (!resultArray) {
        childNodesCache.set(node, resultArray = []);
      }
      for (var i2 = 0, nameCount = names.length; i2 < nameCount; ++i2) {
        getSortedChildNodes(node[names[i2]], lines, resultArray);
      }
      return resultArray;
    }
    function decorateComment(node, comment, lines) {
      var childNodes = getSortedChildNodes(node, lines);
      var left = 0;
      var right = childNodes && childNodes.length;
      var precedingNode;
      var followingNode;
      while (typeof right === "number" && left < right) {
        var middle = left + right >> 1;
        var child = childNodes[middle];
        if ((0, util_1.comparePos)(child.loc.start, comment.loc.start) <= 0 && (0, util_1.comparePos)(comment.loc.end, child.loc.end) <= 0) {
          decorateComment(comment.enclosingNode = child, comment, lines);
          return;
        }
        if ((0, util_1.comparePos)(child.loc.end, comment.loc.start) <= 0) {
          precedingNode = child;
          left = middle + 1;
          continue;
        }
        if ((0, util_1.comparePos)(comment.loc.end, child.loc.start) <= 0) {
          followingNode = child;
          right = middle;
          continue;
        }
        throw new Error("Comment location overlaps with node location");
      }
      if (precedingNode) {
        comment.precedingNode = precedingNode;
      }
      if (followingNode) {
        comment.followingNode = followingNode;
      }
    }
    function attach(comments, ast, lines) {
      if (!isArray.check(comments)) {
        return;
      }
      var tiesToBreak = [];
      comments.forEach(function(comment) {
        comment.loc.lines = lines;
        decorateComment(ast, comment, lines);
        var pn = comment.precedingNode;
        var en = comment.enclosingNode;
        var fn = comment.followingNode;
        if (pn && fn) {
          var tieCount = tiesToBreak.length;
          if (tieCount > 0) {
            var lastTie = tiesToBreak[tieCount - 1];
            assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);
            if (lastTie.followingNode !== comment.followingNode) {
              breakTies(tiesToBreak, lines);
            }
          }
          tiesToBreak.push(comment);
        } else if (pn) {
          breakTies(tiesToBreak, lines);
          addTrailingComment(pn, comment);
        } else if (fn) {
          breakTies(tiesToBreak, lines);
          addLeadingComment(fn, comment);
        } else if (en) {
          breakTies(tiesToBreak, lines);
          addDanglingComment(en, comment);
        } else {
          throw new Error("AST contains no nodes at all?");
        }
      });
      breakTies(tiesToBreak, lines);
      comments.forEach(function(comment) {
        delete comment.precedingNode;
        delete comment.enclosingNode;
        delete comment.followingNode;
      });
    }
    exports.attach = attach;
    function breakTies(tiesToBreak, lines) {
      var tieCount = tiesToBreak.length;
      if (tieCount === 0) {
        return;
      }
      var pn = tiesToBreak[0].precedingNode;
      var fn = tiesToBreak[0].followingNode;
      var gapEndPos = fn.loc.start;
      var indexOfFirstLeadingComment = tieCount;
      var comment;
      for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
        comment = tiesToBreak[indexOfFirstLeadingComment - 1];
        assert_1.default.strictEqual(comment.precedingNode, pn);
        assert_1.default.strictEqual(comment.followingNode, fn);
        var gap = lines.sliceString(comment.loc.end, gapEndPos);
        if (/\S/.test(gap)) {
          break;
        }
        gapEndPos = comment.loc.start;
      }
      while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && (comment.type === "Line" || comment.type === "CommentLine") && comment.loc.start.column > fn.loc.start.column) {
        ++indexOfFirstLeadingComment;
      }
      tiesToBreak.forEach(function(comment2, i2) {
        if (i2 < indexOfFirstLeadingComment) {
          addTrailingComment(pn, comment2);
        } else {
          addLeadingComment(fn, comment2);
        }
      });
      tiesToBreak.length = 0;
    }
    function addCommentHelper(node, comment) {
      var comments = node.comments || (node.comments = []);
      comments.push(comment);
    }
    function addLeadingComment(node, comment) {
      comment.leading = true;
      comment.trailing = false;
      addCommentHelper(node, comment);
    }
    function addDanglingComment(node, comment) {
      comment.leading = false;
      comment.trailing = false;
      addCommentHelper(node, comment);
    }
    function addTrailingComment(node, comment) {
      comment.leading = false;
      comment.trailing = true;
      addCommentHelper(node, comment);
    }
    function printLeadingComment(commentPath, print13) {
      var comment = commentPath.getValue();
      n.Comment.assert(comment);
      var loc = comment.loc;
      var lines = loc && loc.lines;
      var parts = [print13(commentPath)];
      if (comment.trailing) {
        parts.push("\n");
      } else if (lines instanceof lines_1.Lines) {
        var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());
        if (trailingSpace.length === 1) {
          parts.push(trailingSpace);
        } else {
          parts.push(new Array(trailingSpace.length).join("\n"));
        }
      } else {
        parts.push("\n");
      }
      return (0, lines_1.concat)(parts);
    }
    function printTrailingComment(commentPath, print13) {
      var comment = commentPath.getValue(commentPath);
      n.Comment.assert(comment);
      var loc = comment.loc;
      var lines = loc && loc.lines;
      var parts = [];
      if (lines instanceof lines_1.Lines) {
        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
        var leadingSpace = lines.slice(fromPos, loc.start);
        if (leadingSpace.length === 1) {
          parts.push(leadingSpace);
        } else {
          parts.push(new Array(leadingSpace.length).join("\n"));
        }
      }
      parts.push(print13(commentPath));
      return (0, lines_1.concat)(parts);
    }
    function printComments(path3, print13) {
      var value = path3.getValue();
      var innerLines = print13(path3);
      var comments = n.Node.check(value) && types17.getFieldValue(value, "comments");
      if (!comments || comments.length === 0) {
        return innerLines;
      }
      var leadingParts = [];
      var trailingParts = [innerLines];
      path3.each(function(commentPath) {
        var comment = commentPath.getValue();
        var leading = types17.getFieldValue(comment, "leading");
        var trailing = types17.getFieldValue(comment, "trailing");
        if (leading || trailing && !(n.Statement.check(value) || comment.type === "Block" || comment.type === "CommentBlock")) {
          leadingParts.push(printLeadingComment(commentPath, print13));
        } else if (trailing) {
          trailingParts.push(printTrailingComment(commentPath, print13));
        }
      }, "comments");
      leadingParts.push.apply(leadingParts, trailingParts);
      return (0, lines_1.concat)(leadingParts);
    }
    exports.printComments = printComments;
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var types17 = tslib_1.__importStar(require_main());
    var b2 = types17.builders;
    var isObject2 = types17.builtInTypes.object;
    var isArray = types17.builtInTypes.array;
    var options_1 = require_options();
    var lines_1 = require_lines();
    var comments_1 = require_comments();
    var util = tslib_1.__importStar(require_util2());
    function parse12(source, options) {
      options = (0, options_1.normalize)(options);
      var lines = (0, lines_1.fromString)(source, options);
      var sourceWithoutTabs = lines.toString({
        tabWidth: options.tabWidth,
        reuseWhitespace: false,
        useTabs: false
      });
      var comments = [];
      var ast = options.parser.parse(sourceWithoutTabs, {
        jsx: true,
        loc: true,
        locations: true,
        range: options.range,
        comment: true,
        onComment: comments,
        tolerant: util.getOption(options, "tolerant", true),
        ecmaVersion: 6,
        sourceType: util.getOption(options, "sourceType", "module")
      });
      var tokens = Array.isArray(ast.tokens) ? ast.tokens : require_esprima2().tokenize(sourceWithoutTabs, {
        loc: true
      });
      delete ast.tokens;
      tokens.forEach(function(token) {
        if (typeof token.value !== "string") {
          token.value = lines.sliceString(token.loc.start, token.loc.end);
        }
      });
      if (Array.isArray(ast.comments)) {
        comments = ast.comments;
        delete ast.comments;
      }
      if (ast.loc) {
        util.fixFaultyLocations(ast, lines);
      } else {
        ast.loc = {
          start: lines.firstPos(),
          end: lines.lastPos()
        };
      }
      ast.loc.lines = lines;
      ast.loc.indent = 0;
      var file;
      var program3;
      if (ast.type === "Program") {
        program3 = ast;
        file = b2.file(ast, options.sourceFileName || null);
        file.loc = {
          start: lines.firstPos(),
          end: lines.lastPos(),
          lines,
          indent: 0
        };
      } else if (ast.type === "File") {
        file = ast;
        program3 = file.program;
      }
      if (options.tokens) {
        file.tokens = tokens;
      }
      var trueProgramLoc = util.getTrueLoc({
        type: program3.type,
        loc: program3.loc,
        body: [],
        comments
      }, lines);
      program3.loc.start = trueProgramLoc.start;
      program3.loc.end = trueProgramLoc.end;
      (0, comments_1.attach)(comments, program3.body.length ? file.program : file, lines);
      return new TreeCopier(lines, tokens).copy(file);
    }
    exports.parse = parse12;
    var TreeCopier = function TreeCopier2(lines, tokens) {
      assert_1.default.ok(this instanceof TreeCopier2);
      this.lines = lines;
      this.tokens = tokens;
      this.startTokenIndex = 0;
      this.endTokenIndex = tokens.length;
      this.indent = 0;
      this.seen = /* @__PURE__ */ new Map();
    };
    var TCp = TreeCopier.prototype;
    TCp.copy = function(node) {
      if (this.seen.has(node)) {
        return this.seen.get(node);
      }
      if (isArray.check(node)) {
        var copy_1 = new Array(node.length);
        this.seen.set(node, copy_1);
        node.forEach(function(item, i3) {
          copy_1[i3] = this.copy(item);
        }, this);
        return copy_1;
      }
      if (!isObject2.check(node)) {
        return node;
      }
      util.fixFaultyLocations(node, this.lines);
      var copy = Object.create(Object.getPrototypeOf(node), {
        original: {
          value: node,
          configurable: false,
          enumerable: false,
          writable: true
        }
      });
      this.seen.set(node, copy);
      var loc = node.loc;
      var oldIndent = this.indent;
      var newIndent = oldIndent;
      var oldStartTokenIndex = this.startTokenIndex;
      var oldEndTokenIndex = this.endTokenIndex;
      if (loc) {
        if (node.type === "Block" || node.type === "Line" || node.type === "CommentBlock" || node.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {
          newIndent = this.indent = loc.start.column;
        }
        loc.lines = this.lines;
        loc.tokens = this.tokens;
        loc.indent = newIndent;
        this.findTokenRange(loc);
      }
      var keys2 = Object.keys(node);
      var keyCount = keys2.length;
      for (var i2 = 0; i2 < keyCount; ++i2) {
        var key = keys2[i2];
        if (key === "loc") {
          copy[key] = node[key];
        } else if (key === "tokens" && node.type === "File") {
          copy[key] = node[key];
        } else {
          copy[key] = this.copy(node[key]);
        }
      }
      this.indent = oldIndent;
      this.startTokenIndex = oldStartTokenIndex;
      this.endTokenIndex = oldEndTokenIndex;
      return copy;
    };
    TCp.findTokenRange = function(loc) {
      while (this.startTokenIndex > 0) {
        var token = loc.tokens[this.startTokenIndex];
        if (util.comparePos(loc.start, token.loc.start) < 0) {
          --this.startTokenIndex;
        } else
          break;
      }
      while (this.endTokenIndex < loc.tokens.length) {
        var token = loc.tokens[this.endTokenIndex];
        if (util.comparePos(token.loc.end, loc.end) < 0) {
          ++this.endTokenIndex;
        } else
          break;
      }
      while (this.startTokenIndex < this.endTokenIndex) {
        var token = loc.tokens[this.startTokenIndex];
        if (util.comparePos(token.loc.start, loc.start) < 0) {
          ++this.startTokenIndex;
        } else
          break;
      }
      loc.start.token = this.startTokenIndex;
      while (this.endTokenIndex > this.startTokenIndex) {
        var token = loc.tokens[this.endTokenIndex - 1];
        if (util.comparePos(loc.end, token.loc.end) < 0) {
          --this.endTokenIndex;
        } else
          break;
      }
      loc.end.token = this.endTokenIndex;
    };
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/fast-path.js
var require_fast_path = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/fast-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var types17 = tslib_1.__importStar(require_main());
    var util = tslib_1.__importStar(require_util2());
    var n = types17.namedTypes;
    var isArray = types17.builtInTypes.array;
    var isNumber = types17.builtInTypes.number;
    var PRECEDENCE = {};
    [
      ["??"],
      ["||"],
      ["&&"],
      ["|"],
      ["^"],
      ["&"],
      ["==", "===", "!=", "!=="],
      ["<", ">", "<=", ">=", "in", "instanceof"],
      [">>", "<<", ">>>"],
      ["+", "-"],
      ["*", "/", "%"],
      ["**"]
    ].forEach(function(tier, i2) {
      tier.forEach(function(op) {
        PRECEDENCE[op] = i2;
      });
    });
    var FastPath = function FastPath2(value) {
      assert_1.default.ok(this instanceof FastPath2);
      this.stack = [value];
    };
    var FPp = FastPath.prototype;
    FastPath.from = function(obj) {
      if (obj instanceof FastPath) {
        return obj.copy();
      }
      if (obj instanceof types17.NodePath) {
        var copy = Object.create(FastPath.prototype);
        var stack = [obj.value];
        for (var pp = void 0; pp = obj.parentPath; obj = pp)
          stack.push(obj.name, pp.value);
        copy.stack = stack.reverse();
        return copy;
      }
      return new FastPath(obj);
    };
    FPp.copy = function copy() {
      var copy2 = Object.create(FastPath.prototype);
      copy2.stack = this.stack.slice(0);
      return copy2;
    };
    FPp.getName = function getName() {
      var s2 = this.stack;
      var len = s2.length;
      if (len > 1) {
        return s2[len - 2];
      }
      return null;
    };
    FPp.getValue = function getValue() {
      var s2 = this.stack;
      return s2[s2.length - 1];
    };
    FPp.valueIsDuplicate = function() {
      var s2 = this.stack;
      var valueIndex = s2.length - 1;
      return s2.lastIndexOf(s2[valueIndex], valueIndex - 1) >= 0;
    };
    function getNodeHelper(path3, count) {
      var s2 = path3.stack;
      for (var i2 = s2.length - 1; i2 >= 0; i2 -= 2) {
        var value = s2[i2];
        if (n.Node.check(value) && --count < 0) {
          return value;
        }
      }
      return null;
    }
    FPp.getNode = function getNode(count) {
      if (count === void 0) {
        count = 0;
      }
      return getNodeHelper(this, ~~count);
    };
    FPp.getParentNode = function getParentNode(count) {
      if (count === void 0) {
        count = 0;
      }
      return getNodeHelper(this, ~~count + 1);
    };
    FPp.getRootValue = function getRootValue() {
      var s2 = this.stack;
      if (s2.length % 2 === 0) {
        return s2[1];
      }
      return s2[0];
    };
    FPp.call = function call(callback) {
      var s2 = this.stack;
      var origLen = s2.length;
      var value = s2[origLen - 1];
      var argc = arguments.length;
      for (var i2 = 1; i2 < argc; ++i2) {
        var name = arguments[i2];
        value = value[name];
        s2.push(name, value);
      }
      var result = callback(this);
      s2.length = origLen;
      return result;
    };
    FPp.each = function each(callback) {
      var s2 = this.stack;
      var origLen = s2.length;
      var value = s2[origLen - 1];
      var argc = arguments.length;
      for (var i2 = 1; i2 < argc; ++i2) {
        var name = arguments[i2];
        value = value[name];
        s2.push(name, value);
      }
      for (var i2 = 0; i2 < value.length; ++i2) {
        if (i2 in value) {
          s2.push(i2, value[i2]);
          callback(this);
          s2.length -= 2;
        }
      }
      s2.length = origLen;
    };
    FPp.map = function map(callback) {
      var s2 = this.stack;
      var origLen = s2.length;
      var value = s2[origLen - 1];
      var argc = arguments.length;
      for (var i2 = 1; i2 < argc; ++i2) {
        var name = arguments[i2];
        value = value[name];
        s2.push(name, value);
      }
      var result = new Array(value.length);
      for (var i2 = 0; i2 < value.length; ++i2) {
        if (i2 in value) {
          s2.push(i2, value[i2]);
          result[i2] = callback(this, i2);
          s2.length -= 2;
        }
      }
      s2.length = origLen;
      return result;
    };
    FPp.hasParens = function() {
      var node = this.getNode();
      var prevToken = this.getPrevToken(node);
      if (!prevToken) {
        return false;
      }
      var nextToken = this.getNextToken(node);
      if (!nextToken) {
        return false;
      }
      if (prevToken.value === "(") {
        if (nextToken.value === ")") {
          return true;
        }
        var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);
        if (justNeedsOpeningParen) {
          return true;
        }
      }
      return false;
    };
    FPp.getPrevToken = function(node) {
      node = node || this.getNode();
      var loc = node && node.loc;
      var tokens = loc && loc.tokens;
      if (tokens && loc.start.token > 0) {
        var token = tokens[loc.start.token - 1];
        if (token) {
          var rootLoc = this.getRootValue().loc;
          if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {
            return token;
          }
        }
      }
      return null;
    };
    FPp.getNextToken = function(node) {
      node = node || this.getNode();
      var loc = node && node.loc;
      var tokens = loc && loc.tokens;
      if (tokens && loc.end.token < tokens.length) {
        var token = tokens[loc.end.token];
        if (token) {
          var rootLoc = this.getRootValue().loc;
          if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {
            return token;
          }
        }
      }
      return null;
    };
    FPp.needsParens = function(assumeExpressionContext) {
      var node = this.getNode();
      if (node.type === "AssignmentExpression" && node.left.type === "ObjectPattern") {
        return true;
      }
      var parent2 = this.getParentNode();
      var name = this.getName();
      if (this.getValue() !== node) {
        return false;
      }
      if (n.Statement.check(node)) {
        return false;
      }
      if (node.type === "Identifier") {
        return false;
      }
      if (parent2 && parent2.type === "ParenthesizedExpression") {
        return false;
      }
      if (node.extra && node.extra.parenthesized) {
        return true;
      }
      if (!parent2)
        return false;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
          return parent2.type === "MemberExpression" && name === "object" && parent2.object === node;
        case "BinaryExpression":
        case "LogicalExpression":
          switch (parent2.type) {
            case "CallExpression":
              return name === "callee" && parent2.callee === node;
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
              return true;
            case "MemberExpression":
              return name === "object" && parent2.object === node;
            case "BinaryExpression":
            case "LogicalExpression": {
              var po = parent2.operator;
              var pp = PRECEDENCE[po];
              var no = node.operator;
              var np = PRECEDENCE[no];
              if (pp > np) {
                return true;
              }
              if (pp === np && name === "right") {
                assert_1.default.strictEqual(parent2.right, node);
                return true;
              }
              break;
            }
            default:
              return false;
          }
          break;
        case "SequenceExpression":
          switch (parent2.type) {
            case "ReturnStatement":
              return false;
            case "ForStatement":
              return false;
            case "ExpressionStatement":
              return name !== "expression";
            default:
              return true;
          }
        case "OptionalIndexedAccessType":
          return node.optional && parent2.type === "IndexedAccessType";
        case "IntersectionTypeAnnotation":
        case "UnionTypeAnnotation":
          return parent2.type === "NullableTypeAnnotation";
        case "Literal":
          return parent2.type === "MemberExpression" && isNumber.check(node.value) && name === "object" && parent2.object === node;
        case "NumericLiteral":
          return parent2.type === "MemberExpression" && name === "object" && parent2.object === node;
        case "YieldExpression":
        case "AwaitExpression":
        case "AssignmentExpression":
        case "ConditionalExpression":
          switch (parent2.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "BinaryExpression":
            case "LogicalExpression":
              return true;
            case "CallExpression":
            case "NewExpression":
              return name === "callee" && parent2.callee === node;
            case "ConditionalExpression":
              return name === "test" && parent2.test === node;
            case "MemberExpression":
              return name === "object" && parent2.object === node;
            default:
              return false;
          }
        case "ArrowFunctionExpression":
          if (n.CallExpression.check(parent2) && name === "callee" && parent2.callee === node) {
            return true;
          }
          if (n.MemberExpression.check(parent2) && name === "object" && parent2.object === node) {
            return true;
          }
          if (n.TSAsExpression && n.TSAsExpression.check(parent2) && name === "expression" && parent2.expression === node) {
            return true;
          }
          return isBinary(parent2);
        case "ObjectExpression":
          if (parent2.type === "ArrowFunctionExpression" && name === "body" && parent2.body === node) {
            return true;
          }
          break;
        case "TSAsExpression":
          if (parent2.type === "ArrowFunctionExpression" && name === "body" && parent2.body === node && node.expression.type === "ObjectExpression") {
            return true;
          }
          break;
        case "CallExpression":
          if (name === "declaration" && n.ExportDefaultDeclaration.check(parent2) && n.FunctionExpression.check(node.callee)) {
            return true;
          }
      }
      if (parent2.type === "NewExpression" && name === "callee" && parent2.callee === node) {
        return containsCallExpression(node);
      }
      if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {
        return true;
      }
      return false;
    };
    function isBinary(node) {
      return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
    }
    function containsCallExpression(node) {
      if (n.CallExpression.check(node)) {
        return true;
      }
      if (isArray.check(node)) {
        return node.some(containsCallExpression);
      }
      if (n.Node.check(node)) {
        return types17.someField(node, function(_name, child) {
          return containsCallExpression(child);
        });
      }
      return false;
    }
    FPp.canBeFirstInStatement = function() {
      var node = this.getNode();
      if (n.FunctionExpression.check(node)) {
        return false;
      }
      if (n.ObjectExpression.check(node)) {
        return false;
      }
      if (n.ClassExpression.check(node)) {
        return false;
      }
      return true;
    };
    FPp.firstInStatement = function() {
      var s2 = this.stack;
      var parentName, parent2;
      var childName, child;
      for (var i2 = s2.length - 1; i2 >= 0; i2 -= 2) {
        if (n.Node.check(s2[i2])) {
          childName = parentName;
          child = parent2;
          parentName = s2[i2 - 1];
          parent2 = s2[i2];
        }
        if (!parent2 || !child) {
          continue;
        }
        if (n.BlockStatement.check(parent2) && parentName === "body" && childName === 0) {
          assert_1.default.strictEqual(parent2.body[0], child);
          return true;
        }
        if (n.ExpressionStatement.check(parent2) && childName === "expression") {
          assert_1.default.strictEqual(parent2.expression, child);
          return true;
        }
        if (n.AssignmentExpression.check(parent2) && childName === "left") {
          assert_1.default.strictEqual(parent2.left, child);
          return true;
        }
        if (n.ArrowFunctionExpression.check(parent2) && childName === "body") {
          assert_1.default.strictEqual(parent2.body, child);
          return true;
        }
        if (n.SequenceExpression.check(parent2) && s2[i2 + 1] === "expressions" && childName === 0) {
          assert_1.default.strictEqual(parent2.expressions[0], child);
          continue;
        }
        if (n.CallExpression.check(parent2) && childName === "callee") {
          assert_1.default.strictEqual(parent2.callee, child);
          continue;
        }
        if (n.MemberExpression.check(parent2) && childName === "object") {
          assert_1.default.strictEqual(parent2.object, child);
          continue;
        }
        if (n.ConditionalExpression.check(parent2) && childName === "test") {
          assert_1.default.strictEqual(parent2.test, child);
          continue;
        }
        if (isBinary(parent2) && childName === "left") {
          assert_1.default.strictEqual(parent2.left, child);
          continue;
        }
        if (n.UnaryExpression.check(parent2) && !parent2.prefix && childName === "argument") {
          assert_1.default.strictEqual(parent2.argument, child);
          continue;
        }
        return false;
      }
      return true;
    };
    exports.default = FastPath;
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/patcher.js
var require_patcher = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/patcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getReprinter = exports.Patcher = void 0;
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var linesModule = tslib_1.__importStar(require_lines());
    var types17 = tslib_1.__importStar(require_main());
    var Printable = types17.namedTypes.Printable;
    var Expression = types17.namedTypes.Expression;
    var ReturnStatement = types17.namedTypes.ReturnStatement;
    var SourceLocation = types17.namedTypes.SourceLocation;
    var util_1 = require_util2();
    var fast_path_1 = tslib_1.__importDefault(require_fast_path());
    var isObject2 = types17.builtInTypes.object;
    var isArray = types17.builtInTypes.array;
    var isString = types17.builtInTypes.string;
    var riskyAdjoiningCharExp = /[0-9a-z_$]/i;
    var Patcher = function Patcher2(lines) {
      assert_1.default.ok(this instanceof Patcher2);
      assert_1.default.ok(lines instanceof linesModule.Lines);
      var self2 = this, replacements = [];
      self2.replace = function(loc, lines2) {
        if (isString.check(lines2))
          lines2 = linesModule.fromString(lines2);
        replacements.push({
          lines: lines2,
          start: loc.start,
          end: loc.end
        });
      };
      self2.get = function(loc) {
        loc = loc || {
          start: { line: 1, column: 0 },
          end: { line: lines.length, column: lines.getLineLength(lines.length) }
        };
        var sliceFrom = loc.start, toConcat = [];
        function pushSlice(from, to) {
          assert_1.default.ok((0, util_1.comparePos)(from, to) <= 0);
          toConcat.push(lines.slice(from, to));
        }
        replacements.sort(function(a2, b2) {
          return (0, util_1.comparePos)(a2.start, b2.start);
        }).forEach(function(rep) {
          if ((0, util_1.comparePos)(sliceFrom, rep.start) > 0) {
          } else {
            pushSlice(sliceFrom, rep.start);
            toConcat.push(rep.lines);
            sliceFrom = rep.end;
          }
        });
        pushSlice(sliceFrom, loc.end);
        return linesModule.concat(toConcat);
      };
    };
    exports.Patcher = Patcher;
    var Pp = Patcher.prototype;
    Pp.tryToReprintComments = function(newNode, oldNode, print13) {
      var patcher = this;
      if (!newNode.comments && !oldNode.comments) {
        return true;
      }
      var newPath = fast_path_1.default.from(newNode);
      var oldPath = fast_path_1.default.from(oldNode);
      newPath.stack.push("comments", getSurroundingComments(newNode));
      oldPath.stack.push("comments", getSurroundingComments(oldNode));
      var reprints = [];
      var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
      if (ableToReprintComments && reprints.length > 0) {
        reprints.forEach(function(reprint) {
          var oldComment = reprint.oldPath.getValue();
          assert_1.default.ok(oldComment.leading || oldComment.trailing);
          patcher.replace(
            oldComment.loc,
            print13(reprint.newPath).indentTail(oldComment.loc.indent)
          );
        });
      }
      return ableToReprintComments;
    };
    function getSurroundingComments(node) {
      var result = [];
      if (node.comments && node.comments.length > 0) {
        node.comments.forEach(function(comment) {
          if (comment.leading || comment.trailing) {
            result.push(comment);
          }
        });
      }
      return result;
    }
    Pp.deleteComments = function(node) {
      if (!node.comments) {
        return;
      }
      var patcher = this;
      node.comments.forEach(function(comment) {
        if (comment.leading) {
          patcher.replace({
            start: comment.loc.start,
            end: node.loc.lines.skipSpaces(comment.loc.end, false, false)
          }, "");
        } else if (comment.trailing) {
          patcher.replace({
            start: node.loc.lines.skipSpaces(comment.loc.start, true, false),
            end: comment.loc.end
          }, "");
        }
      });
    };
    function getReprinter(path3) {
      assert_1.default.ok(path3 instanceof fast_path_1.default);
      var node = path3.getValue();
      if (!Printable.check(node))
        return;
      var orig = node.original;
      var origLoc = orig && orig.loc;
      var lines = origLoc && origLoc.lines;
      var reprints = [];
      if (!lines || !findReprints(path3, reprints))
        return;
      return function(print13) {
        var patcher = new Patcher(lines);
        reprints.forEach(function(reprint) {
          var newNode = reprint.newPath.getValue();
          var oldNode = reprint.oldPath.getValue();
          SourceLocation.assert(oldNode.loc, true);
          var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print13);
          if (needToPrintNewPathWithComments) {
            patcher.deleteComments(oldNode);
          }
          var newLines = print13(reprint.newPath, {
            includeComments: needToPrintNewPathWithComments,
            avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
          }).indentTail(oldNode.loc.indent);
          var nls = needsLeadingSpace(lines, oldNode.loc, newLines);
          var nts = needsTrailingSpace(lines, oldNode.loc, newLines);
          if (nls || nts) {
            var newParts = [];
            nls && newParts.push(" ");
            newParts.push(newLines);
            nts && newParts.push(" ");
            newLines = linesModule.concat(newParts);
          }
          patcher.replace(oldNode.loc, newLines);
        });
        var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);
        if (path3.needsParens()) {
          return linesModule.concat(["(", patchedLines, ")"]);
        }
        return patchedLines;
      };
    }
    exports.getReprinter = getReprinter;
    function needsLeadingSpace(oldLines, oldLoc, newLines) {
      var posBeforeOldLoc = (0, util_1.copyPos)(oldLoc.start);
      var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
      var newFirstChar = newLines.charAt(newLines.firstPos());
      return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
    }
    function needsTrailingSpace(oldLines, oldLoc, newLines) {
      var charAfterOldLoc = oldLines.charAt(oldLoc.end);
      var newLastPos = newLines.lastPos();
      var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
      return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
    }
    function findReprints(newPath, reprints) {
      var newNode = newPath.getValue();
      Printable.assert(newNode);
      var oldNode = newNode.original;
      Printable.assert(oldNode);
      assert_1.default.deepEqual(reprints, []);
      if (newNode.type !== oldNode.type) {
        return false;
      }
      var oldPath = new fast_path_1.default(oldNode);
      var canReprint = findChildReprints(newPath, oldPath, reprints);
      if (!canReprint) {
        reprints.length = 0;
      }
      return canReprint;
    }
    function findAnyReprints(newPath, oldPath, reprints) {
      var newNode = newPath.getValue();
      var oldNode = oldPath.getValue();
      if (newNode === oldNode)
        return true;
      if (isArray.check(newNode))
        return findArrayReprints(newPath, oldPath, reprints);
      if (isObject2.check(newNode))
        return findObjectReprints(newPath, oldPath, reprints);
      return false;
    }
    function findArrayReprints(newPath, oldPath, reprints) {
      var newNode = newPath.getValue();
      var oldNode = oldPath.getValue();
      if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
        return true;
      }
      isArray.assert(newNode);
      var len = newNode.length;
      if (!(isArray.check(oldNode) && oldNode.length === len))
        return false;
      for (var i2 = 0; i2 < len; ++i2) {
        newPath.stack.push(i2, newNode[i2]);
        oldPath.stack.push(i2, oldNode[i2]);
        var canReprint = findAnyReprints(newPath, oldPath, reprints);
        newPath.stack.length -= 2;
        oldPath.stack.length -= 2;
        if (!canReprint) {
          return false;
        }
      }
      return true;
    }
    function findObjectReprints(newPath, oldPath, reprints) {
      var newNode = newPath.getValue();
      isObject2.assert(newNode);
      if (newNode.original === null) {
        return false;
      }
      var oldNode = oldPath.getValue();
      if (!isObject2.check(oldNode))
        return false;
      if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {
        return true;
      }
      if (Printable.check(newNode)) {
        if (!Printable.check(oldNode)) {
          return false;
        }
        var newParentNode = newPath.getParentNode();
        var oldParentNode = oldPath.getParentNode();
        if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
          var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
          var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
          if (!oldNeedsParens && newNeedParens) {
            return false;
          }
        }
        if (newNode.type === oldNode.type) {
          var childReprints = [];
          if (findChildReprints(newPath, oldPath, childReprints)) {
            reprints.push.apply(reprints, childReprints);
          } else if (oldNode.loc) {
            reprints.push({
              oldPath: oldPath.copy(),
              newPath: newPath.copy()
            });
          } else {
            return false;
          }
          return true;
        }
        if (Expression.check(newNode) && Expression.check(oldNode) && oldNode.loc) {
          reprints.push({
            oldPath: oldPath.copy(),
            newPath: newPath.copy()
          });
          return true;
        }
        return false;
      }
      return findChildReprints(newPath, oldPath, reprints);
    }
    function findChildReprints(newPath, oldPath, reprints) {
      var newNode = newPath.getValue();
      var oldNode = oldPath.getValue();
      isObject2.assert(newNode);
      isObject2.assert(oldNode);
      if (newNode.original === null) {
        return false;
      }
      if (newPath.needsParens() && !oldPath.hasParens()) {
        return false;
      }
      var keys2 = (0, util_1.getUnionOfKeys)(oldNode, newNode);
      if (oldNode.type === "File" || newNode.type === "File") {
        delete keys2.tokens;
      }
      delete keys2.loc;
      var originalReprintCount = reprints.length;
      for (var k3 in keys2) {
        if (k3.charAt(0) === "_") {
          continue;
        }
        newPath.stack.push(k3, types17.getFieldValue(newNode, k3));
        oldPath.stack.push(k3, types17.getFieldValue(oldNode, k3));
        var canReprint = findAnyReprints(newPath, oldPath, reprints);
        newPath.stack.length -= 2;
        oldPath.stack.length -= 2;
        if (!canReprint) {
          return false;
        }
      }
      if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {
        return false;
      }
      return true;
    }
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/printer.js
var require_printer = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/lib/printer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Printer = void 0;
    var tslib_1 = require_tslib();
    var assert_1 = tslib_1.__importDefault(require("assert"));
    var types17 = tslib_1.__importStar(require_main());
    var comments_1 = require_comments();
    var fast_path_1 = tslib_1.__importDefault(require_fast_path());
    var lines_1 = require_lines();
    var options_1 = require_options();
    var patcher_1 = require_patcher();
    var util = tslib_1.__importStar(require_util2());
    var namedTypes = types17.namedTypes;
    var isString = types17.builtInTypes.string;
    var isObject2 = types17.builtInTypes.object;
    var PrintResult = function PrintResult2(code, sourceMap) {
      assert_1.default.ok(this instanceof PrintResult2);
      isString.assert(code);
      this.code = code;
      if (sourceMap) {
        isObject2.assert(sourceMap);
        this.map = sourceMap;
      }
    };
    var PRp = PrintResult.prototype;
    var warnedAboutToString = false;
    PRp.toString = function() {
      if (!warnedAboutToString) {
        console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged.");
        warnedAboutToString = true;
      }
      return this.code;
    };
    var emptyPrintResult = new PrintResult("");
    var Printer = function Printer2(config) {
      assert_1.default.ok(this instanceof Printer2);
      var explicitTabWidth = config && config.tabWidth;
      config = (0, options_1.normalize)(config);
      config.sourceFileName = null;
      function makePrintFunctionWith(options, overrides) {
        options = Object.assign({}, options, overrides);
        return function(path3) {
          return print13(path3, options);
        };
      }
      function print13(path3, options) {
        assert_1.default.ok(path3 instanceof fast_path_1.default);
        options = options || {};
        if (options.includeComments) {
          return (0, comments_1.printComments)(path3, makePrintFunctionWith(options, {
            includeComments: false
          }));
        }
        var oldTabWidth = config.tabWidth;
        if (!explicitTabWidth) {
          var loc = path3.getNode().loc;
          if (loc && loc.lines && loc.lines.guessTabWidth) {
            config.tabWidth = loc.lines.guessTabWidth();
          }
        }
        var reprinter = (0, patcher_1.getReprinter)(path3);
        var lines = reprinter ? reprinter(print13) : genericPrint(path3, config, options, makePrintFunctionWith(options, {
          includeComments: true,
          avoidRootParens: false
        }));
        config.tabWidth = oldTabWidth;
        return lines;
      }
      this.print = function(ast) {
        if (!ast) {
          return emptyPrintResult;
        }
        var lines = print13(fast_path_1.default.from(ast), {
          includeComments: true,
          avoidRootParens: false
        });
        return new PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));
      };
      this.printGenerically = function(ast) {
        if (!ast) {
          return emptyPrintResult;
        }
        function printGenerically(path4) {
          return (0, comments_1.printComments)(path4, function(path5) {
            return genericPrint(path5, config, {
              includeComments: true,
              avoidRootParens: false
            }, printGenerically);
          });
        }
        var path3 = fast_path_1.default.from(ast);
        var oldReuseWhitespace = config.reuseWhitespace;
        config.reuseWhitespace = false;
        var pr = new PrintResult(printGenerically(path3).toString(config));
        config.reuseWhitespace = oldReuseWhitespace;
        return pr;
      };
    };
    exports.Printer = Printer;
    function genericPrint(path3, config, options, printPath) {
      assert_1.default.ok(path3 instanceof fast_path_1.default);
      var node = path3.getValue();
      var parts = [];
      var linesWithoutParens = genericPrintNoParens(path3, config, printPath);
      if (!node || linesWithoutParens.isEmpty()) {
        return linesWithoutParens;
      }
      var shouldAddParens = false;
      var decoratorsLines = printDecorators(path3, printPath);
      if (decoratorsLines.isEmpty()) {
        if (!options.avoidRootParens) {
          shouldAddParens = path3.needsParens();
        }
      } else {
        parts.push(decoratorsLines);
      }
      if (shouldAddParens) {
        parts.unshift("(");
      }
      parts.push(linesWithoutParens);
      if (shouldAddParens) {
        parts.push(")");
      }
      return (0, lines_1.concat)(parts);
    }
    function genericPrintNoParens(path3, options, print13) {
      var n = path3.getValue();
      if (!n) {
        return (0, lines_1.fromString)("");
      }
      if (typeof n === "string") {
        return (0, lines_1.fromString)(n, options);
      }
      namedTypes.Printable.assert(n);
      var parts = [];
      switch (n.type) {
        case "File":
          return path3.call(print13, "program");
        case "Program":
          if (n.directives) {
            path3.each(function(childPath) {
              parts.push(print13(childPath), ";\n");
            }, "directives");
          }
          if (n.interpreter) {
            parts.push(path3.call(print13, "interpreter"));
          }
          parts.push(path3.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print13);
          }, "body"));
          return (0, lines_1.concat)(parts);
        case "Noop":
        case "EmptyStatement":
          return (0, lines_1.fromString)("");
        case "ExpressionStatement":
          return (0, lines_1.concat)([path3.call(print13, "expression"), ";"]);
        case "ParenthesizedExpression":
          return (0, lines_1.concat)(["(", path3.call(print13, "expression"), ")"]);
        case "BinaryExpression":
        case "LogicalExpression":
        case "AssignmentExpression":
          return (0, lines_1.fromString)(" ").join([
            path3.call(print13, "left"),
            n.operator,
            path3.call(print13, "right")
          ]);
        case "AssignmentPattern":
          return (0, lines_1.concat)([
            path3.call(print13, "left"),
            " = ",
            path3.call(print13, "right")
          ]);
        case "MemberExpression":
        case "OptionalMemberExpression": {
          parts.push(path3.call(print13, "object"));
          var property = path3.call(print13, "property");
          var optional = types17.getFieldValue(n, "optional");
          if (n.computed) {
            parts.push(optional ? "?.[" : "[", property, "]");
          } else {
            parts.push(optional ? "?." : ".", property);
          }
          return (0, lines_1.concat)(parts);
        }
        case "ChainExpression":
          return path3.call(print13, "expression");
        case "MetaProperty":
          return (0, lines_1.concat)([
            path3.call(print13, "meta"),
            ".",
            path3.call(print13, "property")
          ]);
        case "BindExpression":
          if (n.object) {
            parts.push(path3.call(print13, "object"));
          }
          parts.push("::", path3.call(print13, "callee"));
          return (0, lines_1.concat)(parts);
        case "Path":
          return (0, lines_1.fromString)(".").join(n.body);
        case "Identifier":
          return (0, lines_1.concat)([
            (0, lines_1.fromString)(n.name, options),
            n.optional ? "?" : "",
            path3.call(print13, "typeAnnotation")
          ]);
        case "SpreadElement":
        case "SpreadElementPattern":
        case "RestProperty":
        case "SpreadProperty":
        case "SpreadPropertyPattern":
        case "ObjectTypeSpreadProperty":
        case "RestElement":
          return (0, lines_1.concat)([
            "...",
            path3.call(print13, "argument"),
            path3.call(print13, "typeAnnotation")
          ]);
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "TSDeclareFunction":
          if (n.declare) {
            parts.push("declare ");
          }
          if (n.async) {
            parts.push("async ");
          }
          parts.push("function");
          if (n.generator)
            parts.push("*");
          if (n.id) {
            parts.push(" ", path3.call(print13, "id"), path3.call(print13, "typeParameters"));
          } else {
            if (n.typeParameters) {
              parts.push(path3.call(print13, "typeParameters"));
            }
          }
          parts.push("(", printFunctionParams(path3, options, print13), ")", path3.call(print13, "returnType"));
          if (n.body) {
            parts.push(" ", path3.call(print13, "body"));
          }
          return (0, lines_1.concat)(parts);
        case "ArrowFunctionExpression":
          if (n.async) {
            parts.push("async ");
          }
          if (n.typeParameters) {
            parts.push(path3.call(print13, "typeParameters"));
          }
          if (!options.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === "Identifier" && !n.params[0].typeAnnotation && !n.returnType) {
            parts.push(path3.call(print13, "params", 0));
          } else {
            parts.push("(", printFunctionParams(path3, options, print13), ")", path3.call(print13, "returnType"));
          }
          parts.push(" => ", path3.call(print13, "body"));
          return (0, lines_1.concat)(parts);
        case "MethodDefinition":
          return printMethod(path3, options, print13);
        case "YieldExpression":
          parts.push("yield");
          if (n.delegate)
            parts.push("*");
          if (n.argument)
            parts.push(" ", path3.call(print13, "argument"));
          return (0, lines_1.concat)(parts);
        case "AwaitExpression":
          parts.push("await");
          if (n.all)
            parts.push("*");
          if (n.argument)
            parts.push(" ", path3.call(print13, "argument"));
          return (0, lines_1.concat)(parts);
        case "ModuleExpression":
          return (0, lines_1.concat)([
            "module {\n",
            path3.call(print13, "body").indent(options.tabWidth),
            "\n}"
          ]);
        case "ModuleDeclaration":
          parts.push("module", path3.call(print13, "id"));
          if (n.source) {
            assert_1.default.ok(!n.body);
            parts.push("from", path3.call(print13, "source"));
          } else {
            parts.push(path3.call(print13, "body"));
          }
          return (0, lines_1.fromString)(" ").join(parts);
        case "ImportSpecifier":
          if (n.importKind && n.importKind !== "value") {
            parts.push(n.importKind + " ");
          }
          if (n.imported) {
            parts.push(path3.call(print13, "imported"));
            if (n.local && n.local.name !== n.imported.name) {
              parts.push(" as ", path3.call(print13, "local"));
            }
          } else if (n.id) {
            parts.push(path3.call(print13, "id"));
            if (n.name) {
              parts.push(" as ", path3.call(print13, "name"));
            }
          }
          return (0, lines_1.concat)(parts);
        case "ExportSpecifier":
          if (n.local) {
            parts.push(path3.call(print13, "local"));
            if (n.exported && n.exported.name !== n.local.name) {
              parts.push(" as ", path3.call(print13, "exported"));
            }
          } else if (n.id) {
            parts.push(path3.call(print13, "id"));
            if (n.name) {
              parts.push(" as ", path3.call(print13, "name"));
            }
          }
          return (0, lines_1.concat)(parts);
        case "ExportBatchSpecifier":
          return (0, lines_1.fromString)("*");
        case "ImportNamespaceSpecifier":
          parts.push("* as ");
          if (n.local) {
            parts.push(path3.call(print13, "local"));
          } else if (n.id) {
            parts.push(path3.call(print13, "id"));
          }
          return (0, lines_1.concat)(parts);
        case "ImportDefaultSpecifier":
          if (n.local) {
            return path3.call(print13, "local");
          }
          return path3.call(print13, "id");
        case "TSExportAssignment":
          return (0, lines_1.concat)(["export = ", path3.call(print13, "expression")]);
        case "ExportDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          return printExportDeclaration(path3, options, print13);
        case "ExportAllDeclaration":
          parts.push("export *");
          if (n.exported) {
            parts.push(" as ", path3.call(print13, "exported"));
          }
          parts.push(" from ", path3.call(print13, "source"), ";");
          return (0, lines_1.concat)(parts);
        case "TSNamespaceExportDeclaration":
          parts.push("export as namespace ", path3.call(print13, "id"));
          return maybeAddSemicolon((0, lines_1.concat)(parts));
        case "ExportNamespaceSpecifier":
          return (0, lines_1.concat)(["* as ", path3.call(print13, "exported")]);
        case "ExportDefaultSpecifier":
          return path3.call(print13, "exported");
        case "Import":
          return (0, lines_1.fromString)("import", options);
        case "ImportExpression":
          return (0, lines_1.concat)(["import(", path3.call(print13, "source"), ")"]);
        case "ImportDeclaration": {
          parts.push("import ");
          if (n.importKind && n.importKind !== "value") {
            parts.push(n.importKind + " ");
          }
          if (n.specifiers && n.specifiers.length > 0) {
            var unbracedSpecifiers_1 = [];
            var bracedSpecifiers_1 = [];
            path3.each(function(specifierPath) {
              var spec = specifierPath.getValue();
              if (spec.type === "ImportSpecifier") {
                bracedSpecifiers_1.push(print13(specifierPath));
              } else if (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") {
                unbracedSpecifiers_1.push(print13(specifierPath));
              }
            }, "specifiers");
            unbracedSpecifiers_1.forEach(function(lines2, i2) {
              if (i2 > 0) {
                parts.push(", ");
              }
              parts.push(lines2);
            });
            if (bracedSpecifiers_1.length > 0) {
              var lines = (0, lines_1.fromString)(", ").join(bracedSpecifiers_1);
              if (lines.getLineLength(1) > options.wrapColumn) {
                lines = (0, lines_1.concat)([
                  (0, lines_1.fromString)(",\n").join(bracedSpecifiers_1).indent(options.tabWidth),
                  ","
                ]);
              }
              if (unbracedSpecifiers_1.length > 0) {
                parts.push(", ");
              }
              if (lines.length > 1) {
                parts.push("{\n", lines, "\n}");
              } else if (options.objectCurlySpacing) {
                parts.push("{ ", lines, " }");
              } else {
                parts.push("{", lines, "}");
              }
            }
            parts.push(" from ");
          }
          parts.push(path3.call(print13, "source"), maybePrintImportAssertions(path3, options, print13), ";");
          return (0, lines_1.concat)(parts);
        }
        case "ImportAttribute":
          return (0, lines_1.concat)([path3.call(print13, "key"), ": ", path3.call(print13, "value")]);
        case "StaticBlock":
          parts.push("static ");
        case "BlockStatement": {
          var naked_1 = path3.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print13);
          }, "body");
          if (naked_1.isEmpty()) {
            if (!n.directives || n.directives.length === 0) {
              parts.push("{}");
              return (0, lines_1.concat)(parts);
            }
          }
          parts.push("{\n");
          if (n.directives) {
            path3.each(function(childPath) {
              parts.push(maybeAddSemicolon(print13(childPath).indent(options.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? "\n" : "");
            }, "directives");
          }
          parts.push(naked_1.indent(options.tabWidth));
          parts.push("\n}");
          return (0, lines_1.concat)(parts);
        }
        case "ReturnStatement": {
          parts.push("return");
          if (n.argument) {
            var argLines = path3.call(print13, "argument");
            if (argLines.startsWithComment() || argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n.argument)) {
              parts.push(" (\n", argLines.indent(options.tabWidth), "\n)");
            } else {
              parts.push(" ", argLines);
            }
          }
          parts.push(";");
          return (0, lines_1.concat)(parts);
        }
        case "CallExpression":
        case "OptionalCallExpression":
          parts.push(path3.call(print13, "callee"));
          if (n.typeParameters) {
            parts.push(path3.call(print13, "typeParameters"));
          }
          if (n.typeArguments) {
            parts.push(path3.call(print13, "typeArguments"));
          }
          if (types17.getFieldValue(n, "optional")) {
            parts.push("?.");
          }
          parts.push(printArgumentsList(path3, options, print13));
          return (0, lines_1.concat)(parts);
        case "RecordExpression":
          parts.push("#");
        case "ObjectExpression":
        case "ObjectPattern":
        case "ObjectTypeAnnotation": {
          var isTypeAnnotation_1 = n.type === "ObjectTypeAnnotation";
          var separator_1 = options.flowObjectCommas ? "," : isTypeAnnotation_1 ? ";" : ",";
          var fields = [];
          var allowBreak_1 = false;
          if (isTypeAnnotation_1) {
            fields.push("indexers", "callProperties");
            if (n.internalSlots != null) {
              fields.push("internalSlots");
            }
          }
          fields.push("properties");
          var len_1 = 0;
          fields.forEach(function(field) {
            len_1 += n[field].length;
          });
          var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0;
          var leftBrace = n.exact ? "{|" : "{";
          var rightBrace = n.exact ? "|}" : "}";
          parts.push(oneLine_1 ? leftBrace : leftBrace + "\n");
          var leftBraceIndex = parts.length - 1;
          var i_1 = 0;
          fields.forEach(function(field) {
            path3.each(function(childPath) {
              var lines2 = print13(childPath);
              if (!oneLine_1) {
                lines2 = lines2.indent(options.tabWidth);
              }
              var multiLine = !isTypeAnnotation_1 && lines2.length > 1;
              if (multiLine && allowBreak_1) {
                parts.push("\n");
              }
              parts.push(lines2);
              if (i_1 < len_1 - 1) {
                parts.push(separator_1 + (multiLine ? "\n\n" : "\n"));
                allowBreak_1 = !multiLine;
              } else if (len_1 !== 1 && isTypeAnnotation_1) {
                parts.push(separator_1);
              } else if (!oneLine_1 && util.isTrailingCommaEnabled(options, "objects") && childPath.getValue().type !== "RestElement") {
                parts.push(separator_1);
              }
              i_1++;
            }, field);
          });
          if (n.inexact) {
            var line = (0, lines_1.fromString)("...", options);
            if (oneLine_1) {
              if (len_1 > 0) {
                parts.push(separator_1, " ");
              }
              parts.push(line);
            } else {
              parts.push("\n", line.indent(options.tabWidth));
            }
          }
          parts.push(oneLine_1 ? rightBrace : "\n" + rightBrace);
          if (i_1 !== 0 && oneLine_1 && options.objectCurlySpacing) {
            parts[leftBraceIndex] = leftBrace + " ";
            parts[parts.length - 1] = " " + rightBrace;
          }
          if (n.typeAnnotation) {
            parts.push(path3.call(print13, "typeAnnotation"));
          }
          return (0, lines_1.concat)(parts);
        }
        case "PropertyPattern":
          return (0, lines_1.concat)([
            path3.call(print13, "key"),
            ": ",
            path3.call(print13, "pattern")
          ]);
        case "ObjectProperty":
        case "Property": {
          if (n.method || n.kind === "get" || n.kind === "set") {
            return printMethod(path3, options, print13);
          }
          if (n.shorthand && n.value.type === "AssignmentPattern") {
            return path3.call(print13, "value");
          }
          var key = path3.call(print13, "key");
          if (n.computed) {
            parts.push("[", key, "]");
          } else {
            parts.push(key);
          }
          if (!n.shorthand || n.key.name !== n.value.name) {
            parts.push(": ", path3.call(print13, "value"));
          }
          return (0, lines_1.concat)(parts);
        }
        case "ClassMethod":
        case "ObjectMethod":
        case "ClassPrivateMethod":
        case "TSDeclareMethod":
          return printMethod(path3, options, print13);
        case "PrivateName":
          return (0, lines_1.concat)(["#", path3.call(print13, "id")]);
        case "Decorator":
          return (0, lines_1.concat)(["@", path3.call(print13, "expression")]);
        case "TupleExpression":
          parts.push("#");
        case "ArrayExpression":
        case "ArrayPattern": {
          var elems = n.elements;
          var len_2 = elems.length;
          var printed_1 = path3.map(print13, "elements");
          var joined = (0, lines_1.fromString)(", ").join(printed_1);
          var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;
          if (oneLine_2) {
            if (options.arrayBracketSpacing) {
              parts.push("[ ");
            } else {
              parts.push("[");
            }
          } else {
            parts.push("[\n");
          }
          path3.each(function(elemPath) {
            var i2 = elemPath.getName();
            var elem = elemPath.getValue();
            if (!elem) {
              parts.push(",");
            } else {
              var lines2 = printed_1[i2];
              if (oneLine_2) {
                if (i2 > 0)
                  parts.push(" ");
              } else {
                lines2 = lines2.indent(options.tabWidth);
              }
              parts.push(lines2);
              if (i2 < len_2 - 1 || !oneLine_2 && util.isTrailingCommaEnabled(options, "arrays"))
                parts.push(",");
              if (!oneLine_2)
                parts.push("\n");
            }
          }, "elements");
          if (oneLine_2 && options.arrayBracketSpacing) {
            parts.push(" ]");
          } else {
            parts.push("]");
          }
          if (n.typeAnnotation) {
            parts.push(path3.call(print13, "typeAnnotation"));
          }
          return (0, lines_1.concat)(parts);
        }
        case "SequenceExpression":
          return (0, lines_1.fromString)(", ").join(path3.map(print13, "expressions"));
        case "ThisExpression":
          return (0, lines_1.fromString)("this");
        case "Super":
          return (0, lines_1.fromString)("super");
        case "NullLiteral":
          return (0, lines_1.fromString)("null");
        case "RegExpLiteral":
          return (0, lines_1.fromString)(getPossibleRaw(n) || "/".concat(n.pattern, "/").concat(n.flags || ""), options);
        case "BigIntLiteral":
          return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "n", options);
        case "NumericLiteral":
          return (0, lines_1.fromString)(getPossibleRaw(n) || n.value, options);
        case "DecimalLiteral":
          return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "m", options);
        case "StringLiteral":
          return (0, lines_1.fromString)(nodeStr(n.value, options));
        case "BooleanLiteral":
        case "Literal":
          return (0, lines_1.fromString)(getPossibleRaw(n) || (typeof n.value === "string" ? nodeStr(n.value, options) : n.value), options);
        case "Directive":
          return path3.call(print13, "value");
        case "DirectiveLiteral":
          return (0, lines_1.fromString)(getPossibleRaw(n) || nodeStr(n.value, options), options);
        case "InterpreterDirective":
          return (0, lines_1.fromString)("#!".concat(n.value, "\n"), options);
        case "ModuleSpecifier":
          if (n.local) {
            throw new Error("The ESTree ModuleSpecifier type should be abstract");
          }
          return (0, lines_1.fromString)(nodeStr(n.value, options), options);
        case "UnaryExpression":
          parts.push(n.operator);
          if (/[a-z]$/.test(n.operator))
            parts.push(" ");
          parts.push(path3.call(print13, "argument"));
          return (0, lines_1.concat)(parts);
        case "UpdateExpression":
          parts.push(path3.call(print13, "argument"), n.operator);
          if (n.prefix)
            parts.reverse();
          return (0, lines_1.concat)(parts);
        case "ConditionalExpression":
          return (0, lines_1.concat)([
            path3.call(print13, "test"),
            " ? ",
            path3.call(print13, "consequent"),
            " : ",
            path3.call(print13, "alternate")
          ]);
        case "NewExpression": {
          parts.push("new ", path3.call(print13, "callee"));
          if (n.typeParameters) {
            parts.push(path3.call(print13, "typeParameters"));
          }
          if (n.typeArguments) {
            parts.push(path3.call(print13, "typeArguments"));
          }
          var args = n.arguments;
          if (args) {
            parts.push(printArgumentsList(path3, options, print13));
          }
          return (0, lines_1.concat)(parts);
        }
        case "VariableDeclaration": {
          if (n.declare) {
            parts.push("declare ");
          }
          parts.push(n.kind, " ");
          var maxLen_1 = 0;
          var printed = path3.map(function(childPath) {
            var lines2 = print13(childPath);
            maxLen_1 = Math.max(lines2.length, maxLen_1);
            return lines2;
          }, "declarations");
          if (maxLen_1 === 1) {
            parts.push((0, lines_1.fromString)(", ").join(printed));
          } else if (printed.length > 1) {
            parts.push((0, lines_1.fromString)(",\n").join(printed).indentTail(n.kind.length + 1));
          } else {
            parts.push(printed[0]);
          }
          var parentNode = path3.getParentNode();
          if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) {
            parts.push(";");
          }
          return (0, lines_1.concat)(parts);
        }
        case "VariableDeclarator":
          return n.init ? (0, lines_1.fromString)(" = ").join([
            path3.call(print13, "id"),
            path3.call(print13, "init")
          ]) : path3.call(print13, "id");
        case "WithStatement":
          return (0, lines_1.concat)([
            "with (",
            path3.call(print13, "object"),
            ") ",
            path3.call(print13, "body")
          ]);
        case "IfStatement": {
          var con = adjustClause(path3.call(print13, "consequent"), options);
          parts.push("if (", path3.call(print13, "test"), ")", con);
          if (n.alternate)
            parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path3.call(print13, "alternate"), options));
          return (0, lines_1.concat)(parts);
        }
        case "ForStatement": {
          var init3 = path3.call(print13, "init");
          var sep2 = init3.length > 1 ? ";\n" : "; ";
          var forParen = "for (";
          var indented = (0, lines_1.fromString)(sep2).join([init3, path3.call(print13, "test"), path3.call(print13, "update")]).indentTail(forParen.length);
          var head = (0, lines_1.concat)([forParen, indented, ")"]);
          var clause = adjustClause(path3.call(print13, "body"), options);
          parts.push(head);
          if (head.length > 1) {
            parts.push("\n");
            clause = clause.trimLeft();
          }
          parts.push(clause);
          return (0, lines_1.concat)(parts);
        }
        case "WhileStatement":
          return (0, lines_1.concat)([
            "while (",
            path3.call(print13, "test"),
            ")",
            adjustClause(path3.call(print13, "body"), options)
          ]);
        case "ForInStatement":
          return (0, lines_1.concat)([
            n.each ? "for each (" : "for (",
            path3.call(print13, "left"),
            " in ",
            path3.call(print13, "right"),
            ")",
            adjustClause(path3.call(print13, "body"), options)
          ]);
        case "ForOfStatement":
        case "ForAwaitStatement":
          parts.push("for ");
          if (n.await || n.type === "ForAwaitStatement") {
            parts.push("await ");
          }
          parts.push("(", path3.call(print13, "left"), " of ", path3.call(print13, "right"), ")", adjustClause(path3.call(print13, "body"), options));
          return (0, lines_1.concat)(parts);
        case "DoWhileStatement": {
          var doBody = (0, lines_1.concat)([
            "do",
            adjustClause(path3.call(print13, "body"), options)
          ]);
          parts.push(doBody);
          if (endsWithBrace(doBody))
            parts.push(" while");
          else
            parts.push("\nwhile");
          parts.push(" (", path3.call(print13, "test"), ");");
          return (0, lines_1.concat)(parts);
        }
        case "DoExpression": {
          var statements = path3.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print13);
          }, "body");
          return (0, lines_1.concat)(["do {\n", statements.indent(options.tabWidth), "\n}"]);
        }
        case "BreakStatement":
          parts.push("break");
          if (n.label)
            parts.push(" ", path3.call(print13, "label"));
          parts.push(";");
          return (0, lines_1.concat)(parts);
        case "ContinueStatement":
          parts.push("continue");
          if (n.label)
            parts.push(" ", path3.call(print13, "label"));
          parts.push(";");
          return (0, lines_1.concat)(parts);
        case "LabeledStatement":
          return (0, lines_1.concat)([
            path3.call(print13, "label"),
            ":\n",
            path3.call(print13, "body")
          ]);
        case "TryStatement":
          parts.push("try ", path3.call(print13, "block"));
          if (n.handler) {
            parts.push(" ", path3.call(print13, "handler"));
          } else if (n.handlers) {
            path3.each(function(handlerPath) {
              parts.push(" ", print13(handlerPath));
            }, "handlers");
          }
          if (n.finalizer) {
            parts.push(" finally ", path3.call(print13, "finalizer"));
          }
          return (0, lines_1.concat)(parts);
        case "CatchClause":
          parts.push("catch ");
          if (n.param) {
            parts.push("(", path3.call(print13, "param"));
          }
          if (n.guard) {
            parts.push(" if ", path3.call(print13, "guard"));
          }
          if (n.param) {
            parts.push(") ");
          }
          parts.push(path3.call(print13, "body"));
          return (0, lines_1.concat)(parts);
        case "ThrowStatement":
          return (0, lines_1.concat)(["throw ", path3.call(print13, "argument"), ";"]);
        case "SwitchStatement":
          return (0, lines_1.concat)([
            "switch (",
            path3.call(print13, "discriminant"),
            ") {\n",
            (0, lines_1.fromString)("\n").join(path3.map(print13, "cases")),
            "\n}"
          ]);
        case "SwitchCase":
          if (n.test)
            parts.push("case ", path3.call(print13, "test"), ":");
          else
            parts.push("default:");
          if (n.consequent.length > 0) {
            parts.push("\n", path3.call(function(consequentPath) {
              return printStatementSequence(consequentPath, options, print13);
            }, "consequent").indent(options.tabWidth));
          }
          return (0, lines_1.concat)(parts);
        case "DebuggerStatement":
          return (0, lines_1.fromString)("debugger;");
        case "JSXAttribute":
          parts.push(path3.call(print13, "name"));
          if (n.value)
            parts.push("=", path3.call(print13, "value"));
          return (0, lines_1.concat)(parts);
        case "JSXIdentifier":
          return (0, lines_1.fromString)(n.name, options);
        case "JSXNamespacedName":
          return (0, lines_1.fromString)(":").join([
            path3.call(print13, "namespace"),
            path3.call(print13, "name")
          ]);
        case "JSXMemberExpression":
          return (0, lines_1.fromString)(".").join([
            path3.call(print13, "object"),
            path3.call(print13, "property")
          ]);
        case "JSXSpreadAttribute":
          return (0, lines_1.concat)(["{...", path3.call(print13, "argument"), "}"]);
        case "JSXSpreadChild":
          return (0, lines_1.concat)(["{...", path3.call(print13, "expression"), "}"]);
        case "JSXExpressionContainer":
          return (0, lines_1.concat)(["{", path3.call(print13, "expression"), "}"]);
        case "JSXElement":
        case "JSXFragment": {
          var openingPropName = "opening" + (n.type === "JSXElement" ? "Element" : "Fragment");
          var closingPropName = "closing" + (n.type === "JSXElement" ? "Element" : "Fragment");
          var openingLines = path3.call(print13, openingPropName);
          if (n[openingPropName].selfClosing) {
            assert_1.default.ok(!n[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n.type);
            return openingLines;
          }
          var childLines = (0, lines_1.concat)(path3.map(function(childPath) {
            var child = childPath.getValue();
            if (namedTypes.Literal.check(child) && typeof child.value === "string") {
              if (/\S/.test(child.value)) {
                return child.value.replace(/^\s+|\s+$/g, "");
              } else if (/\n/.test(child.value)) {
                return "\n";
              }
            }
            return print13(childPath);
          }, "children")).indentTail(options.tabWidth);
          var closingLines = path3.call(print13, closingPropName);
          return (0, lines_1.concat)([openingLines, childLines, closingLines]);
        }
        case "JSXOpeningElement": {
          parts.push("<", path3.call(print13, "name"));
          var attrParts_1 = [];
          path3.each(function(attrPath) {
            attrParts_1.push(" ", print13(attrPath));
          }, "attributes");
          var attrLines = (0, lines_1.concat)(attrParts_1);
          var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;
          if (needLineWrap) {
            attrParts_1.forEach(function(part, i2) {
              if (part === " ") {
                assert_1.default.strictEqual(i2 % 2, 0);
                attrParts_1[i2] = "\n";
              }
            });
            attrLines = (0, lines_1.concat)(attrParts_1).indentTail(options.tabWidth);
          }
          parts.push(attrLines, n.selfClosing ? " />" : ">");
          return (0, lines_1.concat)(parts);
        }
        case "JSXClosingElement":
          return (0, lines_1.concat)(["</", path3.call(print13, "name"), ">"]);
        case "JSXOpeningFragment":
          return (0, lines_1.fromString)("<>");
        case "JSXClosingFragment":
          return (0, lines_1.fromString)("</>");
        case "JSXText":
          return (0, lines_1.fromString)(n.value, options);
        case "JSXEmptyExpression":
          return (0, lines_1.fromString)("");
        case "TypeAnnotatedIdentifier":
          return (0, lines_1.concat)([
            path3.call(print13, "annotation"),
            " ",
            path3.call(print13, "identifier")
          ]);
        case "ClassBody":
          if (n.body.length === 0) {
            return (0, lines_1.fromString)("{}");
          }
          return (0, lines_1.concat)([
            "{\n",
            path3.call(function(bodyPath) {
              return printStatementSequence(bodyPath, options, print13);
            }, "body").indent(options.tabWidth),
            "\n}"
          ]);
        case "ClassPropertyDefinition":
          parts.push("static ", path3.call(print13, "definition"));
          if (!namedTypes.MethodDefinition.check(n.definition))
            parts.push(";");
          return (0, lines_1.concat)(parts);
        case "ClassProperty": {
          if (n.declare) {
            parts.push("declare ");
          }
          var access2 = n.accessibility || n.access;
          if (typeof access2 === "string") {
            parts.push(access2, " ");
          }
          if (n.static) {
            parts.push("static ");
          }
          if (n.abstract) {
            parts.push("abstract ");
          }
          if (n.readonly) {
            parts.push("readonly ");
          }
          var key = path3.call(print13, "key");
          if (n.computed) {
            key = (0, lines_1.concat)(["[", key, "]"]);
          }
          if (n.variance) {
            key = (0, lines_1.concat)([printVariance(path3, print13), key]);
          }
          parts.push(key);
          if (n.optional) {
            parts.push("?");
          }
          if (n.definite) {
            parts.push("!");
          }
          if (n.typeAnnotation) {
            parts.push(path3.call(print13, "typeAnnotation"));
          }
          if (n.value) {
            parts.push(" = ", path3.call(print13, "value"));
          }
          parts.push(";");
          return (0, lines_1.concat)(parts);
        }
        case "ClassPrivateProperty":
          if (n.static) {
            parts.push("static ");
          }
          parts.push(path3.call(print13, "key"));
          if (n.typeAnnotation) {
            parts.push(path3.call(print13, "typeAnnotation"));
          }
          if (n.value) {
            parts.push(" = ", path3.call(print13, "value"));
          }
          parts.push(";");
          return (0, lines_1.concat)(parts);
        case "ClassAccessorProperty": {
          parts.push.apply(parts, tslib_1.__spreadArray(tslib_1.__spreadArray([], printClassMemberModifiers(n), false), ["accessor "], false));
          if (n.computed) {
            parts.push("[", path3.call(print13, "key"), "]");
          } else {
            parts.push(path3.call(print13, "key"));
          }
          if (n.optional) {
            parts.push("?");
          }
          if (n.definite) {
            parts.push("!");
          }
          if (n.typeAnnotation) {
            parts.push(path3.call(print13, "typeAnnotation"));
          }
          if (n.value) {
            parts.push(" = ", path3.call(print13, "value"));
          }
          parts.push(";");
          return (0, lines_1.concat)(parts);
        }
        case "ClassDeclaration":
        case "ClassExpression":
        case "DeclareClass":
          if (n.declare) {
            parts.push("declare ");
          }
          if (n.abstract) {
            parts.push("abstract ");
          }
          parts.push("class");
          if (n.id) {
            parts.push(" ", path3.call(print13, "id"));
          }
          if (n.typeParameters) {
            parts.push(path3.call(print13, "typeParameters"));
          }
          if (n.superClass) {
            parts.push(" extends ", path3.call(print13, "superClass"), path3.call(print13, "superTypeParameters"));
          }
          if (n.extends && n.extends.length > 0) {
            parts.push(" extends ", (0, lines_1.fromString)(", ").join(path3.map(print13, "extends")));
          }
          if (n["implements"] && n["implements"].length > 0) {
            parts.push(" implements ", (0, lines_1.fromString)(", ").join(path3.map(print13, "implements")));
          }
          parts.push(" ", path3.call(print13, "body"));
          if (n.type === "DeclareClass") {
            return printFlowDeclaration(path3, parts);
          } else {
            return (0, lines_1.concat)(parts);
          }
        case "TemplateElement":
          return (0, lines_1.fromString)(n.value.raw, options).lockIndentTail();
        case "TemplateLiteral": {
          var expressions_1 = path3.map(print13, "expressions");
          parts.push("`");
          path3.each(function(childPath) {
            var i2 = childPath.getName();
            parts.push(print13(childPath));
            if (i2 < expressions_1.length) {
              parts.push("${", expressions_1[i2], "}");
            }
          }, "quasis");
          parts.push("`");
          return (0, lines_1.concat)(parts).lockIndentTail();
        }
        case "TaggedTemplateExpression":
          return (0, lines_1.concat)([path3.call(print13, "tag"), path3.call(print13, "quasi")]);
        case "Node":
        case "Printable":
        case "SourceLocation":
        case "Position":
        case "Statement":
        case "Function":
        case "Pattern":
        case "Expression":
        case "Declaration":
        case "Specifier":
        case "NamedSpecifier":
        case "Comment":
        case "Flow":
        case "FlowType":
        case "FlowPredicate":
        case "MemberTypeAnnotation":
        case "Type":
        case "TSHasOptionalTypeParameterInstantiation":
        case "TSHasOptionalTypeParameters":
        case "TSHasOptionalTypeAnnotation":
        case "ChainElement":
          throw new Error("unprintable type: " + JSON.stringify(n.type));
        case "CommentBlock":
        case "Block":
          return (0, lines_1.concat)(["/*", (0, lines_1.fromString)(n.value, options), "*/"]);
        case "CommentLine":
        case "Line":
          return (0, lines_1.concat)(["//", (0, lines_1.fromString)(n.value, options)]);
        case "TypeAnnotation":
          if (n.typeAnnotation) {
            if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
              parts.push(": ");
            }
            parts.push(path3.call(print13, "typeAnnotation"));
            return (0, lines_1.concat)(parts);
          }
          return (0, lines_1.fromString)("");
        case "ExistentialTypeParam":
        case "ExistsTypeAnnotation":
          return (0, lines_1.fromString)("*", options);
        case "EmptyTypeAnnotation":
          return (0, lines_1.fromString)("empty", options);
        case "AnyTypeAnnotation":
          return (0, lines_1.fromString)("any", options);
        case "MixedTypeAnnotation":
          return (0, lines_1.fromString)("mixed", options);
        case "ArrayTypeAnnotation":
          return (0, lines_1.concat)([path3.call(print13, "elementType"), "[]"]);
        case "TupleTypeAnnotation": {
          var printed_2 = path3.map(print13, "types");
          var joined = (0, lines_1.fromString)(", ").join(printed_2);
          var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;
          if (oneLine_3) {
            if (options.arrayBracketSpacing) {
              parts.push("[ ");
            } else {
              parts.push("[");
            }
          } else {
            parts.push("[\n");
          }
          path3.each(function(elemPath) {
            var i2 = elemPath.getName();
            var elem = elemPath.getValue();
            if (!elem) {
              parts.push(",");
            } else {
              var lines2 = printed_2[i2];
              if (oneLine_3) {
                if (i2 > 0)
                  parts.push(" ");
              } else {
                lines2 = lines2.indent(options.tabWidth);
              }
              parts.push(lines2);
              if (i2 < n.types.length - 1 || !oneLine_3 && util.isTrailingCommaEnabled(options, "arrays"))
                parts.push(",");
              if (!oneLine_3)
                parts.push("\n");
            }
          }, "types");
          if (oneLine_3 && options.arrayBracketSpacing) {
            parts.push(" ]");
          } else {
            parts.push("]");
          }
          return (0, lines_1.concat)(parts);
        }
        case "BooleanTypeAnnotation":
          return (0, lines_1.fromString)("boolean", options);
        case "BooleanLiteralTypeAnnotation":
          assert_1.default.strictEqual(typeof n.value, "boolean");
          return (0, lines_1.fromString)("" + n.value, options);
        case "InterfaceTypeAnnotation":
          parts.push("interface");
          if (n.extends && n.extends.length > 0) {
            parts.push(" extends ", (0, lines_1.fromString)(", ").join(path3.map(print13, "extends")));
          }
          parts.push(" ", path3.call(print13, "body"));
          return (0, lines_1.concat)(parts);
        case "DeclareFunction":
          return printFlowDeclaration(path3, [
            "function ",
            path3.call(print13, "id"),
            ";"
          ]);
        case "DeclareModule":
          return printFlowDeclaration(path3, [
            "module ",
            path3.call(print13, "id"),
            " ",
            path3.call(print13, "body")
          ]);
        case "DeclareModuleExports":
          return printFlowDeclaration(path3, [
            "module.exports",
            path3.call(print13, "typeAnnotation")
          ]);
        case "DeclareVariable":
          return printFlowDeclaration(path3, ["var ", path3.call(print13, "id"), ";"]);
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
          return (0, lines_1.concat)(["declare ", printExportDeclaration(path3, options, print13)]);
        case "EnumDeclaration":
          return (0, lines_1.concat)([
            "enum ",
            path3.call(print13, "id"),
            path3.call(print13, "body")
          ]);
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody": {
          if (n.type === "EnumSymbolBody" || n.explicitType) {
            parts.push(
              " of ",
              n.type.slice(4, -4).toLowerCase()
            );
          }
          parts.push(" {\n", (0, lines_1.fromString)("\n").join(path3.map(print13, "members")).indent(options.tabWidth), "\n}");
          return (0, lines_1.concat)(parts);
        }
        case "EnumDefaultedMember":
          return (0, lines_1.concat)([path3.call(print13, "id"), ","]);
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
          return (0, lines_1.concat)([
            path3.call(print13, "id"),
            " = ",
            path3.call(print13, "init"),
            ","
          ]);
        case "InferredPredicate":
          return (0, lines_1.fromString)("%checks", options);
        case "DeclaredPredicate":
          return (0, lines_1.concat)(["%checks(", path3.call(print13, "value"), ")"]);
        case "FunctionTypeAnnotation": {
          var parent2 = path3.getParentNode(0);
          var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent2) || namedTypes.ObjectTypeInternalSlot.check(parent2) && parent2.method || namedTypes.DeclareFunction.check(path3.getParentNode(2)));
          var needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent2) && !namedTypes.TypeAlias.check(parent2);
          if (needsColon) {
            parts.push(": ");
          }
          var hasTypeParameters = !!n.typeParameters;
          var needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;
          parts.push(hasTypeParameters ? path3.call(print13, "typeParameters") : "", needsParens ? "(" : "", printFunctionParams(path3, options, print13), needsParens ? ")" : "");
          if (n.returnType) {
            parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path3.call(print13, "returnType"));
          }
          return (0, lines_1.concat)(parts);
        }
        case "FunctionTypeParam": {
          var name = path3.call(print13, "name");
          parts.push(name);
          if (n.optional) {
            parts.push("?");
          }
          if (name.infos[0].line) {
            parts.push(": ");
          }
          parts.push(path3.call(print13, "typeAnnotation"));
          return (0, lines_1.concat)(parts);
        }
        case "GenericTypeAnnotation":
          return (0, lines_1.concat)([
            path3.call(print13, "id"),
            path3.call(print13, "typeParameters")
          ]);
        case "DeclareInterface":
          parts.push("declare ");
        case "InterfaceDeclaration":
        case "TSInterfaceDeclaration":
          if (n.declare) {
            parts.push("declare ");
          }
          parts.push("interface ", path3.call(print13, "id"), path3.call(print13, "typeParameters"), " ");
          if (n["extends"] && n["extends"].length > 0) {
            parts.push("extends ", (0, lines_1.fromString)(", ").join(path3.map(print13, "extends")), " ");
          }
          if (n.body) {
            parts.push(path3.call(print13, "body"));
          }
          return (0, lines_1.concat)(parts);
        case "ClassImplements":
        case "InterfaceExtends":
          return (0, lines_1.concat)([
            path3.call(print13, "id"),
            path3.call(print13, "typeParameters")
          ]);
        case "IntersectionTypeAnnotation":
          return (0, lines_1.fromString)(" & ").join(path3.map(print13, "types"));
        case "NullableTypeAnnotation":
          return (0, lines_1.concat)(["?", path3.call(print13, "typeAnnotation")]);
        case "NullLiteralTypeAnnotation":
          return (0, lines_1.fromString)("null", options);
        case "ThisTypeAnnotation":
          return (0, lines_1.fromString)("this", options);
        case "NumberTypeAnnotation":
          return (0, lines_1.fromString)("number", options);
        case "ObjectTypeCallProperty":
          return path3.call(print13, "value");
        case "ObjectTypeIndexer":
          if (n.static) {
            parts.push("static ");
          }
          parts.push(printVariance(path3, print13), "[");
          if (n.id) {
            parts.push(path3.call(print13, "id"), ": ");
          }
          parts.push(path3.call(print13, "key"), "]: ", path3.call(print13, "value"));
          return (0, lines_1.concat)(parts);
        case "ObjectTypeProperty":
          return (0, lines_1.concat)([
            printVariance(path3, print13),
            path3.call(print13, "key"),
            n.optional ? "?" : "",
            ": ",
            path3.call(print13, "value")
          ]);
        case "ObjectTypeInternalSlot":
          return (0, lines_1.concat)([
            n.static ? "static " : "",
            "[[",
            path3.call(print13, "id"),
            "]]",
            n.optional ? "?" : "",
            n.value.type !== "FunctionTypeAnnotation" ? ": " : "",
            path3.call(print13, "value")
          ]);
        case "QualifiedTypeIdentifier":
          return (0, lines_1.concat)([
            path3.call(print13, "qualification"),
            ".",
            path3.call(print13, "id")
          ]);
        case "StringLiteralTypeAnnotation":
          return (0, lines_1.fromString)(nodeStr(n.value, options), options);
        case "NumberLiteralTypeAnnotation":
        case "NumericLiteralTypeAnnotation":
          assert_1.default.strictEqual(typeof n.value, "number");
          return (0, lines_1.fromString)(JSON.stringify(n.value), options);
        case "BigIntLiteralTypeAnnotation":
          return (0, lines_1.fromString)(n.raw, options);
        case "StringTypeAnnotation":
          return (0, lines_1.fromString)("string", options);
        case "DeclareTypeAlias":
          parts.push("declare ");
        case "TypeAlias":
          return (0, lines_1.concat)([
            "type ",
            path3.call(print13, "id"),
            path3.call(print13, "typeParameters"),
            " = ",
            path3.call(print13, "right"),
            ";"
          ]);
        case "DeclareOpaqueType":
          parts.push("declare ");
        case "OpaqueType":
          parts.push("opaque type ", path3.call(print13, "id"), path3.call(print13, "typeParameters"));
          if (n["supertype"]) {
            parts.push(": ", path3.call(print13, "supertype"));
          }
          if (n["impltype"]) {
            parts.push(" = ", path3.call(print13, "impltype"));
          }
          parts.push(";");
          return (0, lines_1.concat)(parts);
        case "TypeCastExpression":
          return (0, lines_1.concat)([
            "(",
            path3.call(print13, "expression"),
            path3.call(print13, "typeAnnotation"),
            ")"
          ]);
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
          return (0, lines_1.concat)([
            "<",
            (0, lines_1.fromString)(", ").join(path3.map(print13, "params")),
            ">"
          ]);
        case "Variance":
          if (n.kind === "plus") {
            return (0, lines_1.fromString)("+");
          }
          if (n.kind === "minus") {
            return (0, lines_1.fromString)("-");
          }
          return (0, lines_1.fromString)("");
        case "TypeParameter":
          if (n.variance) {
            parts.push(printVariance(path3, print13));
          }
          parts.push(path3.call(print13, "name"));
          if (n.bound) {
            parts.push(path3.call(print13, "bound"));
          }
          if (n["default"]) {
            parts.push("=", path3.call(print13, "default"));
          }
          return (0, lines_1.concat)(parts);
        case "TypeofTypeAnnotation":
          return (0, lines_1.concat)([
            (0, lines_1.fromString)("typeof ", options),
            path3.call(print13, "argument")
          ]);
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          return (0, lines_1.concat)([
            path3.call(print13, "objectType"),
            n.optional ? "?." : "",
            "[",
            path3.call(print13, "indexType"),
            "]"
          ]);
        case "UnionTypeAnnotation":
          return (0, lines_1.fromString)(" | ").join(path3.map(print13, "types"));
        case "VoidTypeAnnotation":
          return (0, lines_1.fromString)("void", options);
        case "NullTypeAnnotation":
          return (0, lines_1.fromString)("null", options);
        case "SymbolTypeAnnotation":
          return (0, lines_1.fromString)("symbol", options);
        case "BigIntTypeAnnotation":
          return (0, lines_1.fromString)("bigint", options);
        case "TSType":
          throw new Error("unprintable type: " + JSON.stringify(n.type));
        case "TSNumberKeyword":
          return (0, lines_1.fromString)("number", options);
        case "TSBigIntKeyword":
          return (0, lines_1.fromString)("bigint", options);
        case "TSObjectKeyword":
          return (0, lines_1.fromString)("object", options);
        case "TSBooleanKeyword":
          return (0, lines_1.fromString)("boolean", options);
        case "TSStringKeyword":
          return (0, lines_1.fromString)("string", options);
        case "TSSymbolKeyword":
          return (0, lines_1.fromString)("symbol", options);
        case "TSAnyKeyword":
          return (0, lines_1.fromString)("any", options);
        case "TSVoidKeyword":
          return (0, lines_1.fromString)("void", options);
        case "TSIntrinsicKeyword":
          return (0, lines_1.fromString)("intrinsic", options);
        case "TSThisType":
          return (0, lines_1.fromString)("this", options);
        case "TSNullKeyword":
          return (0, lines_1.fromString)("null", options);
        case "TSUndefinedKeyword":
          return (0, lines_1.fromString)("undefined", options);
        case "TSUnknownKeyword":
          return (0, lines_1.fromString)("unknown", options);
        case "TSNeverKeyword":
          return (0, lines_1.fromString)("never", options);
        case "TSArrayType":
          return (0, lines_1.concat)([path3.call(print13, "elementType"), "[]"]);
        case "TSLiteralType":
          return path3.call(print13, "literal");
        case "TSUnionType":
          return (0, lines_1.fromString)(" | ").join(path3.map(print13, "types"));
        case "TSIntersectionType":
          return (0, lines_1.fromString)(" & ").join(path3.map(print13, "types"));
        case "TSConditionalType":
          parts.push(path3.call(print13, "checkType"), " extends ", path3.call(print13, "extendsType"), " ? ", path3.call(print13, "trueType"), " : ", path3.call(print13, "falseType"));
          return (0, lines_1.concat)(parts);
        case "TSInferType":
          parts.push("infer ", path3.call(print13, "typeParameter"));
          return (0, lines_1.concat)(parts);
        case "TSParenthesizedType":
          return (0, lines_1.concat)(["(", path3.call(print13, "typeAnnotation"), ")"]);
        case "TSFunctionType":
          return (0, lines_1.concat)([
            path3.call(print13, "typeParameters"),
            "(",
            printFunctionParams(path3, options, print13),
            ") => ",
            path3.call(print13, "typeAnnotation", "typeAnnotation")
          ]);
        case "TSConstructorType":
          return (0, lines_1.concat)([
            "new ",
            path3.call(print13, "typeParameters"),
            "(",
            printFunctionParams(path3, options, print13),
            ") => ",
            path3.call(print13, "typeAnnotation", "typeAnnotation")
          ]);
        case "TSMappedType": {
          parts.push(n.readonly ? "readonly " : "", "[", path3.call(print13, "typeParameter"), "]", n.optional ? "?" : "");
          if (n.typeAnnotation) {
            parts.push(": ", path3.call(print13, "typeAnnotation"), ";");
          }
          return (0, lines_1.concat)(["{\n", (0, lines_1.concat)(parts).indent(options.tabWidth), "\n}"]);
        }
        case "TSTupleType":
          return (0, lines_1.concat)([
            "[",
            (0, lines_1.fromString)(", ").join(path3.map(print13, "elementTypes")),
            "]"
          ]);
        case "TSNamedTupleMember":
          parts.push(path3.call(print13, "label"));
          if (n.optional) {
            parts.push("?");
          }
          parts.push(": ", path3.call(print13, "elementType"));
          return (0, lines_1.concat)(parts);
        case "TSRestType":
          return (0, lines_1.concat)(["...", path3.call(print13, "typeAnnotation")]);
        case "TSOptionalType":
          return (0, lines_1.concat)([path3.call(print13, "typeAnnotation"), "?"]);
        case "TSIndexedAccessType":
          return (0, lines_1.concat)([
            path3.call(print13, "objectType"),
            "[",
            path3.call(print13, "indexType"),
            "]"
          ]);
        case "TSTypeOperator":
          return (0, lines_1.concat)([
            path3.call(print13, "operator"),
            " ",
            path3.call(print13, "typeAnnotation")
          ]);
        case "TSTypeLiteral": {
          var members = (0, lines_1.fromString)("\n").join(path3.map(print13, "members").map(function(member) {
            if (lastNonSpaceCharacter(member) !== ";") {
              return member.concat(";");
            }
            return member;
          }));
          if (members.isEmpty()) {
            return (0, lines_1.fromString)("{}", options);
          }
          parts.push("{\n", members.indent(options.tabWidth), "\n}");
          return (0, lines_1.concat)(parts);
        }
        case "TSEnumMember":
          parts.push(path3.call(print13, "id"));
          if (n.initializer) {
            parts.push(" = ", path3.call(print13, "initializer"));
          }
          return (0, lines_1.concat)(parts);
        case "TSTypeQuery":
          return (0, lines_1.concat)(["typeof ", path3.call(print13, "exprName")]);
        case "TSParameterProperty":
          if (n.accessibility) {
            parts.push(n.accessibility, " ");
          }
          if (n.export) {
            parts.push("export ");
          }
          if (n.static) {
            parts.push("static ");
          }
          if (n.readonly) {
            parts.push("readonly ");
          }
          parts.push(path3.call(print13, "parameter"));
          return (0, lines_1.concat)(parts);
        case "TSTypeReference":
          return (0, lines_1.concat)([
            path3.call(print13, "typeName"),
            path3.call(print13, "typeParameters")
          ]);
        case "TSQualifiedName":
          return (0, lines_1.concat)([path3.call(print13, "left"), ".", path3.call(print13, "right")]);
        case "TSAsExpression":
        case "TSSatisfiesExpression": {
          var expression = path3.call(print13, "expression");
          parts.push(expression, n.type === "TSSatisfiesExpression" ? " satisfies " : " as ", path3.call(print13, "typeAnnotation"));
          return (0, lines_1.concat)(parts);
        }
        case "TSTypeCastExpression":
          return (0, lines_1.concat)([
            path3.call(print13, "expression"),
            path3.call(print13, "typeAnnotation")
          ]);
        case "TSNonNullExpression":
          return (0, lines_1.concat)([path3.call(print13, "expression"), "!"]);
        case "TSTypeAnnotation":
          return (0, lines_1.concat)([": ", path3.call(print13, "typeAnnotation")]);
        case "TSIndexSignature":
          return (0, lines_1.concat)([
            n.readonly ? "readonly " : "",
            "[",
            path3.map(print13, "parameters"),
            "]",
            path3.call(print13, "typeAnnotation")
          ]);
        case "TSPropertySignature":
          parts.push(printVariance(path3, print13), n.readonly ? "readonly " : "");
          if (n.computed) {
            parts.push("[", path3.call(print13, "key"), "]");
          } else {
            parts.push(path3.call(print13, "key"));
          }
          parts.push(n.optional ? "?" : "", path3.call(print13, "typeAnnotation"));
          return (0, lines_1.concat)(parts);
        case "TSMethodSignature":
          if (n.computed) {
            parts.push("[", path3.call(print13, "key"), "]");
          } else {
            parts.push(path3.call(print13, "key"));
          }
          if (n.optional) {
            parts.push("?");
          }
          parts.push(path3.call(print13, "typeParameters"), "(", printFunctionParams(path3, options, print13), ")", path3.call(print13, "typeAnnotation"));
          return (0, lines_1.concat)(parts);
        case "TSTypePredicate":
          if (n.asserts) {
            parts.push("asserts ");
          }
          parts.push(path3.call(print13, "parameterName"));
          if (n.typeAnnotation) {
            parts.push(" is ", path3.call(print13, "typeAnnotation", "typeAnnotation"));
          }
          return (0, lines_1.concat)(parts);
        case "TSCallSignatureDeclaration":
          return (0, lines_1.concat)([
            path3.call(print13, "typeParameters"),
            "(",
            printFunctionParams(path3, options, print13),
            ")",
            path3.call(print13, "typeAnnotation")
          ]);
        case "TSConstructSignatureDeclaration":
          if (n.typeParameters) {
            parts.push("new", path3.call(print13, "typeParameters"));
          } else {
            parts.push("new ");
          }
          parts.push("(", printFunctionParams(path3, options, print13), ")", path3.call(print13, "typeAnnotation"));
          return (0, lines_1.concat)(parts);
        case "TSTypeAliasDeclaration":
          return (0, lines_1.concat)([
            n.declare ? "declare " : "",
            "type ",
            path3.call(print13, "id"),
            path3.call(print13, "typeParameters"),
            " = ",
            path3.call(print13, "typeAnnotation"),
            ";"
          ]);
        case "TSTypeParameter": {
          parts.push(path3.call(print13, "name"));
          var parent2 = path3.getParentNode(0);
          var isInMappedType = namedTypes.TSMappedType.check(parent2);
          if (n.constraint) {
            parts.push(isInMappedType ? " in " : " extends ", path3.call(print13, "constraint"));
          }
          if (n["default"]) {
            parts.push(" = ", path3.call(print13, "default"));
          }
          return (0, lines_1.concat)(parts);
        }
        case "TSTypeAssertion": {
          parts.push("<", path3.call(print13, "typeAnnotation"), "> ", path3.call(print13, "expression"));
          return (0, lines_1.concat)(parts);
        }
        case "TSTypeParameterDeclaration":
        case "TSTypeParameterInstantiation":
          return (0, lines_1.concat)([
            "<",
            (0, lines_1.fromString)(", ").join(path3.map(print13, "params")),
            ">"
          ]);
        case "TSEnumDeclaration": {
          parts.push(n.declare ? "declare " : "", n.const ? "const " : "", "enum ", path3.call(print13, "id"));
          var memberLines = (0, lines_1.fromString)(",\n").join(path3.map(print13, "members"));
          if (memberLines.isEmpty()) {
            parts.push(" {}");
          } else {
            parts.push(" {\n", memberLines.indent(options.tabWidth), "\n}");
          }
          return (0, lines_1.concat)(parts);
        }
        case "TSExpressionWithTypeArguments":
          return (0, lines_1.concat)([
            path3.call(print13, "expression"),
            path3.call(print13, "typeParameters")
          ]);
        case "TSInterfaceBody": {
          var lines = (0, lines_1.fromString)("\n").join(path3.map(print13, "body").map(function(element) {
            if (lastNonSpaceCharacter(element) !== ";") {
              return element.concat(";");
            }
            return element;
          }));
          if (lines.isEmpty()) {
            return (0, lines_1.fromString)("{}", options);
          }
          return (0, lines_1.concat)(["{\n", lines.indent(options.tabWidth), "\n}"]);
        }
        case "TSImportType":
          parts.push("import(", path3.call(print13, "argument"), ")");
          if (n.qualifier) {
            parts.push(".", path3.call(print13, "qualifier"));
          }
          if (n.typeParameters) {
            parts.push(path3.call(print13, "typeParameters"));
          }
          return (0, lines_1.concat)(parts);
        case "TSImportEqualsDeclaration":
          if (n.isExport) {
            parts.push("export ");
          }
          parts.push("import ", path3.call(print13, "id"), " = ", path3.call(print13, "moduleReference"));
          return maybeAddSemicolon((0, lines_1.concat)(parts));
        case "TSExternalModuleReference":
          return (0, lines_1.concat)(["require(", path3.call(print13, "expression"), ")"]);
        case "TSModuleDeclaration": {
          var parent2 = path3.getParentNode();
          if (parent2.type === "TSModuleDeclaration") {
            parts.push(".");
          } else {
            if (n.declare) {
              parts.push("declare ");
            }
            if (!n.global) {
              var isExternal = n.id.type === "StringLiteral" || n.id.type === "Literal" && typeof n.id.value === "string";
              if (isExternal) {
                parts.push("module ");
              } else if (n.loc && n.loc.lines && n.id.loc) {
                var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);
                if (prefix.indexOf("module") >= 0) {
                  parts.push("module ");
                } else {
                  parts.push("namespace ");
                }
              } else {
                parts.push("namespace ");
              }
            }
          }
          parts.push(path3.call(print13, "id"));
          if (n.body) {
            parts.push(" ");
            parts.push(path3.call(print13, "body"));
          }
          return (0, lines_1.concat)(parts);
        }
        case "TSModuleBlock": {
          var naked = path3.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print13);
          }, "body");
          if (naked.isEmpty()) {
            parts.push("{}");
          } else {
            parts.push("{\n", naked.indent(options.tabWidth), "\n}");
          }
          return (0, lines_1.concat)(parts);
        }
        case "TSInstantiationExpression": {
          parts.push(path3.call(print13, "expression"), path3.call(print13, "typeParameters"));
          return (0, lines_1.concat)(parts);
        }
        case "V8IntrinsicIdentifier":
          return (0, lines_1.concat)(["%", path3.call(print13, "name")]);
        case "TopicReference":
          return (0, lines_1.fromString)("#");
        case "ClassHeritage":
        case "ComprehensionBlock":
        case "ComprehensionExpression":
        case "Glob":
        case "GeneratorExpression":
        case "LetStatement":
        case "LetExpression":
        case "GraphExpression":
        case "GraphIndexExpression":
        case "XMLDefaultDeclaration":
        case "XMLAnyName":
        case "XMLQualifiedIdentifier":
        case "XMLFunctionQualifiedIdentifier":
        case "XMLAttributeSelector":
        case "XMLFilterExpression":
        case "XML":
        case "XMLElement":
        case "XMLList":
        case "XMLEscape":
        case "XMLText":
        case "XMLStartTag":
        case "XMLEndTag":
        case "XMLPointTag":
        case "XMLName":
        case "XMLAttribute":
        case "XMLCdata":
        case "XMLComment":
        case "XMLProcessingInstruction":
        default:
          debugger;
          throw new Error("unknown type: " + JSON.stringify(n.type));
      }
    }
    function printDecorators(path3, printPath) {
      var parts = [];
      var node = path3.getValue();
      if (node.decorators && node.decorators.length > 0 && !util.getParentExportDeclaration(path3)) {
        path3.each(function(decoratorPath) {
          parts.push(printPath(decoratorPath), "\n");
        }, "decorators");
      } else if (util.isExportDeclaration(node) && node.declaration && node.declaration.decorators) {
        path3.each(function(decoratorPath) {
          parts.push(printPath(decoratorPath), "\n");
        }, "declaration", "decorators");
      }
      return (0, lines_1.concat)(parts);
    }
    function printStatementSequence(path3, options, print13) {
      var filtered = [];
      var sawComment = false;
      var sawStatement = false;
      path3.each(function(stmtPath) {
        var stmt = stmtPath.getValue();
        if (!stmt) {
          return;
        }
        if (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0)) {
          return;
        }
        if (namedTypes.Comment.check(stmt)) {
          sawComment = true;
        } else if (namedTypes.Statement.check(stmt)) {
          sawStatement = true;
        } else {
          isString.assert(stmt);
        }
        filtered.push({
          node: stmt,
          printed: print13(stmtPath)
        });
      });
      if (sawComment) {
        assert_1.default.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
      }
      var prevTrailingSpace = null;
      var len = filtered.length;
      var parts = [];
      filtered.forEach(function(info, i2) {
        var printed = info.printed;
        var stmt = info.node;
        var multiLine = printed.length > 1;
        var notFirst = i2 > 0;
        var notLast = i2 < len - 1;
        var leadingSpace;
        var trailingSpace;
        var lines = stmt && stmt.loc && stmt.loc.lines;
        var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);
        if (notFirst) {
          if (trueLoc) {
            var beforeStart = lines.skipSpaces(trueLoc.start, true);
            var beforeStartLine = beforeStart ? beforeStart.line : 1;
            var leadingGap = trueLoc.start.line - beforeStartLine;
            leadingSpace = Array(leadingGap + 1).join("\n");
          } else {
            leadingSpace = multiLine ? "\n\n" : "\n";
          }
        } else {
          leadingSpace = "";
        }
        if (notLast) {
          if (trueLoc) {
            var afterEnd = lines.skipSpaces(trueLoc.end);
            var afterEndLine = afterEnd ? afterEnd.line : lines.length;
            var trailingGap = afterEndLine - trueLoc.end.line;
            trailingSpace = Array(trailingGap + 1).join("\n");
          } else {
            trailingSpace = multiLine ? "\n\n" : "\n";
          }
        } else {
          trailingSpace = "";
        }
        parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
        if (notLast) {
          prevTrailingSpace = trailingSpace;
        } else if (trailingSpace) {
          parts.push(trailingSpace);
        }
      });
      return (0, lines_1.concat)(parts);
    }
    function maxSpace(s1, s2) {
      if (!s1 && !s2) {
        return (0, lines_1.fromString)("");
      }
      if (!s1) {
        return (0, lines_1.fromString)(s2);
      }
      if (!s2) {
        return (0, lines_1.fromString)(s1);
      }
      var spaceLines1 = (0, lines_1.fromString)(s1);
      var spaceLines2 = (0, lines_1.fromString)(s2);
      if (spaceLines2.length > spaceLines1.length) {
        return spaceLines2;
      }
      return spaceLines1;
    }
    function printClassMemberModifiers(node) {
      var parts = [];
      if (node.declare) {
        parts.push("declare ");
      }
      var access2 = node.accessibility || node.access;
      if (typeof access2 === "string") {
        parts.push(access2, " ");
      }
      if (node.static) {
        parts.push("static ");
      }
      if (node.override) {
        parts.push("override ");
      }
      if (node.abstract) {
        parts.push("abstract ");
      }
      if (node.readonly) {
        parts.push("readonly ");
      }
      return parts;
    }
    function printMethod(path3, options, print13) {
      var node = path3.getNode();
      var kind = node.kind;
      var parts = [];
      var nodeValue = node.value;
      if (!namedTypes.FunctionExpression.check(nodeValue)) {
        nodeValue = node;
      }
      parts.push.apply(parts, printClassMemberModifiers(node));
      if (nodeValue.async) {
        parts.push("async ");
      }
      if (nodeValue.generator) {
        parts.push("*");
      }
      if (kind === "get" || kind === "set") {
        parts.push(kind, " ");
      }
      var key = path3.call(print13, "key");
      if (node.computed) {
        key = (0, lines_1.concat)(["[", key, "]"]);
      }
      parts.push(key);
      if (node.optional) {
        parts.push("?");
      }
      if (node === nodeValue) {
        parts.push(path3.call(print13, "typeParameters"), "(", printFunctionParams(path3, options, print13), ")", path3.call(print13, "returnType"));
        if (node.body) {
          parts.push(" ", path3.call(print13, "body"));
        } else {
          parts.push(";");
        }
      } else {
        parts.push(path3.call(print13, "value", "typeParameters"), "(", path3.call(function(valuePath) {
          return printFunctionParams(valuePath, options, print13);
        }, "value"), ")", path3.call(print13, "value", "returnType"));
        if (nodeValue.body) {
          parts.push(" ", path3.call(print13, "value", "body"));
        } else {
          parts.push(";");
        }
      }
      return (0, lines_1.concat)(parts);
    }
    function printArgumentsList(path3, options, print13) {
      var printed = path3.map(print13, "arguments");
      var trailingComma = util.isTrailingCommaEnabled(options, "parameters");
      var joined = (0, lines_1.fromString)(", ").join(printed);
      if (joined.getLineLength(1) > options.wrapColumn) {
        joined = (0, lines_1.fromString)(",\n").join(printed);
        return (0, lines_1.concat)([
          "(\n",
          joined.indent(options.tabWidth),
          trailingComma ? ",\n)" : "\n)"
        ]);
      }
      return (0, lines_1.concat)(["(", joined, ")"]);
    }
    function printFunctionParams(path3, options, print13) {
      var fun = path3.getValue();
      var params;
      var printed = [];
      if (fun.params) {
        params = fun.params;
        printed = path3.map(print13, "params");
      } else if (fun.parameters) {
        params = fun.parameters;
        printed = path3.map(print13, "parameters");
      }
      if (fun.defaults) {
        path3.each(function(defExprPath) {
          var i2 = defExprPath.getName();
          var p3 = printed[i2];
          if (p3 && defExprPath.getValue()) {
            printed[i2] = (0, lines_1.concat)([p3, " = ", print13(defExprPath)]);
          }
        }, "defaults");
      }
      if (fun.rest) {
        printed.push((0, lines_1.concat)(["...", path3.call(print13, "rest")]));
      }
      var joined = (0, lines_1.fromString)(", ").join(printed);
      if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
        joined = (0, lines_1.fromString)(",\n").join(printed);
        if (util.isTrailingCommaEnabled(options, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement") {
          joined = (0, lines_1.concat)([joined, ",\n"]);
        } else {
          joined = (0, lines_1.concat)([joined, "\n"]);
        }
        return (0, lines_1.concat)(["\n", joined.indent(options.tabWidth)]);
      }
      return joined;
    }
    function maybePrintImportAssertions(path3, options, print13) {
      var n = path3.getValue();
      if (n.assertions && n.assertions.length > 0) {
        var parts = [" assert {"];
        var printed = path3.map(print13, "assertions");
        var flat = (0, lines_1.fromString)(", ").join(printed);
        if (flat.length > 1 || flat.getLineLength(1) > options.wrapColumn) {
          parts.push("\n", (0, lines_1.fromString)(",\n").join(printed).indent(options.tabWidth), "\n}");
        } else {
          parts.push(" ", flat, " }");
        }
        return (0, lines_1.concat)(parts);
      }
      return (0, lines_1.fromString)("");
    }
    function printExportDeclaration(path3, options, print13) {
      var decl = path3.getValue();
      var parts = ["export "];
      if (decl.exportKind && decl.exportKind === "type") {
        if (!decl.declaration) {
          parts.push("type ");
        }
      }
      var shouldPrintSpaces = options.objectCurlySpacing;
      namedTypes.Declaration.assert(decl);
      if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
        parts.push("default ");
      }
      if (decl.declaration) {
        parts.push(path3.call(print13, "declaration"));
      } else if (decl.specifiers) {
        if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier") {
          parts.push("*");
        } else if (decl.specifiers.length === 0) {
          parts.push("{}");
        } else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
          var unbracedSpecifiers_2 = [];
          var bracedSpecifiers_2 = [];
          path3.each(function(specifierPath) {
            var spec = specifierPath.getValue();
            if (spec.type === "ExportDefaultSpecifier") {
              unbracedSpecifiers_2.push(print13(specifierPath));
            } else {
              bracedSpecifiers_2.push(print13(specifierPath));
            }
          }, "specifiers");
          unbracedSpecifiers_2.forEach(function(lines2, i2) {
            if (i2 > 0) {
              parts.push(", ");
            }
            parts.push(lines2);
          });
          if (bracedSpecifiers_2.length > 0) {
            var lines_2 = (0, lines_1.fromString)(", ").join(bracedSpecifiers_2);
            if (lines_2.getLineLength(1) > options.wrapColumn) {
              lines_2 = (0, lines_1.concat)([
                (0, lines_1.fromString)(",\n").join(bracedSpecifiers_2).indent(options.tabWidth),
                ","
              ]);
            }
            if (unbracedSpecifiers_2.length > 0) {
              parts.push(", ");
            }
            if (lines_2.length > 1) {
              parts.push("{\n", lines_2, "\n}");
            } else if (options.objectCurlySpacing) {
              parts.push("{ ", lines_2, " }");
            } else {
              parts.push("{", lines_2, "}");
            }
          }
        } else {
          parts.push(shouldPrintSpaces ? "{ " : "{", (0, lines_1.fromString)(", ").join(path3.map(print13, "specifiers")), shouldPrintSpaces ? " }" : "}");
        }
        if (decl.source) {
          parts.push(" from ", path3.call(print13, "source"), maybePrintImportAssertions(path3, options, print13));
        }
      }
      var lines = (0, lines_1.concat)(parts);
      if (lastNonSpaceCharacter(lines) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration"))) {
        lines = (0, lines_1.concat)([lines, ";"]);
      }
      return lines;
    }
    function printFlowDeclaration(path3, parts) {
      var parentExportDecl = util.getParentExportDeclaration(path3);
      if (parentExportDecl) {
        assert_1.default.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
      } else {
        parts.unshift("declare ");
      }
      return (0, lines_1.concat)(parts);
    }
    function printVariance(path3, print13) {
      return path3.call(function(variancePath) {
        var value = variancePath.getValue();
        if (value) {
          if (value === "plus") {
            return (0, lines_1.fromString)("+");
          }
          if (value === "minus") {
            return (0, lines_1.fromString)("-");
          }
          return print13(variancePath);
        }
        return (0, lines_1.fromString)("");
      }, "variance");
    }
    function adjustClause(clause, options) {
      if (clause.length > 1)
        return (0, lines_1.concat)([" ", clause]);
      return (0, lines_1.concat)(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
    }
    function lastNonSpaceCharacter(lines) {
      var pos = lines.lastPos();
      do {
        var ch = lines.charAt(pos);
        if (/\S/.test(ch))
          return ch;
      } while (lines.prevPos(pos));
    }
    function endsWithBrace(lines) {
      return lastNonSpaceCharacter(lines) === "}";
    }
    function swapQuotes(str) {
      return str.replace(/['"]/g, function(m3) {
        return m3 === '"' ? "'" : '"';
      });
    }
    function getPossibleRaw(node) {
      var value = types17.getFieldValue(node, "value");
      var extra = types17.getFieldValue(node, "extra");
      if (extra && typeof extra.raw === "string" && value == extra.rawValue) {
        return extra.raw;
      }
      if (node.type === "Literal") {
        var raw = node.raw;
        if (typeof raw === "string" && value == raw) {
          return raw;
        }
      }
    }
    function jsSafeStringify(str) {
      return JSON.stringify(str).replace(/[\u2028\u2029]/g, function(m3) {
        return "\\u" + m3.charCodeAt(0).toString(16);
      });
    }
    function nodeStr(str, options) {
      isString.assert(str);
      switch (options.quote) {
        case "auto": {
          var double = jsSafeStringify(str);
          var single = swapQuotes(jsSafeStringify(swapQuotes(str)));
          return double.length > single.length ? single : double;
        }
        case "single":
          return swapQuotes(jsSafeStringify(swapQuotes(str)));
        case "double":
        default:
          return jsSafeStringify(str);
      }
    }
    function maybeAddSemicolon(lines) {
      var eoc = lastNonSpaceCharacter(lines);
      if (!eoc || "\n};".indexOf(eoc) < 0)
        return (0, lines_1.concat)([lines, ";"]);
      return lines;
    }
  }
});

// ../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/main.js
var require_main2 = __commonJS({
  "../../node_modules/.pnpm/recast@0.23.1/node_modules/recast/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.run = exports.prettyPrint = exports.print = exports.visit = exports.types = exports.parse = void 0;
    var tslib_1 = require_tslib();
    var fs_1 = tslib_1.__importDefault(require("fs"));
    var types17 = tslib_1.__importStar(require_main());
    exports.types = types17;
    var parser_1 = require_parser();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parser_1.parse;
    } });
    var printer_1 = require_printer();
    var ast_types_1 = require_main();
    Object.defineProperty(exports, "visit", { enumerable: true, get: function() {
      return ast_types_1.visit;
    } });
    function print13(node, options) {
      return new printer_1.Printer(options).print(node);
    }
    exports.print = print13;
    function prettyPrint3(node, options) {
      return new printer_1.Printer(options).printGenerically(node);
    }
    exports.prettyPrint = prettyPrint3;
    function run(transformer, options) {
      return runFile(process.argv[2], transformer, options);
    }
    exports.run = run;
    function runFile(path3, transformer, options) {
      fs_1.default.readFile(path3, "utf-8", function(err, code) {
        if (err) {
          console.error(err);
          return;
        }
        runString(code, transformer, options);
      });
    }
    function defaultWriteback(output) {
      process.stdout.write(output);
    }
    function runString(code, transformer, options) {
      var writeback = options && options.writeback || defaultWriteback;
      transformer((0, parser_1.parse)(code, options), function(node) {
        writeback(print13(node, options).code);
      });
    }
  }
});

// ../../node_modules/.pnpm/deepmerge@4.2.2/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/deepmerge@4.2.2/node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_3) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys2 = Object.keys(expected);
      for (const key of keys2) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "") {
      if (warnings.has(oldName))
        return;
      warnings.add(oldName);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace)
        return {
          internal: false,
          trace: ""
        };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAccessor = isAccessor;
    exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports.isArgumentPlaceholder = isArgumentPlaceholder;
    exports.isArrayExpression = isArrayExpression;
    exports.isArrayPattern = isArrayPattern;
    exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports.isArrowFunctionExpression = isArrowFunctionExpression2;
    exports.isAssignmentExpression = isAssignmentExpression;
    exports.isAssignmentPattern = isAssignmentPattern;
    exports.isAwaitExpression = isAwaitExpression;
    exports.isBigIntLiteral = isBigIntLiteral;
    exports.isBinary = isBinary;
    exports.isBinaryExpression = isBinaryExpression;
    exports.isBindExpression = isBindExpression;
    exports.isBlock = isBlock;
    exports.isBlockParent = isBlockParent;
    exports.isBlockStatement = isBlockStatement;
    exports.isBooleanLiteral = isBooleanLiteral;
    exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports.isBreakStatement = isBreakStatement;
    exports.isCallExpression = isCallExpression;
    exports.isCatchClause = isCatchClause;
    exports.isClass = isClass;
    exports.isClassAccessorProperty = isClassAccessorProperty;
    exports.isClassBody = isClassBody;
    exports.isClassDeclaration = isClassDeclaration;
    exports.isClassExpression = isClassExpression;
    exports.isClassImplements = isClassImplements;
    exports.isClassMethod = isClassMethod;
    exports.isClassPrivateMethod = isClassPrivateMethod;
    exports.isClassPrivateProperty = isClassPrivateProperty;
    exports.isClassProperty = isClassProperty;
    exports.isCompletionStatement = isCompletionStatement;
    exports.isConditional = isConditional;
    exports.isConditionalExpression = isConditionalExpression;
    exports.isContinueStatement = isContinueStatement;
    exports.isDebuggerStatement = isDebuggerStatement;
    exports.isDecimalLiteral = isDecimalLiteral;
    exports.isDeclaration = isDeclaration;
    exports.isDeclareClass = isDeclareClass;
    exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports.isDeclareFunction = isDeclareFunction;
    exports.isDeclareInterface = isDeclareInterface;
    exports.isDeclareModule = isDeclareModule;
    exports.isDeclareModuleExports = isDeclareModuleExports;
    exports.isDeclareOpaqueType = isDeclareOpaqueType;
    exports.isDeclareTypeAlias = isDeclareTypeAlias;
    exports.isDeclareVariable = isDeclareVariable;
    exports.isDeclaredPredicate = isDeclaredPredicate;
    exports.isDecorator = isDecorator;
    exports.isDirective = isDirective;
    exports.isDirectiveLiteral = isDirectiveLiteral;
    exports.isDoExpression = isDoExpression;
    exports.isDoWhileStatement = isDoWhileStatement;
    exports.isEmptyStatement = isEmptyStatement;
    exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports.isEnumBody = isEnumBody;
    exports.isEnumBooleanBody = isEnumBooleanBody;
    exports.isEnumBooleanMember = isEnumBooleanMember;
    exports.isEnumDeclaration = isEnumDeclaration;
    exports.isEnumDefaultedMember = isEnumDefaultedMember;
    exports.isEnumMember = isEnumMember;
    exports.isEnumNumberBody = isEnumNumberBody;
    exports.isEnumNumberMember = isEnumNumberMember;
    exports.isEnumStringBody = isEnumStringBody;
    exports.isEnumStringMember = isEnumStringMember;
    exports.isEnumSymbolBody = isEnumSymbolBody;
    exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports.isExportAllDeclaration = isExportAllDeclaration;
    exports.isExportDeclaration = isExportDeclaration;
    exports.isExportDefaultDeclaration = isExportDefaultDeclaration2;
    exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports.isExportNamedDeclaration = isExportNamedDeclaration;
    exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports.isExportSpecifier = isExportSpecifier;
    exports.isExpression = isExpression;
    exports.isExpressionStatement = isExpressionStatement;
    exports.isExpressionWrapper = isExpressionWrapper;
    exports.isFile = isFile;
    exports.isFlow = isFlow;
    exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports.isFlowDeclaration = isFlowDeclaration;
    exports.isFlowPredicate = isFlowPredicate;
    exports.isFlowType = isFlowType;
    exports.isFor = isFor;
    exports.isForInStatement = isForInStatement;
    exports.isForOfStatement = isForOfStatement;
    exports.isForStatement = isForStatement;
    exports.isForXStatement = isForXStatement;
    exports.isFunction = isFunction;
    exports.isFunctionDeclaration = isFunctionDeclaration2;
    exports.isFunctionExpression = isFunctionExpression2;
    exports.isFunctionParent = isFunctionParent;
    exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports.isFunctionTypeParam = isFunctionTypeParam;
    exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports.isIdentifier = isIdentifier2;
    exports.isIfStatement = isIfStatement;
    exports.isImmutable = isImmutable;
    exports.isImport = isImport;
    exports.isImportAttribute = isImportAttribute;
    exports.isImportDeclaration = isImportDeclaration;
    exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports.isImportSpecifier = isImportSpecifier;
    exports.isIndexedAccessType = isIndexedAccessType;
    exports.isInferredPredicate = isInferredPredicate;
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    exports.isInterfaceExtends = isInterfaceExtends;
    exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports.isInterpreterDirective = isInterpreterDirective;
    exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports.isJSX = isJSX;
    exports.isJSXAttribute = isJSXAttribute;
    exports.isJSXClosingElement = isJSXClosingElement;
    exports.isJSXClosingFragment = isJSXClosingFragment;
    exports.isJSXElement = isJSXElement;
    exports.isJSXEmptyExpression = isJSXEmptyExpression;
    exports.isJSXExpressionContainer = isJSXExpressionContainer;
    exports.isJSXFragment = isJSXFragment;
    exports.isJSXIdentifier = isJSXIdentifier;
    exports.isJSXMemberExpression = isJSXMemberExpression;
    exports.isJSXNamespacedName = isJSXNamespacedName;
    exports.isJSXOpeningElement = isJSXOpeningElement;
    exports.isJSXOpeningFragment = isJSXOpeningFragment;
    exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports.isJSXSpreadChild = isJSXSpreadChild;
    exports.isJSXText = isJSXText;
    exports.isLVal = isLVal;
    exports.isLabeledStatement = isLabeledStatement;
    exports.isLiteral = isLiteral;
    exports.isLogicalExpression = isLogicalExpression;
    exports.isLoop = isLoop;
    exports.isMemberExpression = isMemberExpression;
    exports.isMetaProperty = isMetaProperty;
    exports.isMethod = isMethod;
    exports.isMiscellaneous = isMiscellaneous;
    exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports.isModuleDeclaration = isModuleDeclaration;
    exports.isModuleExpression = isModuleExpression;
    exports.isModuleSpecifier = isModuleSpecifier;
    exports.isNewExpression = isNewExpression;
    exports.isNoop = isNoop;
    exports.isNullLiteral = isNullLiteral;
    exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports.isNumberLiteral = isNumberLiteral;
    exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports.isNumericLiteral = isNumericLiteral;
    exports.isObjectExpression = isObjectExpression;
    exports.isObjectMember = isObjectMember;
    exports.isObjectMethod = isObjectMethod;
    exports.isObjectPattern = isObjectPattern2;
    exports.isObjectProperty = isObjectProperty2;
    exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports.isObjectTypeIndexer = isObjectTypeIndexer;
    exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports.isObjectTypeProperty = isObjectTypeProperty;
    exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports.isOpaqueType = isOpaqueType;
    exports.isOptionalCallExpression = isOptionalCallExpression;
    exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports.isOptionalMemberExpression = isOptionalMemberExpression;
    exports.isParenthesizedExpression = isParenthesizedExpression;
    exports.isPattern = isPattern;
    exports.isPatternLike = isPatternLike;
    exports.isPipelineBareFunction = isPipelineBareFunction;
    exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports.isPipelineTopicExpression = isPipelineTopicExpression;
    exports.isPlaceholder = isPlaceholder;
    exports.isPrivate = isPrivate;
    exports.isPrivateName = isPrivateName;
    exports.isProgram = isProgram;
    exports.isProperty = isProperty;
    exports.isPureish = isPureish;
    exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports.isRecordExpression = isRecordExpression;
    exports.isRegExpLiteral = isRegExpLiteral;
    exports.isRegexLiteral = isRegexLiteral;
    exports.isRestElement = isRestElement;
    exports.isRestProperty = isRestProperty;
    exports.isReturnStatement = isReturnStatement;
    exports.isScopable = isScopable;
    exports.isSequenceExpression = isSequenceExpression;
    exports.isSpreadElement = isSpreadElement;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStandardized = isStandardized;
    exports.isStatement = isStatement;
    exports.isStaticBlock = isStaticBlock;
    exports.isStringLiteral = isStringLiteral;
    exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports.isStringTypeAnnotation = isStringTypeAnnotation;
    exports.isSuper = isSuper;
    exports.isSwitchCase = isSwitchCase;
    exports.isSwitchStatement = isSwitchStatement;
    exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports.isTSAnyKeyword = isTSAnyKeyword;
    exports.isTSArrayType = isTSArrayType;
    exports.isTSAsExpression = isTSAsExpression2;
    exports.isTSBaseType = isTSBaseType;
    exports.isTSBigIntKeyword = isTSBigIntKeyword;
    exports.isTSBooleanKeyword = isTSBooleanKeyword;
    exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports.isTSConditionalType = isTSConditionalType;
    exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports.isTSConstructorType = isTSConstructorType;
    exports.isTSDeclareFunction = isTSDeclareFunction;
    exports.isTSDeclareMethod = isTSDeclareMethod;
    exports.isTSEntityName = isTSEntityName;
    exports.isTSEnumDeclaration = isTSEnumDeclaration;
    exports.isTSEnumMember = isTSEnumMember;
    exports.isTSExportAssignment = isTSExportAssignment;
    exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports.isTSExternalModuleReference = isTSExternalModuleReference;
    exports.isTSFunctionType = isTSFunctionType;
    exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports.isTSImportType = isTSImportType;
    exports.isTSIndexSignature = isTSIndexSignature;
    exports.isTSIndexedAccessType = isTSIndexedAccessType;
    exports.isTSInferType = isTSInferType;
    exports.isTSInstantiationExpression = isTSInstantiationExpression;
    exports.isTSInterfaceBody = isTSInterfaceBody;
    exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports.isTSIntersectionType = isTSIntersectionType;
    exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports.isTSLiteralType = isTSLiteralType;
    exports.isTSMappedType = isTSMappedType;
    exports.isTSMethodSignature = isTSMethodSignature;
    exports.isTSModuleBlock = isTSModuleBlock;
    exports.isTSModuleDeclaration = isTSModuleDeclaration;
    exports.isTSNamedTupleMember = isTSNamedTupleMember;
    exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports.isTSNeverKeyword = isTSNeverKeyword;
    exports.isTSNonNullExpression = isTSNonNullExpression;
    exports.isTSNullKeyword = isTSNullKeyword;
    exports.isTSNumberKeyword = isTSNumberKeyword;
    exports.isTSObjectKeyword = isTSObjectKeyword;
    exports.isTSOptionalType = isTSOptionalType;
    exports.isTSParameterProperty = isTSParameterProperty;
    exports.isTSParenthesizedType = isTSParenthesizedType;
    exports.isTSPropertySignature = isTSPropertySignature;
    exports.isTSQualifiedName = isTSQualifiedName;
    exports.isTSRestType = isTSRestType;
    exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports.isTSStringKeyword = isTSStringKeyword;
    exports.isTSSymbolKeyword = isTSSymbolKeyword;
    exports.isTSThisType = isTSThisType;
    exports.isTSTupleType = isTSTupleType;
    exports.isTSType = isTSType;
    exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports.isTSTypeAnnotation = isTSTypeAnnotation;
    exports.isTSTypeAssertion = isTSTypeAssertion;
    exports.isTSTypeElement = isTSTypeElement;
    exports.isTSTypeLiteral = isTSTypeLiteral;
    exports.isTSTypeOperator = isTSTypeOperator;
    exports.isTSTypeParameter = isTSTypeParameter;
    exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports.isTSTypePredicate = isTSTypePredicate;
    exports.isTSTypeQuery = isTSTypeQuery;
    exports.isTSTypeReference = isTSTypeReference;
    exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports.isTSUnionType = isTSUnionType;
    exports.isTSUnknownKeyword = isTSUnknownKeyword;
    exports.isTSVoidKeyword = isTSVoidKeyword;
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports.isTemplateElement = isTemplateElement;
    exports.isTemplateLiteral = isTemplateLiteral;
    exports.isTerminatorless = isTerminatorless;
    exports.isThisExpression = isThisExpression;
    exports.isThisTypeAnnotation = isThisTypeAnnotation;
    exports.isThrowStatement = isThrowStatement;
    exports.isTopicReference = isTopicReference;
    exports.isTryStatement = isTryStatement;
    exports.isTupleExpression = isTupleExpression;
    exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports.isTypeAlias = isTypeAlias;
    exports.isTypeAnnotation = isTypeAnnotation;
    exports.isTypeCastExpression = isTypeCastExpression;
    exports.isTypeParameter = isTypeParameter;
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports.isTypeScript = isTypeScript;
    exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports.isUnaryExpression = isUnaryExpression;
    exports.isUnaryLike = isUnaryLike;
    exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports.isUpdateExpression = isUpdateExpression;
    exports.isUserWhitespacable = isUserWhitespacable;
    exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports.isVariableDeclaration = isVariableDeclaration2;
    exports.isVariableDeclarator = isVariableDeclarator2;
    exports.isVariance = isVariance;
    exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports.isWhile = isWhile;
    exports.isWhileStatement = isWhileStatement;
    exports.isWithStatement = isWithStatement;
    exports.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrayExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AssignmentExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinaryExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BinaryExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterpreterDirective(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterpreterDirective")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirective(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Directive")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirectiveLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DirectiveLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BlockStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBreakStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BreakStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCallExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "CallExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCatchClause(node, opts) {
      if (!node)
        return false;
      if (node.type !== "CatchClause")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditionalExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ConditionalExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isContinueStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ContinueStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDebuggerStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DebuggerStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoWhileStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DoWhileStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EmptyStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExpressionStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFile(node, opts) {
      if (!node)
        return false;
      if (node.type !== "File")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForInStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ForInStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ForStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionDeclaration2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionExpression2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIdentifier2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Identifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIfStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "IfStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLabeledStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "LabeledStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StringLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumericLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NumericLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NullLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BooleanLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegExpLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "RegExpLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLogicalExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "LogicalExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMemberExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "MemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNewExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NewExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProgram(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Program")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectProperty2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "RestElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isReturnStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ReturnStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSequenceExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SequenceExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isParenthesizedExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ParenthesizedExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchCase(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SwitchCase")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SwitchStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ThisExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThrowStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ThrowStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTryStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TryStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "UnaryExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUpdateExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "UpdateExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclaration2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "VariableDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclarator2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "VariableDeclarator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhileStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "WhileStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWithStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "WithStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentPattern(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AssignmentPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayPattern(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrayPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrowFunctionExpression2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrowFunctionExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportAllDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultDeclaration2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportDefaultDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportNamedDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForOfStatement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ForOfStatement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportDefaultSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportNamespaceSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMetaProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "MetaProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectPattern2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectPattern")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SpreadElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSuper(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Super")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TaggedTemplateExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TemplateElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TemplateLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isYieldExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "YieldExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAwaitExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AwaitExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImport(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Import")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBigIntLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BigIntLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportNamespaceSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OptionalMemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalCallExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OptionalCallExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassAccessorProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassAccessorProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassPrivateProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassPrivateMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivateName(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PrivateName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStaticBlock(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StaticBlock")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "AnyTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArrayTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BooleanTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BooleanLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NullLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassImplements(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ClassImplements")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareClass(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareClass")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareFunction(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareInterface(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareInterface")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModule(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareModule")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModuleExports(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareModuleExports")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareTypeAlias")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareOpaqueType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareVariable(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareVariable")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareExportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclareExportAllDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaredPredicate(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DeclaredPredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExistsTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeParam(node, opts) {
      if (!node)
        return false;
      if (node.type !== "FunctionTypeParam")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "GenericTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInferredPredicate(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InferredPredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceExtends(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterfaceExtends")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterfaceDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "InterfaceTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "IntersectionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "MixedTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EmptyTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NullableTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NumberLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "NumberTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeInternalSlot")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeCallProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeIndexer")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ObjectTypeSpreadProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOpaqueType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OpaqueType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "QualifiedTypeIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StringLiteralTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "StringTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "SymbolTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ThisTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TupleTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeofTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAlias(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeAlias")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeCastExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeCastExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameter(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeParameter")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeParameterDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TypeParameterInstantiation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "UnionTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariance(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Variance")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "VoidTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumBooleanBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumNumberBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumStringBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumSymbolBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumSymbolBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumBooleanMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumNumberMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumStringMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "EnumDefaultedMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIndexedAccessType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "IndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "OptionalIndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXAttribute(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXClosingElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXEmptyExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXExpressionContainer")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadChild(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXSpreadChild")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXMemberExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXMemberExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXNamespacedName(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXNamespacedName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningElement(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXOpeningElement")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXSpreadAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXText(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXText")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXFragment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXOpeningFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingFragment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "JSXClosingFragment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNoop(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Noop")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPlaceholder(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Placeholder")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "V8IntrinsicIdentifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ArgumentPlaceholder")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBindExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "BindExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportAttribute(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ImportAttribute")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecorator(node, opts) {
      if (!node)
        return false;
      if (node.type !== "Decorator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DoExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ExportDefaultSpecifier")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRecordExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "RecordExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TupleExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecimalLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "DecimalLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "ModuleExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTopicReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TopicReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PipelineTopicExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineBareFunction(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PipelineBareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "PipelinePrimaryTopicReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParameterProperty(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSParameterProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareFunction(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSDeclareFunction")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareMethod(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSDeclareMethod")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSQualifiedName(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSQualifiedName")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSCallSignatureDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSConstructSignatureDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSPropertySignature(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSPropertySignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMethodSignature(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSMethodSignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexSignature(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIndexSignature")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAnyKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSAnyKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSBooleanKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSBigIntKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIntrinsicKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNeverKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNeverKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNullKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNullKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNumberKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNumberKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSObjectKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSObjectKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSStringKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSStringKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSSymbolKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSUndefinedKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSUnknownKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSVoidKeyword(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSVoidKeyword")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSThisType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSThisType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSFunctionType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSFunctionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructorType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSConstructorType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypePredicate(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypePredicate")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeQuery(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeQuery")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeLiteral(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSArrayType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSArrayType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTupleType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTupleType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSOptionalType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSOptionalType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSRestType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSRestType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNamedTupleMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnionType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSUnionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntersectionType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIntersectionType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConditionalType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSConditionalType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInferType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInferType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParenthesizedType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSParenthesizedType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeOperator(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeOperator")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSIndexedAccessType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMappedType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSMappedType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSLiteralType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSLiteralType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSExpressionWithTypeArguments")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInterfaceDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceBody(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInterfaceBody")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeAliasDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInstantiationExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSInstantiationExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAsExpression2(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSAsExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSatisfiesExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSSatisfiesExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAssertion(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeAssertion")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSEnumDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumMember(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSEnumMember")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSModuleDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleBlock(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSModuleBlock")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportType(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSImportType")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSImportEqualsDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSExternalModuleReference")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNonNullExpression(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNonNullExpression")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExportAssignment(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSExportAssignment")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSNamespaceExportDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeAnnotation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeParameterInstantiation")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeParameterDeclaration")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameter(node, opts) {
      if (!node)
        return false;
      if (node.type !== "TSTypeParameter")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStandardized(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpression(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinary(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isScopable(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockParent(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlock(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStatement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTerminatorless(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCompletionStatement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditional(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLoop(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhile(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionWrapper(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFor(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForXStatement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunction(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParent(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPureish(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Declaration":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPatternLike(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLVal(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEntityName(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLiteral(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImmutable(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUserWhitespacable(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMethod(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMember(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProperty(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryLike(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPattern(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClass(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleSpecifier(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAccessor(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivate(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlow(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowType(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowDeclaration(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowPredicate(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBody(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumMember(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSX(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMiscellaneous(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeScript(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeElement(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSType(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBaseType(node, opts) {
      if (!node)
        return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node)
        return false;
      if (node.type !== "NumberLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node)
        return false;
      if (node.type !== "RegexLiteral")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestProperty(node, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node)
        return false;
      if (node.type !== "RestProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node)
        return false;
      if (node.type !== "SpreadProperty")
        return false;
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node, opts);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matchesPattern;
    var _generated = require_generated();
    function matchesPattern(member, match, allowPartial) {
      if (!(0, _generated.isMemberExpression)(member))
        return false;
      const parts = Array.isArray(match) ? match : match.split(".");
      const nodes = [];
      let node;
      for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length)
        return false;
      if (!allowPartial && nodes.length > parts.length)
        return false;
      for (let i2 = 0, j2 = nodes.length - 1; i2 < parts.length; i2++, j2--) {
        const node2 = nodes[j2];
        let value;
        if ((0, _generated.isIdentifier)(node2)) {
          value = node2.name;
        } else if ((0, _generated.isStringLiteral)(node2)) {
          value = node2.value;
        } else if ((0, _generated.isThisExpression)(node2)) {
          value = "this";
        } else {
          return false;
        }
        if (parts[i2] !== value)
          return false;
      }
      return true;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      const parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = isReactComponent;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// ../../node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS({
  "../../node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js"(exports, module2) {
    "use strict";
    var fastProto = null;
    function FastObject(o2) {
      if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
      }
      fastProto = FastObject.prototype = o2 == null ? /* @__PURE__ */ Object.create(null) : o2;
      return new FastObject();
    }
    FastObject();
    module2.exports = function toFastproperties(o2) {
      return FastObject(o2);
    };
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isType;
    var _definitions = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (_definitions.ALIAS_KEYS[targetType])
        return false;
      const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (const alias of aliases) {
          if (nodeType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPlaceholderType;
    var _definitions = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType)
        return true;
      const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias)
            return true;
        }
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = is;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _definitions = require_definitions();
    function is(type, node, opts) {
      if (!node)
        return false;
      const matches = (0, _isType.default)(node.type, type);
      if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node.expectedNode, type);
        }
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.19.1/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.19.1/node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i2 = 0, length = set.length; i2 < length; i2 += 2) {
        pos += set[i2];
        if (pos > code)
          return false;
        pos += set[i2 + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i2 = 0; i2 < name.length; i2++) {
        let cp = name.charCodeAt(i2);
        if ((cp & 64512) === 55296 && i2 + 1 < name.length) {
          const trail = name.charCodeAt(++i2);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.19.1/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.19.1/node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.19.1/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.19.1/node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib4();
    function isValidIdentifier(name, reserved = true) {
      if (typeof name !== "string")
        return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name);
    }
  }
});

// ../../node_modules/.pnpm/@babel+helper-string-parser@7.21.5/node_modules/@babel/helper-string-parser/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/.pnpm/@babel+helper-string-parser@7.21.5/node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readCodePoint = readCodePoint;
    exports.readInt = readInt;
    exports.readStringContents = readStringContents;
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          ({
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i2 = 0, e3 = len == null ? Infinity : len; i2 < e3; ++i2) {
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code;
      if (ch === 123) {
        ++pos;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code,
        pos
      };
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/constants/index.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
    var FLATTENABLE_KEYS = ["body", "expressions"];
    exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
    var FOR_INIT_KEYS = ["left", "init"];
    exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
    var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    exports.COMMENT_KEYS = COMMENT_KEYS;
    var LOGICAL_OPERATORS = ["||", "&&", "??"];
    exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
    var UPDATE_OPERATORS = ["++", "--"];
    exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
    var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
    var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
    var COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
    var BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
    var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
    var BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    exports.BINARY_OPERATORS = BINARY_OPERATORS;
    var ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
    var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
    var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
    var STRING_UNARY_OPERATORS = ["typeof"];
    exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
    var UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    exports.UNARY_OPERATORS = UNARY_OPERATORS;
    var INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    exports.INHERIT_KEYS = INHERIT_KEYS;
    var BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
    var NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.assertEach = assertEach;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertNodeType = assertNodeType;
    exports.assertOneOf = assertOneOf;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.assertShape = assertShape;
    exports.assertValueType = assertValueType;
    exports.chain = chain;
    exports.default = defineType;
    exports.defineAliasedType = defineAliasedType;
    exports.typeIs = typeIs;
    exports.validate = validate2;
    exports.validateArrayOfType = validateArrayOfType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = {};
    exports.VISITOR_KEYS = VISITOR_KEYS;
    var ALIAS_KEYS = {};
    exports.ALIAS_KEYS = ALIAS_KEYS;
    var FLIPPED_ALIAS_KEYS = {};
    exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
    var NODE_FIELDS = {};
    exports.NODE_FIELDS = NODE_FIELDS;
    var BUILDER_KEYS = {};
    exports.BUILDER_KEYS = BUILDER_KEYS;
    var DEPRECATED_KEYS = {};
    exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
    var NODE_PARENT_VALIDATIONS = {};
    exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate2(validate3) {
      return {
        validate: validate3
      };
    }
    function typeIs(typeName) {
      return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
    }
    function validateType(typeName) {
      return validate2(typeIs(typeName));
    }
    function validateOptional(validate3) {
      return {
        validate: validate3,
        optional: true
      };
    }
    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }
    function validateArrayOfType(typeName) {
      return validate2(arrayOfType(typeName));
    }
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val))
          return;
        for (let i2 = 0; i2 < val.length; i2++) {
          const subkey = `${key}[${i2}]`;
          const v2 = val[i2];
          callback(node, subkey, v2);
          if (process.env.BABEL_TYPES_8_BREAKING)
            (0, _validate.validateChild)(node, subkey, v2);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate3(node, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate3.oneOf = values;
      return validate3;
    }
    function assertNodeType(...types17) {
      function validate3(node, key, val) {
        for (const type of types17) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types17)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate3.oneOfNodeTypes = types17;
      return validate3;
    }
    function assertNodeOrValueType(...types17) {
      function validate3(node, key, val) {
        for (const type of types17) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types17)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate3.oneOfNodeOrValueTypes = types17;
      return validate3;
    }
    function assertValueType(type) {
      function validate3(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) {
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
      }
      validate3.type = type;
      return validate3;
    }
    function assertShape(shape) {
      function validate3(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate3.shapeOf = shape;
      return validate3;
    }
    function assertOptionalChainStart() {
      function validate3(node) {
        var _current;
        let current = node;
        while (node) {
          const {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional)
              return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional)
              return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate3;
    }
    function chain(...fns) {
      function validate3(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate3.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate3;
    }
    var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    var validFieldKeys = ["default", "optional", "validate"];
    var store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$, _defined;
          if (opts.inherits)
            defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          (_defined = defined) != null ? _defined : defined = [];
          opts.aliases = defined;
        }
        const additional = aliases.filter((a2) => !defined.includes(a2));
        defined.unshift(...additional);
        defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys2 = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys2) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k3 of Object.keys(opts)) {
        if (validTypeOpts.indexOf(k3) === -1) {
          throw new Error(`Unknown type option "${k3}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && builder.indexOf(key) === -1) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k3 of Object.keys(field)) {
          if (validFieldKeys.indexOf(k3) === -1) {
            throw new Error(`Unknown field key "${k3}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      store[type] = opts;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/core.js
var require_core3 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib4();
    var _helperStringParser = require_lib5();
    var _constants = require_constants2();
    var _utils = require_utils3();
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertValueType)("string");
            }
            const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
            const pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
              validator(node, key, val);
            };
          }()
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.operator === "in" ? inOp : expression;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {}, {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
      },
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: function() {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return () => {
          };
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent2, key, node) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent2)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          }))
        }
      }),
      validate(parent2, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /\.(\w+)$/.exec(key);
        if (!match)
          return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent2, nonComp))
            return;
          if ((0, _is.default)("OptionalMemberExpression", parent2, nonComp))
            return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent2, nonComp))
            return;
          if ((0, _is.default)("Method", parent2, nonComp))
            return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent2))
            return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent2, {
            imported: node
          }))
            return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent2, {
            meta: node
          }))
            return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      }
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("number")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            const invalid = /[^gimsuy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertOneOf)(true, false),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: {
          validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
          }, {
            type: "boolean"
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !(0, _is.default)("Identifier", node.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }),
          default: false
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent2, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const validator = (0, _is.default)("ObjectPattern", parent2) ? pattern : expression;
          validator(node, "value", node.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate(parent2, key) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match)
          throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index] = match;
        if (parent2[listKey].length > +index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      }
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (!node.handler && !node.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          }))
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using")
        },
        declarations: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
      },
      validate(parent2, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ForXStatement", parent2, {
          left: node
        }))
          return;
        if (node.declarations.length !== 1) {
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent2.type}`);
        }
      }
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("LVal");
            }
            const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
            const without = (0, _utils.assertNodeType)("Identifier");
            return function(node, key, val) {
              const validator = node.init ? normal : without;
              validator(node, key, val);
            };
          }()
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
        }
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent2, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _is.default)("ExportDefaultDeclaration", parent2)) {
            identifier(node, "id", node.id);
          }
        };
      }()
    });
    defineType("ExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
      }
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          }), function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          })
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
          default: [],
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return sourced;
            return function(node, key, val) {
              const validator = node.source ? sourced : sourceless;
              validator(node, key, val);
            };
          }()))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return function(node, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            };
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      visitor: ["specifiers", "source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: {
        assertions: {
          optional: true,
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        specifiers: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          }))
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
      },
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    });
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "quasi", "typeParameters"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled)
              throw new Error("Invalid raw");
            node.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            if (val && !node.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node, key, val) {
              const validator2 = node.computed ? computed : normal;
              validator2(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassAccessorProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators", "typeAnnotation"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/flow.js
var require_flow2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _utils = require_utils3();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name) => {
      const isDeclareClass = name === "DeclareClass";
      defineType(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils3();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    var _utils = require_utils3();
    var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    exports.PLACEHOLDERS = PLACEHOLDERS;
    var PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length)
        PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = {};
    exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils3();
    var _placeholders = require_placeholders();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    {
      defineType("Noop", {
        visitor: []
      });
    }
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils3();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils3();
    var _core = require_core3();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation", "initializer"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "typeAnnotation", "nameType"],
      fields: {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent2, key, node) {
              if ((0, _is.default)("UnaryExpression", node)) {
                unaryOperator(node, "operator", node.operator);
                unaryExpression(node, "argument", node.argument);
              } else {
                literal(parent2, key, node);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
        body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
      }
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      visitor: ["argument", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement"],
      visitor: ["id", "moduleReference"],
      fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
    exports.DEPRECATED_ALIASES = DEPRECATED_ALIASES;
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    var _toFastProperties = require_to_fast_properties();
    require_core3();
    require_flow2();
    require_jsx2();
    require_misc();
    require_experimental();
    require_typescript2();
    var _utils = require_utils3();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    var TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
    exports.TYPES = TYPES;
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validate2;
    exports.validateChild = validateChild;
    exports.validateField = validateField;
    var _definitions = require_definitions();
    function validate2(node, key, val) {
      if (!node)
        return;
      const fields = _definitions.NODE_FIELDS[node.type];
      if (!fields)
        return;
      const field = fields[key];
      validateField(node, key, val, field);
      validateChild(node, key, val);
    }
    function validateField(node, key, val, field) {
      if (!(field != null && field.validate))
        return;
      if (field.optional && val == null)
        return;
      field.validate(node, key, val);
    }
    function validateChild(node, key, val) {
      if (val == null)
        return;
      const validate3 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
      if (!validate3)
        return;
      validate3(node, key, val);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/validateNode.js
var require_validateNode = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/validateNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = validateNode;
    var _validate = require_validate();
    var _3 = require_lib6();
    function validateNode(node) {
      const keys2 = _3.BUILDER_KEYS[node.type];
      for (const key of keys2) {
        (0, _validate.default)(node, key, node[key]);
      }
      return node;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.arrayExpression = arrayExpression;
    exports.arrayPattern = arrayPattern;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.assignmentPattern = assignmentPattern;
    exports.awaitExpression = awaitExpression;
    exports.bigIntLiteral = bigIntLiteral;
    exports.binaryExpression = binaryExpression;
    exports.bindExpression = bindExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.classAccessorProperty = classAccessorProperty;
    exports.classBody = classBody;
    exports.classDeclaration = classDeclaration;
    exports.classExpression = classExpression;
    exports.classImplements = classImplements;
    exports.classMethod = classMethod;
    exports.classPrivateMethod = classPrivateMethod;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classProperty = classProperty;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.decimalLiteral = decimalLiteral;
    exports.declareClass = declareClass;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareVariable = declareVariable;
    exports.declaredPredicate = declaredPredicate;
    exports.decorator = decorator;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.doExpression = doExpression;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumDeclaration = enumDeclaration;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.enumNumberBody = enumNumberBody;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringBody = enumStringBody;
    exports.enumStringMember = enumStringMember;
    exports.enumSymbolBody = enumSymbolBody;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.exportSpecifier = exportSpecifier;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forOfStatement = forOfStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.import = _import;
    exports.importAttribute = importAttribute;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.indexedAccessType = indexedAccessType;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.interpreterDirective = interpreterDirective;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
    exports.jSXElement = exports.jsxElement = jsxElement;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
    exports.jSXFragment = exports.jsxFragment = jsxFragment;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXText = exports.jsxText = jsxText;
    exports.labeledStatement = labeledStatement;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.metaProperty = metaProperty;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.moduleExpression = moduleExpression;
    exports.newExpression = newExpression;
    exports.noop = noop2;
    exports.nullLiteral = nullLiteral;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteral = NumberLiteral;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectPattern = objectPattern;
    exports.objectProperty = objectProperty;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.optionalCallExpression = optionalCallExpression;
    exports.optionalIndexedAccessType = optionalIndexedAccessType;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.placeholder = placeholder;
    exports.privateName = privateName;
    exports.program = program3;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.recordExpression = recordExpression;
    exports.regExpLiteral = regExpLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restElement = restElement;
    exports.restProperty = RestProperty;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.spreadElement = spreadElement;
    exports.spreadProperty = SpreadProperty;
    exports.staticBlock = staticBlock;
    exports.stringLiteral = stringLiteral;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.super = _super;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.thisExpression = thisExpression;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.throwStatement = throwStatement;
    exports.topicReference = topicReference;
    exports.tryStatement = tryStatement;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference2;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tupleExpression = tupleExpression;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.unaryExpression = unaryExpression;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.updateExpression = updateExpression;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.variance = variance;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.yieldExpression = yieldExpression;
    var _validateNode = require_validateNode();
    var _deprecationWarning = require_deprecationWarning();
    function arrayExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "ArrayExpression",
        elements
      });
    }
    function assignmentExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentExpression",
        operator,
        left,
        right
      });
    }
    function binaryExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "BinaryExpression",
        operator,
        left,
        right
      });
    }
    function interpreterDirective(value) {
      return (0, _validateNode.default)({
        type: "InterpreterDirective",
        value
      });
    }
    function directive(value) {
      return (0, _validateNode.default)({
        type: "Directive",
        value
      });
    }
    function directiveLiteral(value) {
      return (0, _validateNode.default)({
        type: "DirectiveLiteral",
        value
      });
    }
    function blockStatement(body, directives = []) {
      return (0, _validateNode.default)({
        type: "BlockStatement",
        body,
        directives
      });
    }
    function breakStatement(label = null) {
      return (0, _validateNode.default)({
        type: "BreakStatement",
        label
      });
    }
    function callExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "CallExpression",
        callee,
        arguments: _arguments
      });
    }
    function catchClause(param = null, body) {
      return (0, _validateNode.default)({
        type: "CatchClause",
        param,
        body
      });
    }
    function conditionalExpression(test, consequent, alternate) {
      return (0, _validateNode.default)({
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      });
    }
    function continueStatement(label = null) {
      return (0, _validateNode.default)({
        type: "ContinueStatement",
        label
      });
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      return (0, _validateNode.default)({
        type: "DoWhileStatement",
        test,
        body
      });
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      return (0, _validateNode.default)({
        type: "ExpressionStatement",
        expression
      });
    }
    function file(program4, comments = null, tokens = null) {
      return (0, _validateNode.default)({
        type: "File",
        program: program4,
        comments,
        tokens
      });
    }
    function forInStatement(left, right, body) {
      return (0, _validateNode.default)({
        type: "ForInStatement",
        left,
        right,
        body
      });
    }
    function forStatement(init3 = null, test = null, update = null, body) {
      return (0, _validateNode.default)({
        type: "ForStatement",
        init: init3,
        test,
        update,
        body
      });
    }
    function functionDeclaration(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function functionExpression(id = null, params, body, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      });
    }
    function identifier(name) {
      return (0, _validateNode.default)({
        type: "Identifier",
        name
      });
    }
    function ifStatement(test, consequent, alternate = null) {
      return (0, _validateNode.default)({
        type: "IfStatement",
        test,
        consequent,
        alternate
      });
    }
    function labeledStatement(label, body) {
      return (0, _validateNode.default)({
        type: "LabeledStatement",
        label,
        body
      });
    }
    function stringLiteral(value) {
      return (0, _validateNode.default)({
        type: "StringLiteral",
        value
      });
    }
    function numericLiteral(value) {
      return (0, _validateNode.default)({
        type: "NumericLiteral",
        value
      });
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value) {
      return (0, _validateNode.default)({
        type: "BooleanLiteral",
        value
      });
    }
    function regExpLiteral(pattern, flags = "") {
      return (0, _validateNode.default)({
        type: "RegExpLiteral",
        pattern,
        flags
      });
    }
    function logicalExpression(operator, left, right) {
      return (0, _validateNode.default)({
        type: "LogicalExpression",
        operator,
        left,
        right
      });
    }
    function memberExpression(object, property, computed = false, optional = null) {
      return (0, _validateNode.default)({
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function newExpression(callee, _arguments) {
      return (0, _validateNode.default)({
        type: "NewExpression",
        callee,
        arguments: _arguments
      });
    }
    function program3(body, directives = [], sourceType = "script", interpreter = null) {
      return (0, _validateNode.default)({
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter,
        sourceFile: null
      });
    }
    function objectExpression(properties) {
      return (0, _validateNode.default)({
        type: "ObjectExpression",
        properties
      });
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      });
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      return (0, _validateNode.default)({
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      });
    }
    function restElement(argument) {
      return (0, _validateNode.default)({
        type: "RestElement",
        argument
      });
    }
    function returnStatement(argument = null) {
      return (0, _validateNode.default)({
        type: "ReturnStatement",
        argument
      });
    }
    function sequenceExpression(expressions) {
      return (0, _validateNode.default)({
        type: "SequenceExpression",
        expressions
      });
    }
    function parenthesizedExpression(expression) {
      return (0, _validateNode.default)({
        type: "ParenthesizedExpression",
        expression
      });
    }
    function switchCase(test = null, consequent) {
      return (0, _validateNode.default)({
        type: "SwitchCase",
        test,
        consequent
      });
    }
    function switchStatement(discriminant, cases) {
      return (0, _validateNode.default)({
        type: "SwitchStatement",
        discriminant,
        cases
      });
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      return (0, _validateNode.default)({
        type: "ThrowStatement",
        argument
      });
    }
    function tryStatement(block3, handler = null, finalizer = null) {
      return (0, _validateNode.default)({
        type: "TryStatement",
        block: block3,
        handler,
        finalizer
      });
    }
    function unaryExpression(operator, argument, prefix = true) {
      return (0, _validateNode.default)({
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      });
    }
    function updateExpression(operator, argument, prefix = false) {
      return (0, _validateNode.default)({
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      });
    }
    function variableDeclaration(kind, declarations) {
      return (0, _validateNode.default)({
        type: "VariableDeclaration",
        kind,
        declarations
      });
    }
    function variableDeclarator(id, init3 = null) {
      return (0, _validateNode.default)({
        type: "VariableDeclarator",
        id,
        init: init3
      });
    }
    function whileStatement(test, body) {
      return (0, _validateNode.default)({
        type: "WhileStatement",
        test,
        body
      });
    }
    function withStatement(object, body) {
      return (0, _validateNode.default)({
        type: "WithStatement",
        object,
        body
      });
    }
    function assignmentPattern(left, right) {
      return (0, _validateNode.default)({
        type: "AssignmentPattern",
        left,
        right
      });
    }
    function arrayPattern(elements) {
      return (0, _validateNode.default)({
        type: "ArrayPattern",
        elements
      });
    }
    function arrowFunctionExpression(params, body, async = false) {
      return (0, _validateNode.default)({
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      });
    }
    function classBody(body) {
      return (0, _validateNode.default)({
        type: "ClassBody",
        body
      });
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      });
    }
    function classDeclaration(id, superClass = null, body, decorators = null) {
      return (0, _validateNode.default)({
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      });
    }
    function exportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "ExportAllDeclaration",
        source
      });
    }
    function exportDefaultDeclaration(declaration) {
      return (0, _validateNode.default)({
        type: "ExportDefaultDeclaration",
        declaration
      });
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      return (0, _validateNode.default)({
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function exportSpecifier(local, exported) {
      return (0, _validateNode.default)({
        type: "ExportSpecifier",
        local,
        exported
      });
    }
    function forOfStatement(left, right, body, _await = false) {
      return (0, _validateNode.default)({
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      });
    }
    function importDeclaration(specifiers, source) {
      return (0, _validateNode.default)({
        type: "ImportDeclaration",
        specifiers,
        source
      });
    }
    function importDefaultSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportDefaultSpecifier",
        local
      });
    }
    function importNamespaceSpecifier(local) {
      return (0, _validateNode.default)({
        type: "ImportNamespaceSpecifier",
        local
      });
    }
    function importSpecifier(local, imported) {
      return (0, _validateNode.default)({
        type: "ImportSpecifier",
        local,
        imported
      });
    }
    function metaProperty(meta, property) {
      return (0, _validateNode.default)({
        type: "MetaProperty",
        meta,
        property
      });
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
      return (0, _validateNode.default)({
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      });
    }
    function objectPattern(properties) {
      return (0, _validateNode.default)({
        type: "ObjectPattern",
        properties
      });
    }
    function spreadElement(argument) {
      return (0, _validateNode.default)({
        type: "SpreadElement",
        argument
      });
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      return (0, _validateNode.default)({
        type: "TaggedTemplateExpression",
        tag,
        quasi
      });
    }
    function templateElement(value, tail = false) {
      return (0, _validateNode.default)({
        type: "TemplateElement",
        value,
        tail
      });
    }
    function templateLiteral(quasis, expressions) {
      return (0, _validateNode.default)({
        type: "TemplateLiteral",
        quasis,
        expressions
      });
    }
    function yieldExpression(argument = null, delegate = false) {
      return (0, _validateNode.default)({
        type: "YieldExpression",
        argument,
        delegate
      });
    }
    function awaitExpression(argument) {
      return (0, _validateNode.default)({
        type: "AwaitExpression",
        argument
      });
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value) {
      return (0, _validateNode.default)({
        type: "BigIntLiteral",
        value
      });
    }
    function exportNamespaceSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportNamespaceSpecifier",
        exported
      });
    }
    function optionalMemberExpression(object, property, computed = false, optional) {
      return (0, _validateNode.default)({
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      });
    }
    function optionalCallExpression(callee, _arguments, optional) {
      return (0, _validateNode.default)({
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      });
    }
    function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassAccessorProperty",
        key,
        value,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      });
    }
    function classPrivateProperty(key, value = null, decorators = null, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateProperty",
        key,
        value,
        decorators,
        static: _static
      });
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      return (0, _validateNode.default)({
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      });
    }
    function privateName(id) {
      return (0, _validateNode.default)({
        type: "PrivateName",
        id
      });
    }
    function staticBlock(body) {
      return (0, _validateNode.default)({
        type: "StaticBlock",
        body
      });
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      return (0, _validateNode.default)({
        type: "ArrayTypeAnnotation",
        elementType
      });
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "BooleanLiteralTypeAnnotation",
        value
      });
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "ClassImplements",
        id,
        typeParameters
      });
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareFunction(id) {
      return (0, _validateNode.default)({
        type: "DeclareFunction",
        id
      });
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function declareModule(id, body, kind = null) {
      return (0, _validateNode.default)({
        type: "DeclareModule",
        id,
        body,
        kind
      });
    }
    function declareModuleExports(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      });
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      return (0, _validateNode.default)({
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      });
    }
    function declareVariable(id) {
      return (0, _validateNode.default)({
        type: "DeclareVariable",
        id
      });
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
      return (0, _validateNode.default)({
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source
      });
    }
    function declareExportAllDeclaration(source) {
      return (0, _validateNode.default)({
        type: "DeclareExportAllDeclaration",
        source
      });
    }
    function declaredPredicate(value) {
      return (0, _validateNode.default)({
        type: "DeclaredPredicate",
        value
      });
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      return (0, _validateNode.default)({
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      });
    }
    function functionTypeParam(name = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "FunctionTypeParam",
        name,
        typeAnnotation: typeAnnotation2
      });
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      });
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "InterfaceExtends",
        id,
        typeParameters
      });
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      return (0, _validateNode.default)({
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      });
    }
    function intersectionTypeAnnotation(types17) {
      return (0, _validateNode.default)({
        type: "IntersectionTypeAnnotation",
        types: types17
      });
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function numberLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "NumberLiteralTypeAnnotation",
        value
      });
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      return (0, _validateNode.default)({
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      });
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      return (0, _validateNode.default)({
        type: "ObjectTypeInternalSlot",
        id,
        value,
        optional,
        static: _static,
        method
      });
    }
    function objectTypeCallProperty(value) {
      return (0, _validateNode.default)({
        type: "ObjectTypeCallProperty",
        value,
        static: null
      });
    }
    function objectTypeIndexer(id = null, key, value, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeIndexer",
        id,
        key,
        value,
        variance: variance2,
        static: null
      });
    }
    function objectTypeProperty(key, value, variance2 = null) {
      return (0, _validateNode.default)({
        type: "ObjectTypeProperty",
        key,
        value,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      });
    }
    function objectTypeSpreadProperty(argument) {
      return (0, _validateNode.default)({
        type: "ObjectTypeSpreadProperty",
        argument
      });
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      return (0, _validateNode.default)({
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      });
    }
    function qualifiedTypeIdentifier(id, qualification) {
      return (0, _validateNode.default)({
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      });
    }
    function stringLiteralTypeAnnotation(value) {
      return (0, _validateNode.default)({
        type: "StringLiteralTypeAnnotation",
        value
      });
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types17) {
      return (0, _validateNode.default)({
        type: "TupleTypeAnnotation",
        types: types17
      });
    }
    function typeofTypeAnnotation(argument) {
      return (0, _validateNode.default)({
        type: "TypeofTypeAnnotation",
        argument
      });
    }
    function typeAlias(id, typeParameters = null, right) {
      return (0, _validateNode.default)({
        type: "TypeAlias",
        id,
        typeParameters,
        right
      });
    }
    function typeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function typeCastExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      return (0, _validateNode.default)({
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      });
    }
    function typeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterDeclaration",
        params
      });
    }
    function typeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TypeParameterInstantiation",
        params
      });
    }
    function unionTypeAnnotation(types17) {
      return (0, _validateNode.default)({
        type: "UnionTypeAnnotation",
        types: types17
      });
    }
    function variance(kind) {
      return (0, _validateNode.default)({
        type: "Variance",
        kind
      });
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "EnumDeclaration",
        id,
        body
      });
    }
    function enumBooleanBody(members) {
      return (0, _validateNode.default)({
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumNumberBody(members) {
      return (0, _validateNode.default)({
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumStringBody(members) {
      return (0, _validateNode.default)({
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      });
    }
    function enumSymbolBody(members) {
      return (0, _validateNode.default)({
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      });
    }
    function enumBooleanMember(id) {
      return (0, _validateNode.default)({
        type: "EnumBooleanMember",
        id,
        init: null
      });
    }
    function enumNumberMember(id, init3) {
      return (0, _validateNode.default)({
        type: "EnumNumberMember",
        id,
        init: init3
      });
    }
    function enumStringMember(id, init3) {
      return (0, _validateNode.default)({
        type: "EnumStringMember",
        id,
        init: init3
      });
    }
    function enumDefaultedMember(id) {
      return (0, _validateNode.default)({
        type: "EnumDefaultedMember",
        id
      });
    }
    function indexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "IndexedAccessType",
        objectType,
        indexType
      });
    }
    function optionalIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      });
    }
    function jsxAttribute(name, value = null) {
      return (0, _validateNode.default)({
        type: "JSXAttribute",
        name,
        value
      });
    }
    function jsxClosingElement(name) {
      return (0, _validateNode.default)({
        type: "JSXClosingElement",
        name
      });
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      return (0, _validateNode.default)({
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      });
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      return (0, _validateNode.default)({
        type: "JSXExpressionContainer",
        expression
      });
    }
    function jsxSpreadChild(expression) {
      return (0, _validateNode.default)({
        type: "JSXSpreadChild",
        expression
      });
    }
    function jsxIdentifier(name) {
      return (0, _validateNode.default)({
        type: "JSXIdentifier",
        name
      });
    }
    function jsxMemberExpression(object, property) {
      return (0, _validateNode.default)({
        type: "JSXMemberExpression",
        object,
        property
      });
    }
    function jsxNamespacedName(namespace, name) {
      return (0, _validateNode.default)({
        type: "JSXNamespacedName",
        namespace,
        name
      });
    }
    function jsxOpeningElement(name, attributes, selfClosing = false) {
      return (0, _validateNode.default)({
        type: "JSXOpeningElement",
        name,
        attributes,
        selfClosing
      });
    }
    function jsxSpreadAttribute(argument) {
      return (0, _validateNode.default)({
        type: "JSXSpreadAttribute",
        argument
      });
    }
    function jsxText(value) {
      return (0, _validateNode.default)({
        type: "JSXText",
        value
      });
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      return (0, _validateNode.default)({
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      });
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop2() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name) {
      return (0, _validateNode.default)({
        type: "Placeholder",
        expectedNode,
        name
      });
    }
    function v8IntrinsicIdentifier(name) {
      return (0, _validateNode.default)({
        type: "V8IntrinsicIdentifier",
        name
      });
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      return (0, _validateNode.default)({
        type: "BindExpression",
        object,
        callee
      });
    }
    function importAttribute(key, value) {
      return (0, _validateNode.default)({
        type: "ImportAttribute",
        key,
        value
      });
    }
    function decorator(expression) {
      return (0, _validateNode.default)({
        type: "Decorator",
        expression
      });
    }
    function doExpression(body, async = false) {
      return (0, _validateNode.default)({
        type: "DoExpression",
        body,
        async
      });
    }
    function exportDefaultSpecifier(exported) {
      return (0, _validateNode.default)({
        type: "ExportDefaultSpecifier",
        exported
      });
    }
    function recordExpression(properties) {
      return (0, _validateNode.default)({
        type: "RecordExpression",
        properties
      });
    }
    function tupleExpression(elements = []) {
      return (0, _validateNode.default)({
        type: "TupleExpression",
        elements
      });
    }
    function decimalLiteral(value) {
      return (0, _validateNode.default)({
        type: "DecimalLiteral",
        value
      });
    }
    function moduleExpression(body) {
      return (0, _validateNode.default)({
        type: "ModuleExpression",
        body
      });
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      return (0, _validateNode.default)({
        type: "PipelineTopicExpression",
        expression
      });
    }
    function pipelineBareFunction(callee) {
      return (0, _validateNode.default)({
        type: "PipelineBareFunction",
        callee
      });
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      return (0, _validateNode.default)({
        type: "TSParameterProperty",
        parameter
      });
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      });
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      return (0, _validateNode.default)({
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      });
    }
    function tsQualifiedName(left, right) {
      return (0, _validateNode.default)({
        type: "TSQualifiedName",
        left,
        right
      });
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsPropertySignature(key, typeAnnotation2 = null, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2,
        initializer,
        kind: null
      });
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      });
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      return (0, _validateNode.default)({
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeReference2(typeName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeReference",
        typeName,
        typeParameters
      });
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      return (0, _validateNode.default)({
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      });
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSTypeQuery",
        exprName,
        typeParameters
      });
    }
    function tsTypeLiteral(members) {
      return (0, _validateNode.default)({
        type: "TSTypeLiteral",
        members
      });
    }
    function tsArrayType(elementType) {
      return (0, _validateNode.default)({
        type: "TSArrayType",
        elementType
      });
    }
    function tsTupleType(elementTypes) {
      return (0, _validateNode.default)({
        type: "TSTupleType",
        elementTypes
      });
    }
    function tsOptionalType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsRestType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      return (0, _validateNode.default)({
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      });
    }
    function tsUnionType(types17) {
      return (0, _validateNode.default)({
        type: "TSUnionType",
        types: types17
      });
    }
    function tsIntersectionType(types17) {
      return (0, _validateNode.default)({
        type: "TSIntersectionType",
        types: types17
      });
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return (0, _validateNode.default)({
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      });
    }
    function tsInferType(typeParameter2) {
      return (0, _validateNode.default)({
        type: "TSInferType",
        typeParameter: typeParameter2
      });
    }
    function tsParenthesizedType(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeOperator(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      });
    }
    function tsIndexedAccessType(objectType, indexType) {
      return (0, _validateNode.default)({
        type: "TSIndexedAccessType",
        objectType,
        indexType
      });
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      return (0, _validateNode.default)({
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      });
    }
    function tsLiteralType(literal) {
      return (0, _validateNode.default)({
        type: "TSLiteralType",
        literal
      });
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      });
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      });
    }
    function tsInterfaceBody(body) {
      return (0, _validateNode.default)({
        type: "TSInterfaceBody",
        body
      });
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      });
    }
    function tsAsExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      return (0, _validateNode.default)({
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      });
    }
    function tsEnumDeclaration(id, members) {
      return (0, _validateNode.default)({
        type: "TSEnumDeclaration",
        id,
        members
      });
    }
    function tsEnumMember(id, initializer = null) {
      return (0, _validateNode.default)({
        type: "TSEnumMember",
        id,
        initializer
      });
    }
    function tsModuleDeclaration(id, body) {
      return (0, _validateNode.default)({
        type: "TSModuleDeclaration",
        id,
        body
      });
    }
    function tsModuleBlock(body) {
      return (0, _validateNode.default)({
        type: "TSModuleBlock",
        body
      });
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      return (0, _validateNode.default)({
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      });
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      return (0, _validateNode.default)({
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      });
    }
    function tsExternalModuleReference(expression) {
      return (0, _validateNode.default)({
        type: "TSExternalModuleReference",
        expression
      });
    }
    function tsNonNullExpression(expression) {
      return (0, _validateNode.default)({
        type: "TSNonNullExpression",
        expression
      });
    }
    function tsExportAssignment(expression) {
      return (0, _validateNode.default)({
        type: "TSExportAssignment",
        expression
      });
    }
    function tsNamespaceExportDeclaration(id) {
      return (0, _validateNode.default)({
        type: "TSNamespaceExportDeclaration",
        id
      });
    }
    function tsTypeAnnotation(typeAnnotation2) {
      return (0, _validateNode.default)({
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      });
    }
    function tsTypeParameterInstantiation(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterInstantiation",
        params
      });
    }
    function tsTypeParameterDeclaration(params) {
      return (0, _validateNode.default)({
        type: "TSTypeParameterDeclaration",
        params
      });
    }
    function tsTypeParameter(constraint = null, _default = null, name) {
      return (0, _validateNode.default)({
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name
      });
    }
    function NumberLiteral(value) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value);
    }
    function RegexLiteral(pattern, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cleanJSXElementLiteralChild;
    var _generated = require_generated2();
    var _3 = require_lib6();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i2 = 0; i2 < lines.length; i2++) {
        if (lines[i2].match(/[^ \t]/)) {
          lastNonEmptyLine = i2;
        }
      }
      let str = "";
      for (let i2 = 0; i2 < lines.length; i2++) {
        const line = lines[i2];
        const isFirstLine = i2 === 0;
        const isLastLine = i2 === lines.length - 1;
        const isLastNonEmptyLine = i2 === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push((0, _3.inherits)((0, _generated.stringLiteral)(str), child));
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildChildren;
    var _generated = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      const elements = [];
      for (let i2 = 0; i2 < node.children.length; i2++) {
        let child = node.children[i2];
        if ((0, _generated.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child))
          child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child))
          continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNode;
    var _definitions = require_definitions();
    function isNode(node) {
      return !!(node && _definitions.VISITOR_KEYS[node.type]);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertAccessor = assertAccessor;
    exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports.assertArrayExpression = assertArrayExpression;
    exports.assertArrayPattern = assertArrayPattern;
    exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports.assertAssignmentExpression = assertAssignmentExpression;
    exports.assertAssignmentPattern = assertAssignmentPattern;
    exports.assertAwaitExpression = assertAwaitExpression;
    exports.assertBigIntLiteral = assertBigIntLiteral;
    exports.assertBinary = assertBinary;
    exports.assertBinaryExpression = assertBinaryExpression;
    exports.assertBindExpression = assertBindExpression;
    exports.assertBlock = assertBlock;
    exports.assertBlockParent = assertBlockParent;
    exports.assertBlockStatement = assertBlockStatement;
    exports.assertBooleanLiteral = assertBooleanLiteral;
    exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports.assertBreakStatement = assertBreakStatement;
    exports.assertCallExpression = assertCallExpression;
    exports.assertCatchClause = assertCatchClause;
    exports.assertClass = assertClass;
    exports.assertClassAccessorProperty = assertClassAccessorProperty;
    exports.assertClassBody = assertClassBody;
    exports.assertClassDeclaration = assertClassDeclaration;
    exports.assertClassExpression = assertClassExpression;
    exports.assertClassImplements = assertClassImplements;
    exports.assertClassMethod = assertClassMethod;
    exports.assertClassPrivateMethod = assertClassPrivateMethod;
    exports.assertClassPrivateProperty = assertClassPrivateProperty;
    exports.assertClassProperty = assertClassProperty;
    exports.assertCompletionStatement = assertCompletionStatement;
    exports.assertConditional = assertConditional;
    exports.assertConditionalExpression = assertConditionalExpression;
    exports.assertContinueStatement = assertContinueStatement;
    exports.assertDebuggerStatement = assertDebuggerStatement;
    exports.assertDecimalLiteral = assertDecimalLiteral;
    exports.assertDeclaration = assertDeclaration;
    exports.assertDeclareClass = assertDeclareClass;
    exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports.assertDeclareFunction = assertDeclareFunction;
    exports.assertDeclareInterface = assertDeclareInterface;
    exports.assertDeclareModule = assertDeclareModule;
    exports.assertDeclareModuleExports = assertDeclareModuleExports;
    exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports.assertDeclareVariable = assertDeclareVariable;
    exports.assertDeclaredPredicate = assertDeclaredPredicate;
    exports.assertDecorator = assertDecorator;
    exports.assertDirective = assertDirective;
    exports.assertDirectiveLiteral = assertDirectiveLiteral;
    exports.assertDoExpression = assertDoExpression;
    exports.assertDoWhileStatement = assertDoWhileStatement;
    exports.assertEmptyStatement = assertEmptyStatement;
    exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports.assertEnumBody = assertEnumBody;
    exports.assertEnumBooleanBody = assertEnumBooleanBody;
    exports.assertEnumBooleanMember = assertEnumBooleanMember;
    exports.assertEnumDeclaration = assertEnumDeclaration;
    exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports.assertEnumMember = assertEnumMember;
    exports.assertEnumNumberBody = assertEnumNumberBody;
    exports.assertEnumNumberMember = assertEnumNumberMember;
    exports.assertEnumStringBody = assertEnumStringBody;
    exports.assertEnumStringMember = assertEnumStringMember;
    exports.assertEnumSymbolBody = assertEnumSymbolBody;
    exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports.assertExportAllDeclaration = assertExportAllDeclaration;
    exports.assertExportDeclaration = assertExportDeclaration;
    exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports.assertExportSpecifier = assertExportSpecifier;
    exports.assertExpression = assertExpression;
    exports.assertExpressionStatement = assertExpressionStatement;
    exports.assertExpressionWrapper = assertExpressionWrapper;
    exports.assertFile = assertFile;
    exports.assertFlow = assertFlow;
    exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports.assertFlowDeclaration = assertFlowDeclaration;
    exports.assertFlowPredicate = assertFlowPredicate;
    exports.assertFlowType = assertFlowType;
    exports.assertFor = assertFor;
    exports.assertForInStatement = assertForInStatement;
    exports.assertForOfStatement = assertForOfStatement;
    exports.assertForStatement = assertForStatement;
    exports.assertForXStatement = assertForXStatement;
    exports.assertFunction = assertFunction;
    exports.assertFunctionDeclaration = assertFunctionDeclaration;
    exports.assertFunctionExpression = assertFunctionExpression;
    exports.assertFunctionParent = assertFunctionParent;
    exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports.assertFunctionTypeParam = assertFunctionTypeParam;
    exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports.assertIdentifier = assertIdentifier;
    exports.assertIfStatement = assertIfStatement;
    exports.assertImmutable = assertImmutable;
    exports.assertImport = assertImport;
    exports.assertImportAttribute = assertImportAttribute;
    exports.assertImportDeclaration = assertImportDeclaration;
    exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports.assertImportSpecifier = assertImportSpecifier;
    exports.assertIndexedAccessType = assertIndexedAccessType;
    exports.assertInferredPredicate = assertInferredPredicate;
    exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports.assertInterfaceExtends = assertInterfaceExtends;
    exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports.assertInterpreterDirective = assertInterpreterDirective;
    exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports.assertJSX = assertJSX;
    exports.assertJSXAttribute = assertJSXAttribute;
    exports.assertJSXClosingElement = assertJSXClosingElement;
    exports.assertJSXClosingFragment = assertJSXClosingFragment;
    exports.assertJSXElement = assertJSXElement;
    exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports.assertJSXFragment = assertJSXFragment;
    exports.assertJSXIdentifier = assertJSXIdentifier;
    exports.assertJSXMemberExpression = assertJSXMemberExpression;
    exports.assertJSXNamespacedName = assertJSXNamespacedName;
    exports.assertJSXOpeningElement = assertJSXOpeningElement;
    exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports.assertJSXSpreadChild = assertJSXSpreadChild;
    exports.assertJSXText = assertJSXText;
    exports.assertLVal = assertLVal;
    exports.assertLabeledStatement = assertLabeledStatement;
    exports.assertLiteral = assertLiteral;
    exports.assertLogicalExpression = assertLogicalExpression;
    exports.assertLoop = assertLoop;
    exports.assertMemberExpression = assertMemberExpression;
    exports.assertMetaProperty = assertMetaProperty;
    exports.assertMethod = assertMethod;
    exports.assertMiscellaneous = assertMiscellaneous;
    exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports.assertModuleDeclaration = assertModuleDeclaration;
    exports.assertModuleExpression = assertModuleExpression;
    exports.assertModuleSpecifier = assertModuleSpecifier;
    exports.assertNewExpression = assertNewExpression;
    exports.assertNoop = assertNoop;
    exports.assertNullLiteral = assertNullLiteral;
    exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports.assertNumberLiteral = assertNumberLiteral;
    exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports.assertNumericLiteral = assertNumericLiteral;
    exports.assertObjectExpression = assertObjectExpression;
    exports.assertObjectMember = assertObjectMember;
    exports.assertObjectMethod = assertObjectMethod;
    exports.assertObjectPattern = assertObjectPattern;
    exports.assertObjectProperty = assertObjectProperty;
    exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports.assertObjectTypeProperty = assertObjectTypeProperty;
    exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports.assertOpaqueType = assertOpaqueType;
    exports.assertOptionalCallExpression = assertOptionalCallExpression;
    exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports.assertParenthesizedExpression = assertParenthesizedExpression;
    exports.assertPattern = assertPattern;
    exports.assertPatternLike = assertPatternLike;
    exports.assertPipelineBareFunction = assertPipelineBareFunction;
    exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports.assertPlaceholder = assertPlaceholder;
    exports.assertPrivate = assertPrivate;
    exports.assertPrivateName = assertPrivateName;
    exports.assertProgram = assertProgram;
    exports.assertProperty = assertProperty;
    exports.assertPureish = assertPureish;
    exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports.assertRecordExpression = assertRecordExpression;
    exports.assertRegExpLiteral = assertRegExpLiteral;
    exports.assertRegexLiteral = assertRegexLiteral;
    exports.assertRestElement = assertRestElement;
    exports.assertRestProperty = assertRestProperty;
    exports.assertReturnStatement = assertReturnStatement;
    exports.assertScopable = assertScopable;
    exports.assertSequenceExpression = assertSequenceExpression;
    exports.assertSpreadElement = assertSpreadElement;
    exports.assertSpreadProperty = assertSpreadProperty;
    exports.assertStandardized = assertStandardized;
    exports.assertStatement = assertStatement;
    exports.assertStaticBlock = assertStaticBlock;
    exports.assertStringLiteral = assertStringLiteral;
    exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports.assertSuper = assertSuper;
    exports.assertSwitchCase = assertSwitchCase;
    exports.assertSwitchStatement = assertSwitchStatement;
    exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports.assertTSAnyKeyword = assertTSAnyKeyword;
    exports.assertTSArrayType = assertTSArrayType;
    exports.assertTSAsExpression = assertTSAsExpression;
    exports.assertTSBaseType = assertTSBaseType;
    exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports.assertTSConditionalType = assertTSConditionalType;
    exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports.assertTSConstructorType = assertTSConstructorType;
    exports.assertTSDeclareFunction = assertTSDeclareFunction;
    exports.assertTSDeclareMethod = assertTSDeclareMethod;
    exports.assertTSEntityName = assertTSEntityName;
    exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports.assertTSEnumMember = assertTSEnumMember;
    exports.assertTSExportAssignment = assertTSExportAssignment;
    exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports.assertTSFunctionType = assertTSFunctionType;
    exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports.assertTSImportType = assertTSImportType;
    exports.assertTSIndexSignature = assertTSIndexSignature;
    exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports.assertTSInferType = assertTSInferType;
    exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports.assertTSInterfaceBody = assertTSInterfaceBody;
    exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports.assertTSIntersectionType = assertTSIntersectionType;
    exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports.assertTSLiteralType = assertTSLiteralType;
    exports.assertTSMappedType = assertTSMappedType;
    exports.assertTSMethodSignature = assertTSMethodSignature;
    exports.assertTSModuleBlock = assertTSModuleBlock;
    exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports.assertTSNeverKeyword = assertTSNeverKeyword;
    exports.assertTSNonNullExpression = assertTSNonNullExpression;
    exports.assertTSNullKeyword = assertTSNullKeyword;
    exports.assertTSNumberKeyword = assertTSNumberKeyword;
    exports.assertTSObjectKeyword = assertTSObjectKeyword;
    exports.assertTSOptionalType = assertTSOptionalType;
    exports.assertTSParameterProperty = assertTSParameterProperty;
    exports.assertTSParenthesizedType = assertTSParenthesizedType;
    exports.assertTSPropertySignature = assertTSPropertySignature;
    exports.assertTSQualifiedName = assertTSQualifiedName;
    exports.assertTSRestType = assertTSRestType;
    exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports.assertTSStringKeyword = assertTSStringKeyword;
    exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports.assertTSThisType = assertTSThisType;
    exports.assertTSTupleType = assertTSTupleType;
    exports.assertTSType = assertTSType;
    exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports.assertTSTypeAssertion = assertTSTypeAssertion;
    exports.assertTSTypeElement = assertTSTypeElement;
    exports.assertTSTypeLiteral = assertTSTypeLiteral;
    exports.assertTSTypeOperator = assertTSTypeOperator;
    exports.assertTSTypeParameter = assertTSTypeParameter;
    exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports.assertTSTypePredicate = assertTSTypePredicate;
    exports.assertTSTypeQuery = assertTSTypeQuery;
    exports.assertTSTypeReference = assertTSTypeReference;
    exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports.assertTSUnionType = assertTSUnionType;
    exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports.assertTSVoidKeyword = assertTSVoidKeyword;
    exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports.assertTemplateElement = assertTemplateElement;
    exports.assertTemplateLiteral = assertTemplateLiteral;
    exports.assertTerminatorless = assertTerminatorless;
    exports.assertThisExpression = assertThisExpression;
    exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports.assertThrowStatement = assertThrowStatement;
    exports.assertTopicReference = assertTopicReference;
    exports.assertTryStatement = assertTryStatement;
    exports.assertTupleExpression = assertTupleExpression;
    exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports.assertTypeAlias = assertTypeAlias;
    exports.assertTypeAnnotation = assertTypeAnnotation;
    exports.assertTypeCastExpression = assertTypeCastExpression;
    exports.assertTypeParameter = assertTypeParameter;
    exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports.assertTypeScript = assertTypeScript;
    exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports.assertUnaryExpression = assertUnaryExpression;
    exports.assertUnaryLike = assertUnaryLike;
    exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports.assertUpdateExpression = assertUpdateExpression;
    exports.assertUserWhitespacable = assertUserWhitespacable;
    exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports.assertVariableDeclaration = assertVariableDeclaration;
    exports.assertVariableDeclarator = assertVariableDeclarator;
    exports.assertVariance = assertVariance;
    exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports.assertWhile = assertWhile;
    exports.assertWhileStatement = assertWhileStatement;
    exports.assertWithStatement = assertWithStatement;
    exports.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert(type, node, opts) {
      if (!(0, _is.default)(type, node, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert("ModuleDeclaration", node, opts);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _generated = require_generated2();
    var _default = createTypeAnnotationBasedOnTypeof;
    exports.default = _default;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _generated.stringTypeAnnotation)();
        case "number":
          return (0, _generated.numberTypeAnnotation)();
        case "undefined":
          return (0, _generated.voidTypeAnnotation)();
        case "boolean":
          return (0, _generated.booleanTypeAnnotation)();
        case "function":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
        case "object":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
        case "symbol":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
        case "bigint":
          return (0, _generated.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _generated = require_generated();
    function getQualifiedName(node) {
      return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types17 = [];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if (!node)
          continue;
        if (types17.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _generated.isAnyTypeAnnotation)(node)) {
          return [node];
        }
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
          const name = getQualifiedName(node.id);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params.push(...node.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types17.push(node);
      }
      for (const [, baseType] of bases) {
        types17.push(baseType);
      }
      for (const [, genericName] of generics) {
        types17.push(genericName);
      }
      return types17;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createFlowUnionType;
    var _generated = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types17) {
      const flattened = (0, _removeTypeDuplicates.default)(types17);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _generated.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeTypeDuplicates;
    var _generated = require_generated();
    function getQualifiedName(node) {
      return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types17 = [];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if (!node)
          continue;
        if (types17.indexOf(node) >= 0) {
          continue;
        }
        if ((0, _generated.isTSAnyKeyword)(node)) {
          return [node];
        }
        if ((0, _generated.isTSBaseType)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
          if (!typeGroups.has(node.types)) {
            nodes.push(...node.types);
            typeGroups.add(node.types);
          }
          continue;
        }
        if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
          const name = getQualifiedName(node.typeName);
          if (generics.has(name)) {
            let existing = generics.get(name);
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params.push(...node.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics.set(name, node);
          }
          continue;
        }
        types17.push(node);
      }
      for (const [, baseType] of bases) {
        types17.push(baseType);
      }
      for (const [, genericName] of generics) {
        types17.push(genericName);
      }
      return types17;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createTSUnionType;
    var _generated = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types17 = typeAnnotations.map((type) => {
        return (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types17);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _generated.tsUnionType)(flattened);
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _index.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _index.arrayExpression;
      }
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _index.arrayPattern;
      }
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _index.assignmentExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _index.assignmentPattern;
      }
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _index.awaitExpression;
      }
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _index.bigIntLiteral;
      }
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _index.binaryExpression;
      }
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function() {
        return _index.bindExpression;
      }
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _index.blockStatement;
      }
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteral;
      }
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _index.breakStatement;
      }
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function() {
        return _index.callExpression;
      }
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function() {
        return _index.catchClause;
      }
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return _index.classAccessorProperty;
      }
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function() {
        return _index.classBody;
      }
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _index.classDeclaration;
      }
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _index.classExpression;
      }
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _index.classImplements;
      }
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _index.classMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _index.classPrivateMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _index.classPrivateProperty;
      }
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _index.classProperty;
      }
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _index.conditionalExpression;
      }
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _index.continueStatement;
      }
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _index.debuggerStatement;
      }
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _index.decimalLiteral;
      }
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _index.declareClass;
      }
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.declareFunction;
      }
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _index.declareInterface;
      }
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _index.declareModule;
      }
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _index.declareModuleExports;
      }
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _index.declareOpaqueType;
      }
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _index.declareTypeAlias;
      }
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _index.declareVariable;
      }
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _index.declaredPredicate;
      }
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function() {
        return _index.decorator;
      }
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function() {
        return _index.directive;
      }
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _index.directiveLiteral;
      }
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function() {
        return _index.doExpression;
      }
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _index.doWhileStatement;
      }
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _index.emptyStatement;
      }
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanBody;
      }
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _index.enumBooleanMember;
      }
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.enumDeclaration;
      }
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _index.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _index.enumNumberBody;
      }
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _index.enumNumberMember;
      }
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _index.enumStringBody;
      }
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _index.enumStringMember;
      }
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _index.enumSymbolBody;
      }
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _index.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.exportSpecifier;
      }
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _index.expressionStatement;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function() {
        return _index.file;
      }
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _index.forInStatement;
      }
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _index.forOfStatement;
      }
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function() {
        return _index.forStatement;
      }
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _index.functionDeclaration;
      }
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _index.functionExpression;
      }
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _index.functionTypeParam;
      }
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function() {
        return _index.identifier;
      }
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function() {
        return _index.ifStatement;
      }
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function() {
        return _index.import;
      }
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _index.importAttribute;
      }
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.importDeclaration;
      }
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _index.importSpecifier;
      }
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.indexedAccessType;
      }
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _index.inferredPredicate;
      }
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _index.interfaceExtends;
      }
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _index.interpreterDirective;
      }
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxAttribute;
      }
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingElement;
      }
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function() {
        return _index.jsxElement;
      }
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _index.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxFragment;
      }
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _index.jsxIdentifier;
      }
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _index.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _index.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _index.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function() {
        return _index.jsxText;
      }
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _index.labeledStatement;
      }
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _index.logicalExpression;
      }
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _index.memberExpression;
      }
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _index.metaProperty;
      }
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _index.moduleExpression;
      }
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function() {
        return _index.newExpression;
      }
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function() {
        return _index.noop;
      }
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _index.nullLiteral;
      }
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _index.numberLiteral;
      }
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _index.numericLiteral;
      }
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _index.objectExpression;
      }
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _index.objectMethod;
      }
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _index.objectPattern;
      }
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _index.objectProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _index.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _index.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _index.opaqueType;
      }
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalCallExpression;
      }
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _index.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _index.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _index.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _index.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _index.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function() {
        return _index.placeholder;
      }
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function() {
        return _index.privateName;
      }
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function() {
        return _index.program;
      }
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _index.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _index.recordExpression;
      }
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _index.regExpLiteral;
      }
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _index.regexLiteral;
      }
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function() {
        return _index.restElement;
      }
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function() {
        return _index.restProperty;
      }
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _index.returnStatement;
      }
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _index.sequenceExpression;
      }
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _index.spreadElement;
      }
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _index.spreadProperty;
      }
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _index.staticBlock;
      }
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _index.stringLiteral;
      }
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function() {
        return _index.super;
      }
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _index.switchCase;
      }
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _index.switchStatement;
      }
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _index.tsArrayType;
      }
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _index.tsAsExpression;
      }
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _index.tsConditionalType;
      }
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _index.tsConstructorType;
      }
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _index.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _index.tsEnumMember;
      }
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _index.tsExportAssignment;
      }
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _index.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _index.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _index.tsFunctionType;
      }
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function() {
        return _index.tsImportType;
      }
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _index.tsIndexSignature;
      }
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _index.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function() {
        return _index.tsInferType;
      }
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return _index.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _index.tsIntersectionType;
      }
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _index.tsLiteralType;
      }
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _index.tsMappedType;
      }
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _index.tsMethodSignature;
      }
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _index.tsModuleBlock;
      }
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _index.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _index.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNullKeyword;
      }
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _index.tsOptionalType;
      }
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _index.tsParameterProperty;
      }
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _index.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _index.tsPropertySignature;
      }
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _index.tsQualifiedName;
      }
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function() {
        return _index.tsRestType;
      }
    });
    Object.defineProperty(exports, "TSSatisfiesExpression", {
      enumerable: true,
      get: function() {
        return _index.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsStringKeyword;
      }
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function() {
        return _index.tsThisType;
      }
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _index.tsTupleType;
      }
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _index.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _index.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _index.tsTypeOperator;
      }
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameter;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _index.tsTypePredicate;
      }
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _index.tsTypeQuery;
      }
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _index.tsTypeReference;
      }
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _index.tsUnionType;
      }
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _index.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _index.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _index.templateElement;
      }
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _index.templateLiteral;
      }
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _index.thisExpression;
      }
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _index.throwStatement;
      }
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function() {
        return _index.topicReference;
      }
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function() {
        return _index.tryStatement;
      }
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _index.tupleExpression;
      }
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _index.typeAlias;
      }
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _index.typeCastExpression;
      }
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _index.typeParameter;
      }
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _index.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _index.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _index.unaryExpression;
      }
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _index.updateExpression;
      }
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _index.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _index.variableDeclaration;
      }
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _index.variableDeclarator;
      }
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function() {
        return _index.variance;
      }
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _index.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _index.whileStatement;
      }
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function() {
        return _index.withStatement;
      }
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _index.yieldExpression;
      }
    });
    var _index = require_generated2();
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneNode;
    var _definitions = require_definitions();
    var _generated = require_generated();
    var has = Function.call.bind(Object.prototype.hasOwnProperty);
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node, deep = true, withoutLoc = false) {
      return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
      if (!node)
        return node;
      const {
        type
      } = node;
      const newNode = {
        type: node.type
      };
      if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (has(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
        }
      } else if (!has(_definitions.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
          if (has(node, field)) {
            if (deep) {
              newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (has(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (has(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
      }
      if (has(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
      }
      if (has(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map((comment) => {
        const cache = commentsCache.get(comment);
        if (cache)
          return cache;
        const {
          type,
          value,
          loc
        } = comment;
        const ret = {
          type,
          value,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment, ret);
        return ret;
      });
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/clone.js
var require_clone2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clone2;
    var _cloneNode = require_cloneNode();
    function clone2(node) {
      return (0, _cloneNode.default)(node, false);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, true, true);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, false, true);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/addComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node)
        return node;
      const key = `${type}Comments`;
      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          node[key].push(...comments);
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/addComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addComment;
    var _addComments = require_addComments();
    function addComment(node, type, content, line) {
      return (0, _addComments.default)(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/utils/inherit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherit;
    function inherit(key, child, parent2) {
      if (child && parent2) {
        child[key] = Array.from(new Set([].concat(child[key], parent2[key]).filter(Boolean)));
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent2) {
      (0, _inherit.default)("innerComments", child, parent2);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent2) {
      (0, _inherit.default)("leadingComments", child, parent2);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent2) {
      (0, _inherit.default)("trailingComments", child, parent2);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent2) {
      (0, _inheritTrailingComments.default)(child, parent2);
      (0, _inheritLeadingComments.default)(child, parent2);
      (0, _inheritInnerComments.default)(child, parent2);
      return child;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeComments;
    var _constants = require_constants2();
    function removeComments(node) {
      _constants.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      });
      return node;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
    var _definitions = require_definitions();
    var STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
    exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
    var EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
    exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
    var BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
    exports.BINARY_TYPES = BINARY_TYPES;
    var SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
    exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
    var BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
    exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
    var BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
    exports.BLOCK_TYPES = BLOCK_TYPES;
    var STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
    exports.STATEMENT_TYPES = STATEMENT_TYPES;
    var TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
    exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
    var COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
    var CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
    exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
    var LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
    exports.LOOP_TYPES = LOOP_TYPES;
    var WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
    exports.WHILE_TYPES = WHILE_TYPES;
    var EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
    var FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
    exports.FOR_TYPES = FOR_TYPES;
    var FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
    exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
    var FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
    exports.FUNCTION_TYPES = FUNCTION_TYPES;
    var FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
    exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
    var PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
    exports.PUREISH_TYPES = PUREISH_TYPES;
    var DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
    exports.DECLARATION_TYPES = DECLARATION_TYPES;
    var PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
    exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
    var LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
    exports.LVAL_TYPES = LVAL_TYPES;
    var TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
    exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
    var LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
    exports.LITERAL_TYPES = LITERAL_TYPES;
    var IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
    exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
    var USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
    var METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
    exports.METHOD_TYPES = METHOD_TYPES;
    var OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
    exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
    var PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
    exports.PROPERTY_TYPES = PROPERTY_TYPES;
    var UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
    exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
    var PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
    exports.PATTERN_TYPES = PATTERN_TYPES;
    var CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
    exports.CLASS_TYPES = CLASS_TYPES;
    var IMPORTOREXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    exports.IMPORTOREXPORTDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    var EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
    var MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
    var ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Accessor"];
    exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
    var PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
    exports.PRIVATE_TYPES = PRIVATE_TYPES;
    var FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
    exports.FLOW_TYPES = FLOW_TYPES;
    var FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
    exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
    var FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
    var FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
    var FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
    var ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
    exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
    var ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
    exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
    var JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
    exports.JSX_TYPES = JSX_TYPES;
    var MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
    var TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
    exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
    var TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
    var TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
    exports.TSTYPE_TYPES = TSTYPE_TYPES;
    var TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
    exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBlock;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    function toBlock(node, parent2) {
      if ((0, _generated.isBlockStatement)(node)) {
        return node;
      }
      let blockNodes = [];
      if ((0, _generated.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _generated.isStatement)(node)) {
          if ((0, _generated.isFunction)(parent2)) {
            node = (0, _generated2.returnStatement)(node);
          } else {
            node = (0, _generated2.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _generated2.blockStatement)(blockNodes);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      const result = (0, _toBlock.default)(node[key], node);
      node[key] = result;
      return result;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib4();
    function toIdentifier(input) {
      input = input + "";
      let name = "";
      for (const c2 of input) {
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c2.codePointAt(0)) ? c2 : "-";
      }
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function(match, c2) {
        return c2 ? c2.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name)) {
        name = `_${name}`;
      }
      return name || "_";
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name) {
      name = (0, _toIdentifier.default)(name);
      if (name === "eval" || name === "arguments")
        name = "_" + name;
      return name;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toComputedKey;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      if (!node.computed && (0, _generated.isIdentifier)(key))
        key = (0, _generated2.stringLiteral)(key.name);
      return key;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _generated = require_generated();
    var _default = toExpression;
    exports.default = _default;
    function toExpression(node) {
      if ((0, _generated.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _generated.isExpression)(node)) {
        return node;
      }
      if ((0, _generated.isClass)(node)) {
        node.type = "ClassExpression";
      } else if ((0, _generated.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _generated.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }
      return node;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverseFast;
    var _definitions = require_definitions();
    function traverseFast(node, enter, opts) {
      if (!node)
        return;
      const keys2 = _definitions.VISITOR_KEYS[node.type];
      if (!keys2)
        return;
      opts = opts || {};
      enter(node, opts);
      for (const key of keys2) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (const node2 of subNode) {
            traverseFast(node2, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removeProperties;
    var _constants = require_constants2();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._constants.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node, opts = {}) {
      const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map) {
        if (node[key] != null)
          node[key] = void 0;
      }
      for (const key of Object.keys(node)) {
        if (key[0] === "_" && node[key] != null)
          node[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node);
      for (const sym of symbols) {
        node[sym] = null;
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toKeyAlias;
    var _generated = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _generated.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _generated.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node.computed) {
        alias = `[${alias}]`;
      }
      if (node.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getBindingIdentifiers;
    var _generated = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly) {
      const search = [].concat(node);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id)
          continue;
        const keys2 = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
          if (duplicates) {
            const _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
          if ((0, _generated.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _generated.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _generated.isFunctionExpression)(id)) {
            continue;
          }
        }
        if (keys2) {
          for (let i2 = 0; i2 < keys2.length; i2++) {
            const key = keys2[i2];
            const nodes = id[key];
            if (nodes) {
              Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
            }
          }
        }
      }
      return ids;
    }
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _generated = require_generated();
    var _generated2 = require_generated2();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, scope, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!(0, _generated.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _generated.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _generated.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _generated.isVariableDeclaration)(node)) {
          if (node.kind !== "var")
            return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return;
          exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body)
            return;
          exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _generated2.sequenceExpression)(exprs);
      }
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length))
        return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
      if (!result)
        return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _generated = require_generated();
    var _generated2 = require_generated2();
    var _default = toStatement;
    exports.default = _default;
    function toStatement(node, ignore) {
      if ((0, _generated.isStatement)(node)) {
        return node;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _generated.isAssignmentExpression)(node)) {
        return (0, _generated2.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }
      node.type = newType;
      return node;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _generated = require_generated2();
    var _default = valueToNode;
    exports.default = _default;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === void 0) {
        return (0, _generated.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _generated.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _generated.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _generated.stringLiteral)(value);
      }
      if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) {
          result = (0, _generated.numericLiteral)(Math.abs(value));
        } else {
          let numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _generated.numericLiteral)(0);
          } else {
            numerator = (0, _generated.numericLiteral)(1);
          }
          result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _generated.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _generated.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _generated.identifier)(key);
          } else {
            nodeKey = (0, _generated.stringLiteral)(key);
          }
          props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = appendToMemberExpression;
    var _generated = require_generated2();
    function appendToMemberExpression(member, append, computed = false) {
      member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits2 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inherits;
    var _constants = require_constants2();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent2) {
      if (!child || !parent2)
        return child;
      for (const key of _constants.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent2[key];
        }
      }
      for (const key of Object.keys(parent2)) {
        if (key[0] === "_" && key !== "__clone") {
          child[key] = parent2[key];
        }
      }
      for (const key of _constants.INHERIT_KEYS.force) {
        child[key] = parent2[key];
      }
      (0, _inheritsComments.default)(child, parent2);
      return child;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prependToMemberExpression;
    var _generated = require_generated2();
    var _3 = require_lib6();
    function prependToMemberExpression(member, prepend) {
      if ((0, _3.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _generated.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = getOuterBindingIdentifiers;
    exports.default = _default;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = traverse;
    var _definitions = require_definitions();
    function traverse(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys2 = _definitions.VISITOR_KEYS[node.type];
      if (!keys2)
        return;
      if (enter)
        enter(node, ancestors, state);
      for (const key of keys2) {
        const subNode = node[key];
        if (Array.isArray(subNode)) {
          for (let i2 = 0; i2 < subNode.length; i2++) {
            const child = subNode[i2];
            if (!child)
              continue;
            ancestors.push({
              node,
              key,
              index: i2
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit)
        exit(node, ancestors, state);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent2, grandparent) {
      if (grandparent && node.type === "Identifier" && parent2.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys2 = _getBindingIdentifiers.default.keys[parent2.type];
      if (keys2) {
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key = keys2[i2];
          const val = parent2[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0)
              return true;
          } else {
            if (val === node)
              return true;
          }
        }
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isLet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLet;
    var _generated = require_generated();
    var _constants = require_constants2();
    function isLet(node) {
      return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBlockScoped;
    var _generated = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isImmutable;
    var _isType = require_isType();
    var _generated = require_generated();
    function isImmutable(node) {
      if ((0, _isType.default)(node.type, "Immutable"))
        return true;
      if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNodesEquivalent;
    var _definitions = require_definitions();
    function isNodesEquivalent(a2, b2) {
      if (typeof a2 !== "object" || typeof b2 !== "object" || a2 == null || b2 == null) {
        return a2 === b2;
      }
      if (a2.type !== b2.type) {
        return false;
      }
      const fields = Object.keys(_definitions.NODE_FIELDS[a2.type] || a2.type);
      const visitorKeys = _definitions.VISITOR_KEYS[a2.type];
      for (const field of fields) {
        const val_a = a2[field];
        const val_b = b2[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i2 = 0; i2 < val_a.length; i2++) {
            if (!isNodesEquivalent(val_a[i2], val_b[i2])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isReferenced;
    function isReferenced(node, parent2, grandparent) {
      switch (parent2.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent2.property === node) {
            return !!parent2.computed;
          }
          return parent2.object === node;
        case "JSXMemberExpression":
          return parent2.object === node;
        case "VariableDeclarator":
          return parent2.init === node;
        case "ArrowFunctionExpression":
          return parent2.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent2.key === node) {
            return !!parent2.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent2.key === node) {
            return !!parent2.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent2.key === node) {
            return !!parent2.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent2.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent2.superClass === node;
        case "AssignmentExpression":
          return parent2.right === node;
        case "AssignmentPattern":
          return parent2.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent2.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent2.key !== node;
        case "TSEnumMember":
          return parent2.id !== node;
        case "TSPropertySignature":
          if (parent2.key === node) {
            return !!parent2.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isScope;
    var _generated = require_generated();
    function isScope(node, parent2) {
      if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent2) || (0, _generated.isCatchClause)(parent2))) {
        return false;
      }
      if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent2) || (0, _generated.isCatchClause)(parent2))) {
        return true;
      }
      return (0, _generated.isScopable)(node);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSpecifierDefault;
    var _generated = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/validators/isVar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVar;
    var _generated = require_generated();
    var _constants = require_constants2();
    function isVar(node) {
      return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// ../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/.pnpm/@babel+types@7.21.5/node_modules/@babel/types/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports, "toSequenceExpression", {
      enumerable: true,
      get: function() {
        return _toSequenceExpression.default;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _generated = require_generated3();
    Object.keys(_generated).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _generated2 = require_generated2();
    Object.keys(_generated2).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated2[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated2[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _uppercase[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone2();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _generated3 = require_generated4();
    Object.keys(_generated3).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated3[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated3[key];
        }
      });
    });
    var _constants = require_constants2();
    Object.keys(_constants).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _constants[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _constants[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toSequenceExpression = require_toSequenceExpression();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _definitions = require_definitions();
    Object.keys(_definitions).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _definitions[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _definitions[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits = require_inherits2();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _traverse[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _generated4 = require_generated();
    Object.keys(_generated4).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _generated4[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generated4[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    exports.react = react;
  }
});

// ../../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports, module2) {
    "use strict";
    var ESC = "\x1B";
    var CSI = `${ESC}[`;
    var beep = "\x07";
    var cursor = {
      to(x3, y3) {
        if (!y3)
          return `${CSI}${x3 + 1}G`;
        return `${CSI}${y3 + 1};${x3 + 1}H`;
      },
      move(x3, y3) {
        let ret = "";
        if (x3 < 0)
          ret += `${CSI}${-x3}D`;
        else if (x3 > 0)
          ret += `${CSI}${x3}C`;
        if (y3 < 0)
          ret += `${CSI}${-y3}A`;
        else if (y3 > 0)
          ret += `${CSI}${y3}B`;
        return ret;
      },
      up: (count = 1) => `${CSI}${count}A`,
      down: (count = 1) => `${CSI}${count}B`,
      forward: (count = 1) => `${CSI}${count}C`,
      backward: (count = 1) => `${CSI}${count}D`,
      nextLine: (count = 1) => `${CSI}E`.repeat(count),
      prevLine: (count = 1) => `${CSI}F`.repeat(count),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC}7`,
      restore: `${ESC}8`
    };
    var scroll = {
      up: (count = 1) => `${CSI}S`.repeat(count),
      down: (count = 1) => `${CSI}T`.repeat(count)
    };
    var erase = {
      screen: `${CSI}2J`,
      up: (count = 1) => `${CSI}1J`.repeat(count),
      down: (count = 1) => `${CSI}J`.repeat(count),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i2 = 0; i2 < count; i2++)
          clear += this.line + (i2 < count - 1 ? cursor.up() : "");
        if (count)
          clear += cursor.left;
        return clear;
      }
    };
    module2.exports = { cursor, scroll, erase, beep };
  }
});

// ../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js"(exports, module2) {
    var tty = require("tty");
    var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input;
      let index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let start = string.substring(0, index) + replace;
      let end = string.substring(index + close.length);
      let nextIndex = end.indexOf(close);
      return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
    };
    var createColors = (enabled = isColorSupported) => ({
      isColorSupported: enabled,
      reset: enabled ? (s2) => `\x1B[0m${s2}\x1B[0m` : String,
      bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
      dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
      italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
      underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
      inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
      hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
      strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
      black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
      red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
      green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
      yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
      blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
      magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
      cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
      white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
      gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
      bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
      bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
      bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
      bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
      bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
      bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
      bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
      bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
    });
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/lib/pipeline.ts
async function runPipeline(config, pipeline2, target) {
  for (const transform of pipeline2) {
    await transform?.(config, target);
  }
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
var import_graphql17 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/helpers.js
var import_graphql = require("graphql");
var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
function compareStrings(a2, b2) {
  if (String(a2) < String(b2)) {
    return -1;
  }
  if (String(a2) > String(b2)) {
    return 1;
  }
  return 0;
}
function nodeToString(a2) {
  var _a, _b;
  let name;
  if ("alias" in a2) {
    name = (_a = a2.alias) === null || _a === void 0 ? void 0 : _a.value;
  }
  if (name == null && "name" in a2) {
    name = (_b = a2.name) === null || _b === void 0 ? void 0 : _b.value;
  }
  if (name == null) {
    name = a2.kind;
  }
  return name;
}
function compareNodes(a2, b2, customFn) {
  const aStr = nodeToString(a2);
  const bStr = nodeToString(b2);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/inspect.js
var import_graphql2 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/AggregateError.js
var AggregateErrorImpl;
if (typeof AggregateError === "undefined") {
  class AggregateErrorClass extends Error {
    constructor(errors, message = "") {
      super(message);
      this.errors = errors;
      this.name = "AggregateError";
      Error.captureStackTrace(this, AggregateErrorClass);
    }
  }
  AggregateErrorImpl = function(errors, message) {
    return new AggregateErrorClass(errors, message);
  };
} else {
  AggregateErrorImpl = AggregateError;
}
function isAggregateError(error) {
  return "errors" in error && Array.isArray(error["errors"]);
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/inspect.js
var MAX_RECURSIVE_DEPTH = 3;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatError(value) {
  if (value instanceof import_graphql2.GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (isAggregateError(value)) {
      return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
var import_graphql5 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/astFromType.js
var import_graphql3 = require("graphql");
function astFromType(type) {
  if ((0, import_graphql3.isNonNullType)(type)) {
    const innerType = astFromType(type.ofType);
    if (innerType.kind === import_graphql3.Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: import_graphql3.Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if ((0, import_graphql3.isListType)(type)) {
    return {
      kind: import_graphql3.Kind.LIST_TYPE,
      type: astFromType(type.ofType)
    };
  }
  return {
    kind: import_graphql3.Kind.NAMED_TYPE,
    name: {
      kind: import_graphql3.Kind.NAME,
      value: type.name
    }
  };
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
var import_graphql4 = require("graphql");
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: import_graphql4.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: import_graphql4.Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: import_graphql4.Kind.OBJECT_FIELD,
          name: { kind: import_graphql4.Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: import_graphql4.Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: import_graphql4.Kind.BOOLEAN, value };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp.test(stringNum) ? { kind: import_graphql4.Kind.INT, value: stringNum } : { kind: import_graphql4.Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: import_graphql4.Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/rootTypes.js
var getRootTypeNames = memoize1(function getRootTypeNames2(schema) {
  const rootTypes = getRootTypes(schema);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema) {
  const rootTypeMap = getRootTypeMap(schema);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
function getDocumentNodeFromSchema(schema, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema.getTypeMap();
  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema.getDirectives();
  for (const directive of directives) {
    if ((0, import_graphql5.isSpecifiedDirective)(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = (0, import_graphql5.isSpecifiedScalarType)(type);
    const isIntrospection = (0, import_graphql5.isIntrospectionType)(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if ((0, import_graphql5.isObjectType)(type)) {
      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql5.isInterfaceType)(type)) {
      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql5.isUnionType)(type)) {
      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql5.isInputObjectType)(type)) {
      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql5.isEnumType)(type)) {
      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql5.isScalarType)(type)) {
      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: import_graphql5.Kind.DOCUMENT,
    definitions
  };
}
function astFromSchema(schema, pathToDirectivesInExtensions) {
  var _a, _b;
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema.astNode != null) {
    nodes.push(schema.astNode);
  }
  if (schema.extensionASTNodes != null) {
    for (const extensionASTNode of schema.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: import_graphql5.Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? import_graphql5.Kind.SCHEMA_DEFINITION : import_graphql5.Kind.SCHEMA_EXTENSION,
    operationTypes,
    directives
  };
  schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
    kind: import_graphql5.Kind.STRING,
    value: schema.description,
    block: true
  } : void 0;
  return schemaNode;
}
function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c, _d;
  return {
    kind: import_graphql5.Kind.DIRECTIVE_DEFINITION,
    description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
      kind: import_graphql5.Kind.STRING,
      value: directive.description
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: directive.name
    },
    arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
      kind: import_graphql5.Kind.NAME,
      value: location
    }))) || []
  };
}
function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = [];
    for (const node of nodes) {
      if (node.directives) {
        directives.push(...node.directives);
      }
    }
  }
  return directives;
}
function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
  }
  if (directives != null) {
    directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
function astFromArg(arg, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c;
  return {
    kind: import_graphql5.Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
      kind: import_graphql5.Kind.STRING,
      value: arg.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    defaultValue: arg.defaultValue !== void 0 ? (_c = (0, import_graphql5.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql5.Kind.OBJECT_TYPE_DEFINITION,
    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql5.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  const node = {
    kind: import_graphql5.Kind.INTERFACE_TYPE_DEFINITION,
    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql5.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql5.Kind.UNION_TYPE_DEFINITION,
    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql5.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: type.name
    },
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType(type2))
  };
}
function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql5.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql5.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql5.Kind.ENUM_TYPE_DEFINITION,
    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql5.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c;
  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: import_graphql5.Kind.SCALAR_TYPE_DEFINITION,
    description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
      kind: import_graphql5.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: type.name
    },
    directives
  };
}
function astFromField(field, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql5.Kind.FIELD_DEFINITION,
    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: import_graphql5.Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c;
  return {
    kind: import_graphql5.Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: import_graphql5.Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
    defaultValue: (_c = (0, import_graphql5.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
  };
}
function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql5.Kind.ENUM_VALUE_DEFINITION,
    description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
      kind: import_graphql5.Kind.STRING,
      value: value.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: value.name
    },
    directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, import_graphql5.GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  if (directive != null) {
    for (const arg of directive.args) {
      const argName = arg.name;
      const argValue = args[argName];
      if (argValue !== void 0) {
        const value = (0, import_graphql5.astFromValue)(argValue, arg.type);
        if (value) {
          directiveArguments.push({
            kind: import_graphql5.Kind.ARGUMENT,
            name: {
              kind: import_graphql5.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
  } else {
    for (const argName in args) {
      const argValue = args[argName];
      const value = astFromValueUntyped(argValue);
      if (value) {
        directiveArguments.push({
          kind: import_graphql5.Kind.ARGUMENT,
          name: {
            kind: import_graphql5.Kind.NAME,
            value: argName
          },
          value
        });
      }
    }
  }
  return {
    kind: import_graphql5.Kind.DIRECTIVE,
    name: {
      kind: import_graphql5.Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
      }
    } else {
      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
    }
  }
  return directiveNodes;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/comments.js
var import_graphql6 = require("graphql");
var MAX_LINE_LENGTH = 80;
var commentsRegistry = {};
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  var _a;
  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys2 = [entity];
  if (field) {
    keys2.push(field);
    if (argument) {
      keys2.push(argument);
    }
  }
  const path3 = keys2.join(".");
  if (!commentsRegistry[path3]) {
    commentsRegistry[path3] = [];
  }
  commentsRegistry[path3].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x3) => x3).join(separator || "") : "";
}
function hasMultilineItems(maybeArray) {
  var _a;
  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
}
function addDescription(cb) {
  return (node, _key, _parent, path3, ancestors) => {
    var _a;
    const keys2 = [];
    const parent2 = path3.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys2.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys2, (_a = parent2 === null || parent2 === void 0 ? void 0 : parent2.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path3, ancestors)], "\n");
  };
}
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block(array) {
  return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
}
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function printBlockString(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
var printDocASTReducer = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: { leave: ({ selections }) => block(selections) },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value }) => name + ": " + value },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
  ObjectField: { leave: ({ name, value }) => name + ": " + value },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type }) => "[" + type + "]" },
  NonNullType: { leave: ({ type }) => type + "!" },
  SchemaDefinition: {
    leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives, types: types17 }) => join(["union", name, join(directives, " "), wrap("= ", join(types17, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types: types17 }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types17, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
function printWithComments(ast) {
  return (0, import_graphql6.visit)(ast, printDocASTReducerWithComments);
}
function isFieldDefinitionNode(node) {
  return node.kind === "FieldDefinition";
}
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue(`
${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === import_graphql6.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i2 = 1; i2 < lines.length; i2++) {
      lines[i2] = lines[i2].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i2 = 1; i2 < lines.length; i2++) {
    const line = lines[i2];
    const indent3 = leadingWhitespace(line);
    if (indent3 === line.length) {
      continue;
    }
    if (commonIndent === null || indent3 < commonIndent) {
      commonIndent = indent3;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
  let i2 = 0;
  while (i2 < str.length && (str[i2] === " " || str[i2] === "	")) {
    i2++;
  }
  return i2;
}
function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/Interfaces.js
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/mapSchema.js
var import_graphql11 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
var import_graphql7 = require("graphql");
function getObjectTypeFromTypeMap(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if ((0, import_graphql7.isObjectType)(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/rewire.js
var import_graphql9 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/stub.js
var import_graphql8 = require("graphql");
function isNamedStub(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type) {
  switch (type.name) {
    case import_graphql8.GraphQLInt.name:
      return import_graphql8.GraphQLInt;
    case import_graphql8.GraphQLFloat.name:
      return import_graphql8.GraphQLFloat;
    case import_graphql8.GraphQLString.name:
      return import_graphql8.GraphQLString;
    case import_graphql8.GraphQLBoolean.name:
      return import_graphql8.GraphQLBoolean;
    case import_graphql8.GraphQLID.name:
      return import_graphql8.GraphQLID;
    default:
      return type;
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/rewire.js
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
      continue;
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if ((0, import_graphql9.isSpecifiedDirective)(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new import_graphql9.GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if ((0, import_graphql9.isObjectType)(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireFields(config.fields),
        interfaces: () => rewireNamedTypes(config.interfaces)
      };
      return new import_graphql9.GraphQLObjectType(newConfig);
    } else if ((0, import_graphql9.isInterfaceType)(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireFields(config.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
      }
      return new import_graphql9.GraphQLInterfaceType(newConfig);
    } else if ((0, import_graphql9.isUnionType)(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        types: () => rewireNamedTypes(config.types)
      };
      return new import_graphql9.GraphQLUnionType(newConfig);
    } else if ((0, import_graphql9.isInputObjectType)(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireInputFields(config.fields)
      };
      return new import_graphql9.GraphQLInputObjectType(newConfig);
    } else if ((0, import_graphql9.isEnumType)(type)) {
      const enumConfig = type.toConfig();
      return new import_graphql9.GraphQLEnumType(enumConfig);
    } else if ((0, import_graphql9.isScalarType)(type)) {
      if ((0, import_graphql9.isSpecifiedScalarType)(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new import_graphql9.GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if ((0, import_graphql9.isListType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql9.GraphQLList(rewiredType) : null;
    } else if ((0, import_graphql9.isNonNullType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql9.GraphQLNonNull(rewiredType) : null;
    } else if ((0, import_graphql9.isNamedType)(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/transformInputValue.js
var import_graphql10 = require("graphql");
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = (0, import_graphql10.getNullableType)(type);
  if ((0, import_graphql10.isLeafType)(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if ((0, import_graphql10.isListType)(nullableType)) {
    return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if ((0, import_graphql10.isInputObjectType)(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type, value) {
  return transformInputValue(type, value, (t3, v2) => {
    try {
      return t3.serialize(v2);
    } catch (_a) {
      return v2;
    }
  });
}
function parseInputValue(type, value) {
  return transformInputValue(type, value, (t3, v2) => {
    try {
      return t3.parseValue(v2);
    } catch (_a) {
      return v2;
    }
  });
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/mapSchema.js
function mapSchema(schema, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type) => (0, import_graphql11.isLeafType)(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type) => !(0, import_graphql11.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
  const originalDirectives = schema.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new import_graphql11.GraphQLSchema({
    ...schema.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema, {
    [MapperKind.ENUM_TYPE]: (type) => {
      const config = type.toConfig();
      const originalEnumValueConfigMap = config.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new import_graphql11.GraphQLEnumType({
        ...config,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => (0, import_graphql11.isEnumType)(type));
}
function mapDefaultValues(originalTypeMap, schema, fn) {
  const newTypeMap = mapArguments(originalTypeMap, schema, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
}
function getNewType(newTypeMap, type) {
  if ((0, import_graphql11.isListType)(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql11.GraphQLList(newType) : null;
  } else if ((0, import_graphql11.isNonNullType)(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql11.GraphQLNonNull(newType) : null;
  } else if ((0, import_graphql11.isNamedType)(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql11.isObjectType)(originalType) && !(0, import_graphql11.isInterfaceType)(originalType) && !(0, import_graphql11.isInputObjectType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config = originalType.toConfig();
      const originalFieldConfigMap = config.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if ((0, import_graphql11.isObjectType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql11.GraphQLObjectType({
          ...config,
          fields: newFieldConfigMap
        }));
      } else if ((0, import_graphql11.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql11.GraphQLInterfaceType({
          ...config,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new import_graphql11.GraphQLInputObjectType({
          ...config,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapArguments(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql11.isObjectType)(originalType) && !(0, import_graphql11.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config = originalType.toConfig();
      const originalFieldConfigMap = config.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if ((0, import_graphql11.isObjectType)(originalType)) {
        newTypeMap[typeName] = new import_graphql11.GraphQLObjectType({
          ...config,
          fields: newFieldConfigMap
        });
      } else if ((0, import_graphql11.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = new import_graphql11.GraphQLInterfaceType({
          ...config,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new import_graphql11.GraphQLInputObjectType({
          ...config,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
}
function mapDirectives(originalDirectives, schema, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers(schema, typeName) {
  var _a, _b, _c;
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if ((0, import_graphql11.isObjectType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if ((0, import_graphql11.isInputObjectType)(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if ((0, import_graphql11.isInterfaceType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if ((0, import_graphql11.isUnionType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if ((0, import_graphql11.isEnumType)(type)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if ((0, import_graphql11.isScalarType)(type)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper(schema, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema, typeName) {
  var _a, _b, _c;
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if ((0, import_graphql11.isObjectType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if ((0, import_graphql11.isInterfaceType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if ((0, import_graphql11.isInputObjectType)(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper(schema, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type) {
  if ((0, import_graphql11.isObjectType)(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: import_graphql11.Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql11.Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql11.GraphQLObjectType(config);
  } else if ((0, import_graphql11.isInterfaceType)(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: import_graphql11.Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql11.Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql11.GraphQLInterfaceType(config);
  } else if ((0, import_graphql11.isInputObjectType)(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: import_graphql11.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql11.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql11.GraphQLInputObjectType(config);
  } else if ((0, import_graphql11.isEnumType)(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const values = [];
      for (const enumKey in config.values) {
        const enumValueConfig = config.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        values
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        values: void 0
      }));
    }
    return new import_graphql11.GraphQLEnumType(config);
  } else {
    return type;
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/heal.js
var import_graphql12 = require("graphql");
function healSchema(schema) {
  healTypes(schema.getTypeMap(), schema.getDirectives());
  return schema;
}
function healTypes(originalTypeMap, directives) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualNamedTypeMap[actualName] != null) {
      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
      continue;
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if ((0, import_graphql12.isObjectType)(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if ((0, import_graphql12.isInterfaceType)(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if ((0, import_graphql12.isUnionType)(type)) {
      healUnderlyingTypes(type);
      return;
    } else if ((0, import_graphql12.isInputObjectType)(type)) {
      healInputFields(type);
      return;
    } else if ((0, import_graphql12.isLeafType)(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types17 = type.getTypes();
    types17.push(...types17.splice(0).map((t3) => healType(t3)).filter(Boolean));
  }
  function healType(type) {
    if ((0, import_graphql12.isListType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql12.GraphQLList(healedType) : null;
    } else if ((0, import_graphql12.isNonNullType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql12.GraphQLNonNull(healedType) : null;
    } else if ((0, import_graphql12.isNamedType)(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/getResolversFromSchema.js
var import_graphql13 = require("graphql");
function getResolversFromSchema(schema, includeDefaultMergedResolver) {
  var _a, _b;
  const resolvers = /* @__PURE__ */ Object.create(null);
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    if (!typeName.startsWith("__")) {
      const type = typeMap[typeName];
      if ((0, import_graphql13.isScalarType)(type)) {
        if (!(0, import_graphql13.isSpecifiedScalarType)(type)) {
          const config = type.toConfig();
          delete config.astNode;
          resolvers[typeName] = new import_graphql13.GraphQLScalarType(config);
        }
      } else if ((0, import_graphql13.isEnumType)(type)) {
        resolvers[typeName] = {};
        const values = type.getValues();
        for (const value of values) {
          resolvers[typeName][value.name] = value.value;
        }
      } else if ((0, import_graphql13.isInterfaceType)(type)) {
        if (type.resolveType != null) {
          resolvers[typeName] = {
            __resolveType: type.resolveType
          };
        }
      } else if ((0, import_graphql13.isUnionType)(type)) {
        if (type.resolveType != null) {
          resolvers[typeName] = {
            __resolveType: type.resolveType
          };
        }
      } else if ((0, import_graphql13.isObjectType)(type)) {
        resolvers[typeName] = {};
        if (type.isTypeOf != null) {
          resolvers[typeName].__isTypeOf = type.isTypeOf;
        }
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          if (field.subscribe != null) {
            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
            resolvers[typeName][fieldName].subscribe = field.subscribe;
          }
          if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
            switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
              case "defaultMergedResolver":
                if (!includeDefaultMergedResolver) {
                  continue;
                }
                break;
              case "defaultFieldResolver":
                continue;
            }
            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
            resolvers[typeName][fieldName].resolve = field.resolve;
          }
        }
      }
    }
  }
  return resolvers;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/forEachField.js
var import_graphql14 = require("graphql");
function forEachField(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql14.getNamedType)(type).name.startsWith("__") && (0, import_graphql14.isObjectType)(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn(field, typeName, fieldName);
      }
    }
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
var import_graphql15 = require("graphql");
function forEachDefaultValue(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql15.getNamedType)(type).name.startsWith("__")) {
      if ((0, import_graphql15.isObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn(arg.type, arg.defaultValue);
          }
        }
      } else if ((0, import_graphql15.isInputObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn(field.type, field.defaultValue);
        }
      }
    }
  }
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/mergeDeep.js
function mergeDeep(sources, respectPrototype = false) {
  const target = sources[0] || {};
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
  }
  for (const source of sources) {
    if (isObject(target) && isObject(source)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (isObject(source[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep([output[key], source[key]], respectPrototype);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      }
    }
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/isDocumentNode.js
var import_graphql16 = require("graphql");
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === import_graphql16.Kind.DOCUMENT;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@9.1.3_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/extractExtensionsFromSchema.js
function extractExtensionsFromSchema(schema) {
  const result = {
    schemaExtensions: schema.extensions || {},
    types: {}
  };
  mapSchema(schema, {
    [MapperKind.OBJECT_TYPE]: (type) => {
      result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} };
      return type;
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} };
      return type;
    },
    [MapperKind.FIELD]: (field, fieldName, typeName) => {
      result.types[typeName].fields[fieldName] = {
        arguments: {},
        extensions: field.extensions || {}
      };
      const args = field.args;
      if (args != null) {
        for (const argName in args) {
          result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
        }
      }
      return field;
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} };
      return type;
    },
    [MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
      result.types[typeName].values[valueName] = value.extensions || {};
      return value;
    },
    [MapperKind.SCALAR_TYPE]: (type) => {
      result.types[type.name] = { type: "scalar", extensions: type.extensions || {} };
      return type;
    },
    [MapperKind.UNION_TYPE]: (type) => {
      result.types[type.name] = { type: "union", extensions: type.extensions || {} };
      return type;
    },
    [MapperKind.INPUT_OBJECT_TYPE]: (type) => {
      result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} };
      return type;
    },
    [MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
      result.types[typeName].fields[fieldName] = {
        extensions: field.extensions || {}
      };
      return field;
    }
  });
  return result;
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
function assertResolversPresent(schema, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !(0, import_graphql17.isScalarType)((0, import_graphql17.getNamedType)(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
function expectResolver(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
var import_graphql18 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
  mapSchema(schema, {
    [MapperKind.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
function extendResolversFromInterfaces(schema, resolvers) {
  const extendedResolvers = {};
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers[iFace.name]) {
          for (const fieldName in resolvers[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
  for (const typeName in resolvers) {
    const resolverValue = resolvers[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema.getType(typeName);
    if (type == null) {
      if (requireResolversToMatchSchema === "ignore") {
        continue;
      }
      throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
    } else if ((0, import_graphql18.isSpecifiedScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql18.isEnumType)(type)) {
      const values = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
        }
      }
    } else if ((0, import_graphql18.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
        }
      }
    } else if ((0, import_graphql18.isObjectType)(type) || (0, import_graphql18.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
  }
  return schema;
}
function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  const typeMap = schema.getTypeMap();
  for (const typeName in resolvers) {
    const type = schema.getType(typeName);
    const resolverValue = resolvers[typeName];
    if ((0, import_graphql18.isScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
            directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql18.isEnumType)(type)) {
      const config = type.toConfig();
      const enumValueConfigMap = config.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config.astNode != null) {
          config.astNode = {
            ...config.astNode,
            description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
            directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
          };
        } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new import_graphql18.GraphQLEnumType(config);
    } else if ((0, import_graphql18.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql18.isObjectType)(type) || (0, import_graphql18.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields = type.getFields();
        const field = fields[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema, serializeInputValue);
  healSchema(schema);
  forEachDefaultValue(schema, parseInputValue);
  if (defaultFieldResolver != null) {
    forEachField(schema, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver;
      }
    });
  }
  return schema;
}
function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
  schema = mapSchema(schema, {
    [MapperKind.SCALAR_TYPE]: (type) => {
      var _a, _b, _c, _d, _e, _f;
      const config = type.toConfig();
      const resolverValue = resolvers[type.name];
      if (!(0, import_graphql18.isSpecifiedScalarType)(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
              directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
          } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
            config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config[fieldName] = resolverValue[fieldName];
          }
        }
        return new import_graphql18.GraphQLScalarType(config);
      }
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      var _a, _b, _c, _d, _e, _f;
      const resolverValue = resolvers[type.name];
      const config = type.toConfig();
      const enumValueConfigMap = config.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
              directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
          } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
            config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new import_graphql18.GraphQLEnumType(config);
      }
    },
    [MapperKind.UNION_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql18.GraphQLUnionType(config);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new import_graphql18.GraphQLObjectType(config);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql18.GraphQLInterfaceType(config);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver != null) {
    schema = mapSchema(schema, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
      })
    });
  }
  return schema;
}
function setFieldProperties(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
var import_graphql30 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/merge-resolvers.js
function mergeResolvers(resolversDefinitions, options) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers = new Array();
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers, true);
  if (options === null || options === void 0 ? void 0 : options.exclusions) {
    for (const exclusion of options.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
function mergeArguments(args1, args2, config) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome));
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}
function deduplicateArguments(args) {
  return args.reduce((acc, current) => {
    const dup = acc.find((arg) => arg.name.value === current.name.value);
    if (!dup) {
      return acc.concat([current]);
    }
    return acc;
  }, []);
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
var import_graphql19 = require("graphql");
function directiveAlreadyExists(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
}
function nameAlreadyExists(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
}
function mergeArguments2(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a3) => a3.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
          const value = targetVal.value;
          return !value || !source2.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
}
function deduplicateDirectives(directives) {
  return directives.map((directive, i2, all) => {
    const firstAt = all.findIndex((d3) => d3.name.value === directive.name.value);
    if (firstAt !== i2) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments2(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome);
}
function mergeDirectives(d1 = [], d22 = [], config) {
  const reverseOrder = config && config.reverseDirectives;
  const asNext = reverseOrder ? d1 : d22;
  const asFirst = reverseOrder ? d22 : d1;
  const result = deduplicateDirectives([...asNext]);
  for (const directive of asFirst) {
    if (directiveAlreadyExists(result, directive)) {
      const existingDirectiveIndex = result.findIndex((d3) => d3.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments2(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
function validateInputs(node, existingNode) {
  const printedNode = (0, import_graphql19.print)({
    ...node,
    description: void 0
  });
  const printedExistingNode = (0, import_graphql19.print)({
    ...existingNode,
    description: void 0
  });
  const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
  const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
  if (!sameArguments) {
    throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
  }
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    validateInputs(node, existingNode);
    return {
      ...node,
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
function deduplicateLists(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
function mergeEnumValues(first, second, config) {
  if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
var import_graphql20 = require("graphql");
function mergeEnum(e1, e22, config) {
  if (e22) {
    return {
      name: e1.name,
      description: e1["description"] || e22["description"],
      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e22.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e22.directives, config),
      values: mergeEnumValues(e1.values, e22.values, config)
    };
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...e1,
    kind: import_graphql20.Kind.ENUM_TYPE_DEFINITION
  } : e1;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
var import_graphql21 = require("graphql");
function isStringTypes(types17) {
  return typeof types17 === "string";
}
function isSourceTypes(types17) {
  return types17 instanceof import_graphql21.Source;
}
function extractType(type) {
  let visitedType = type;
  while (visitedType.kind === import_graphql21.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type) {
  return type.kind !== import_graphql21.Kind.NAMED_TYPE;
}
function isListTypeNode(type) {
  return type.kind === import_graphql21.Kind.LIST_TYPE;
}
function isNonNullTypeNode(type) {
  return type.kind === import_graphql21.Kind.NON_NULL_TYPE;
}
function printTypeNode(type) {
  if (isListTypeNode(type)) {
    return `[${printTypeNode(type.type)}]`;
  }
  if (isNonNullTypeNode(type)) {
    return `${printTypeNode(type.type)}!`;
  }
  return type.name.value;
}
var CompareVal;
(function(CompareVal3) {
  CompareVal3[CompareVal3["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal3[CompareVal3["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal3[CompareVal3["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));
function defaultStringComparator(a2, b2) {
  if (a2 == null && b2 == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a2 == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b2 == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a2 < b2)
    return CompareVal.A_SMALLER_THAN_B;
  if (a2 > b2)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
function fieldAlreadyExists(fieldsArr, otherField, config) {
  const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
  if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
    const t1 = extractType(result.type);
    const t22 = extractType(otherField.type);
    if (t1.name.value !== t22.name.value) {
      throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t22.name.value}"`);
    }
  }
  return !!result;
}
function mergeFields(type, f1, f22, config) {
  const result = [];
  if (f22 != null) {
    result.push(...f22);
  }
  if (f1 != null) {
    for (const field of f1) {
      if (fieldAlreadyExists(result, field, config)) {
        const existing = result.find((f5) => f5.name.value === field.name.value);
        if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
          if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {
            preventConflicts(type, existing, field, false);
          } else {
            preventConflicts(type, existing, field, true);
          }
          if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {
            existing.type = field.type;
          }
        }
        existing.arguments = mergeArguments(field["arguments"] || [], existing.arguments || [], config);
        existing.directives = mergeDirectives(field.directives, existing.directives, config);
        existing.description = field.description || existing.description;
      } else {
        result.push(field);
      }
    }
  }
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  if (config && config.exclusions) {
    const exclusions = config.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
function preventConflicts(type, a2, b2, ignoreNullability = false) {
  const aType = printTypeNode(a2.type);
  const bType = printTypeNode(b2.type);
  if (aType !== bType && !safeChangeForFieldType(a2.type, b2.type, ignoreNullability)) {
    throw new Error(`Field '${type.name.value}.${a2.name.value}' changed type from '${aType}' to '${bType}'`);
  }
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
var import_graphql22 = require("graphql");
function mergeInputType(node, existingNode, config) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config)
      };
    } catch (e3) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e3.message}`);
    }
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...node,
    kind: import_graphql22.Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
var import_graphql23 = require("graphql");
function mergeInterface(node, existingNode, config) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config) : void 0
      };
    } catch (e3) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e3.message}`);
    }
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...node,
    kind: import_graphql23.Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
function alreadyExists(arr, other) {
  return !!arr.find((i2) => i2.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config = {}) {
  const result = [...second, ...first.filter((d3) => !alreadyExists(second, d3))];
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var import_graphql28 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
var import_graphql24 = require("graphql");
function mergeType(node, existingNode, config) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)
      };
    } catch (e3) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e3.message}`);
    }
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...node,
    kind: import_graphql24.Kind.OBJECT_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
var import_graphql25 = require("graphql");
function mergeScalar(node, existingNode, config) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config)
    };
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...node,
    kind: import_graphql25.Kind.SCALAR_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
var import_graphql26 = require("graphql");
function mergeUnion(first, second, config) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      directives: mergeDirectives(first.directives, second.directives, config),
      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? import_graphql26.Kind.UNION_TYPE_DEFINITION : import_graphql26.Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config)
    };
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...first,
    kind: import_graphql26.Kind.UNION_TYPE_DEFINITION
  } : first;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
var import_graphql27 = require("graphql");
var DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config) {
  if (existingNode) {
    return {
      kind: node.kind === import_graphql27.Kind.SCHEMA_DEFINITION || existingNode.kind === import_graphql27.Kind.SCHEMA_DEFINITION ? import_graphql27.Kind.SCHEMA_DEFINITION : import_graphql27.Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
    ...node,
    kind: import_graphql27.Kind.SCHEMA_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config) {
  var _a, _b, _c;
  const mergedResultMap = {};
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case import_graphql28.Kind.OBJECT_TYPE_DEFINITION:
          case import_graphql28.Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);
            break;
          case import_graphql28.Kind.ENUM_TYPE_DEFINITION:
          case import_graphql28.Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);
            break;
          case import_graphql28.Kind.UNION_TYPE_DEFINITION:
          case import_graphql28.Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);
            break;
          case import_graphql28.Kind.SCALAR_TYPE_DEFINITION:
          case import_graphql28.Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);
            break;
          case import_graphql28.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case import_graphql28.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);
            break;
          case import_graphql28.Kind.INTERFACE_TYPE_DEFINITION:
          case import_graphql28.Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);
            break;
          case import_graphql28.Kind.DIRECTIVE_DEFINITION:
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === import_graphql28.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === import_graphql28.Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);
    }
  }
  return mergedResultMap;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
var import_graphql29 = require("graphql");
function mergeTypeDefs(typeSource, config) {
  resetComments();
  const doc = {
    kind: import_graphql29.Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config
    })
  };
  let result;
  if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type of typeSource) {
        visitTypeSources(type, options, allNodes, visitedTypeSources);
      }
    } else if ((0, import_graphql29.isSchema)(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = (0, import_graphql29.parse)(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && (0, import_graphql29.isDefinitionNode)(typeSource)) {
      allNodes.push(typeSource);
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return allNodes;
}
function mergeGraphQLTypes(typeSource, config) {
  var _a, _b, _c;
  resetComments();
  const allNodes = visitTypeSources(typeSource, config);
  const mergedNodes = mergeGraphQLNodes(allNodes, config);
  if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: import_graphql29.Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: import_graphql29.Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: import_graphql29.Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
    mergedNodes[schemaDefSymbol] = {
      kind: import_graphql29.Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: import_graphql29.Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: import_graphql29.Kind.NAMED_TYPE,
            name: {
              kind: import_graphql29.Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config === null || config === void 0 ? void 0 : config.sort) {
    const sortFn = typeof config.sort === "function" ? config.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a2, b2) => {
      var _a2, _b2;
      return sortFn((_a2 = a2.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b2.name) === null || _b2 === void 0 ? void 0 : _b2.value);
    });
  }
  return mergedNodeDefinitions;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@8.3.14_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/extensions.js
function mergeExtensions(extensions) {
  return mergeDeep(extensions);
}
function applyExtensionObject(obj, extensions) {
  if (!obj) {
    return;
  }
  obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}]);
}
function applyExtensions(schema, extensions) {
  applyExtensionObject(schema, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type = schema.getType(typeName);
    if (type) {
      applyExtensionObject(type, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a2) => a2.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema;
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs) {
    throw new Error("Must provide typeDefs");
  }
  let schema;
  if ((0, import_graphql30.isSchema)(typeDefs)) {
    schema = typeDefs;
  } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, {
      ...otherOptions,
      commentDescriptions: true
    });
    schema = (0, import_graphql30.buildSchema)(mergedTypeDefs, otherOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, otherOptions);
    schema = (0, import_graphql30.buildASTSchema)(mergedTypeDefs, otherOptions);
  }
  schema = addResolversToSchema({
    schema,
    resolvers: mergeResolvers(resolvers),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema, resolverValidationOptions);
  }
  if (schemaExtensions) {
    schemaExtensions = mergeExtensions(asArray(schemaExtensions));
    applyExtensions(schema, schemaExtensions);
  }
  return schema;
}

// ../../node_modules/.pnpm/@graphql-tools+schema@9.0.12_graphql@15.5.0/node_modules/@graphql-tools/schema/esm/merge-schemas.js
function mergeSchemas(config) {
  const extractedTypeDefs = [];
  const extractedResolvers = [];
  const extractedSchemaExtensions = [];
  if (config.schemas != null) {
    for (const schema of config.schemas) {
      extractedTypeDefs.push(schema);
      extractedResolvers.push(getResolversFromSchema(schema));
      extractedSchemaExtensions.push(extractExtensionsFromSchema(schema));
    }
  }
  if (config.typeDefs != null) {
    extractedTypeDefs.push(config.typeDefs);
  }
  if (config.resolvers != null) {
    const additionalResolvers = asArray(config.resolvers);
    extractedResolvers.push(...additionalResolvers);
  }
  if (config.schemaExtensions != null) {
    const additionalSchemaExtensions = asArray(config.schemaExtensions);
    extractedSchemaExtensions.push(...additionalSchemaExtensions);
  }
  return makeExecutableSchema({
    ...config,
    typeDefs: extractedTypeDefs,
    resolvers: extractedResolvers,
    schemaExtensions: extractedSchemaExtensions
  });
}

// src/lib/config.ts
var graphql2 = __toESM(require("graphql"), 1);
var import_minimatch = __toESM(require_minimatch(), 1);
var import_node_url2 = require("node:url");

// src/runtime/imports/config.ts
var config_default = {};

// src/runtime/imports/pluginConfig.ts
var configs = [];
var pluginConfig_default = configs;

// src/runtime/lib/config.ts
var mockConfig = null;
function getMockConfig() {
  return mockConfig;
}
function defaultConfigValues(file) {
  return {
    defaultKeys: ["id"],
    ...file,
    types: {
      Node: {
        keys: ["id"],
        resolve: {
          queryField: "node",
          arguments: (node) => ({ id: node.id })
        }
      },
      ...file.types
    }
  };
}
function keyFieldsForType(configFile, type) {
  const withDefault = defaultConfigValues(configFile);
  return withDefault.types?.[type]?.keys || withDefault.defaultKeys;
}
function computeID(configFile, type, data) {
  const fields = keyFieldsForType(configFile, type);
  let id = "";
  for (const field of fields) {
    id += data[field] + "__";
  }
  return id.slice(0, -2);
}
var _configFile = null;
function localApiEndpoint(configFile) {
  return configFile.router?.apiEndpoint ?? "/_api";
}
function getCurrentConfig() {
  const mockConfig2 = getMockConfig();
  if (mockConfig2) {
    return mockConfig2;
  }
  if (_configFile) {
    return _configFile;
  }
  let configFile = defaultConfigValues(config_default);
  for (const pluginConfig of pluginConfig_default) {
    configFile = pluginConfig(configFile);
  }
  _configFile = configFile;
  return configFile;
}

// src/runtime/lib/deepEquals.ts
function deepEquals(objA, objB, map = /* @__PURE__ */ new WeakMap()) {
  if (Object.is(objA, objB))
    return true;
  if (objA instanceof Date && objB instanceof Date) {
    return objA.getTime() === objB.getTime();
  }
  if (objA instanceof RegExp && objB instanceof RegExp) {
    return objA.toString() === objB.toString();
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (map.get(objA) === objB)
    return true;
  map.set(objA, objB);
  const keysA = Reflect.ownKeys(objA);
  const keysB = Reflect.ownKeys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Reflect.has(objB, keysA[i2]) || !deepEquals(objA[keysA[i2]], objB[keysA[i2]], map)) {
      return false;
    }
  }
  return true;
}

// src/runtime/lib/selection.ts
function getFieldsForType(selection, __typename, loading) {
  if (loading) {
    if (selection.loadingTypes && selection.loadingTypes.length > 0) {
      return deepMerge(
        ...selection.loadingTypes.map((type) => selection.abstractFields?.fields[type])
      );
    }
    return selection.fields ?? {};
  }
  let targetSelection = selection.fields || {};
  if (selection.abstractFields && __typename) {
    const mappedType = selection.abstractFields.typeMap[__typename];
    if (mappedType) {
      targetSelection = selection.abstractFields.fields[mappedType];
    } else if (selection.abstractFields.fields[__typename]) {
      targetSelection = selection.abstractFields.fields[__typename];
    }
  }
  return targetSelection;
}
function deepMerge(...objects) {
  const mergedObj = {};
  for (let obj of objects) {
    if (!obj) {
      continue;
    }
    for (let prop in obj) {
      if (prop in obj) {
        const val = obj[prop];
        if (typeof val === "object" && val !== null && !Array.isArray(val)) {
          mergedObj[prop] = deepMerge(mergedObj[prop] || {}, val);
        } else {
          mergedObj[prop] = val;
        }
      }
    }
  }
  return mergedObj;
}

// src/runtime/lib/scalars.ts
async function marshalSelection({
  selection,
  data
}) {
  const config = getCurrentConfig();
  if (data === null || typeof data === "undefined") {
    return data;
  }
  if (Array.isArray(data)) {
    return await Promise.all(data.map((val) => marshalSelection({ selection, data: val })));
  }
  const targetSelection = getFieldsForType(selection, data["__typename"], false);
  return Object.fromEntries(
    await Promise.all(
      Object.entries(data).map(async ([fieldName, value]) => {
        const { type, selection: selection2 } = targetSelection[fieldName];
        if (!type) {
          return [fieldName, value];
        }
        if (selection2) {
          return [fieldName, await marshalSelection({ selection: selection2, data: value })];
        }
        if (config.scalars?.[type]) {
          const marshalFn = config.scalars[type].marshal;
          if (!marshalFn) {
            throw new Error(
              `scalar type ${type} is missing a \`marshal\` function. see https://github.com/AlecAivazis/houdini#%EF%B8%8Fcustom-scalars`
            );
          }
          if (Array.isArray(value)) {
            return [fieldName, value.map(marshalFn)];
          }
          return [fieldName, marshalFn(value)];
        }
        return [fieldName, value];
      })
    )
  );
}

// src/runtime/lib/types.ts
var CachePolicy = {
  CacheOrNetwork: "CacheOrNetwork",
  CacheOnly: "CacheOnly",
  NetworkOnly: "NetworkOnly",
  CacheAndNetwork: "CacheAndNetwork"
};
var PaginateMode = {
  Infinite: "Infinite",
  SinglePage: "SinglePage"
};
var ArtifactKind = {
  Query: "HoudiniQuery",
  Subscription: "HoudiniSubscription",
  Mutation: "HoudiniMutation",
  Fragment: "HoudiniFragment"
};
var CompiledFragmentKind = ArtifactKind.Fragment;
var CompiledMutationKind = ArtifactKind.Mutation;
var CompiledQueryKind = ArtifactKind.Query;
var CompiledSubscriptionKind = ArtifactKind.Subscription;
var RefetchUpdateMode = {
  append: "append",
  prepend: "prepend",
  replace: "replace"
};
var DataSource = {
  Cache: "cache",
  Network: "network",
  Ssr: "ssr"
};
var fragmentKey = " $fragments";
var PendingValue = Symbol("houdini_loading");

// src/runtime/lib/key.ts
var computeKey = ({ field, args }) => {
  const keys2 = Object.keys(args ?? {});
  keys2.sort();
  return args && keys2.length > 0 ? `${field}(${keys2.map((key) => `${key}: ${stringifyObjectWithNoQuotesOnKeys(args[key])}`).join(", ")})` : field;
};
var stringifyObjectWithNoQuotesOnKeys = (obj_from_json) => {
  if (Array.isArray(obj_from_json)) {
    return `[${obj_from_json.map((obj) => `${stringifyObjectWithNoQuotesOnKeys(obj)}`).join(", ")}]`;
  }
  if (typeof obj_from_json !== "object" || obj_from_json instanceof Date || obj_from_json === null) {
    return JSON.stringify(obj_from_json).replace(/"([^"]+)":/g, "$1: ");
  }
  return `{${Object.keys(obj_from_json).map((key) => `${key}: ${stringifyObjectWithNoQuotesOnKeys(obj_from_json[key])}`).join(", ")}}`;
};

// src/lib/constants.ts
var siteURL = "https://houdinigraphql.com";
var houdini_mode = {
  get is_testing() {
    return process.env.HOUDINI_TEST === "true";
  }
};

// src/lib/error.ts
var HoudiniError = class extends Error {
  filepath = null;
  description = null;
  constructor({
    filepath,
    message,
    description
  }) {
    super(message);
    if (filepath) {
      this.filepath = filepath;
    }
    if (description) {
      this.description = description;
    }
  }
};

// src/lib/fs.ts
var fs_exports = {};
__export(fs_exports, {
  access: () => access,
  copyFile: () => copyFile,
  copyFileSync: () => copyFileSync,
  existsSync: () => existsSync,
  glob: () => glob,
  mkdir: () => mkdir,
  mkdirp: () => mkdirp,
  mkdirpSync: () => mkdirpSync,
  mock: () => mock,
  readFile: () => readFile,
  readFileSync: () => readFileSync,
  readdir: () => readdir,
  recursiveCopy: () => recursiveCopy,
  remove: () => remove,
  rmdir: () => rmdir,
  snapshot: () => snapshot,
  stat: () => stat,
  writeFile: () => writeFile
});
var import_fs_extra = __toESM(require_lib(), 1);
var import_glob = __toESM(require_glob(), 1);
var import_memfs = __toESM(require_lib2(), 1);
var import_promises = __toESM(require("node:fs/promises"), 1);
var import_node_util = require("node:util");

// src/lib/path.ts
var path_exports = {};
__export(path_exports, {
  basename: () => basename,
  dirname: () => dirname,
  extname: () => extname,
  importPath: () => importPath,
  isAbsolute: () => isAbsolute,
  join: () => join2,
  parse: () => parse3,
  posixify: () => posixify,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep
});
var import_node_os = __toESM(require("node:os"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var sep = "/";
function resolve(...parts) {
  return posixify(import_node_path.default.resolve(...parts));
}
function join2(...parts) {
  return posixify(import_node_path.default.join(...parts));
}
function extname(target) {
  return import_node_path.default.extname(target);
}
function relative(from, to) {
  return posixify(import_node_path.default.relative(from, to));
}
function basename(target) {
  return import_node_path.default.basename(target);
}
function dirname(target) {
  return import_node_path.default.dirname(target);
}
function isAbsolute(target) {
  return import_node_path.default.isAbsolute(target);
}
function parse3(target) {
  return import_node_path.default.parse(target);
}
var posixify = (str) => str.replace(/\\/g, "/");
function importPath(target) {
  return ["win32", "win64"].includes(import_node_os.default.platform()) ? "file:///" + target : target;
}

// src/lib/fs.ts
function copyFileSync(src, dest) {
  if (houdini_mode.is_testing) {
    try {
      if (src.includes("build/runtime") || dest.includes("build/runtime")) {
        import_fs_extra.default.copyFileSync(src, dest);
        return;
      }
      import_memfs.fs.copyFileSync(src, dest);
      return;
    } catch (e3) {
      return null;
    }
  }
  try {
    import_fs_extra.default.copyFileSync(src, dest);
    return;
  } catch (e3) {
  }
  return null;
}
async function copyFile(src, dest) {
  if (houdini_mode.is_testing) {
    try {
      if (src.includes("build/runtime") || dest.includes("build/runtime")) {
        await import_promises.default.copyFile(src, dest);
        return;
      }
      await import_memfs.fs.copyFile(src, dest, (err) => {
        throw err;
      });
      return;
    } catch (e3) {
      return null;
    }
  }
  try {
    await import_promises.default.copyFile(src, dest);
    return;
  } catch (e3) {
  }
  return null;
}
async function readFile(filepath) {
  if (houdini_mode.is_testing) {
    try {
      if (filepath.includes("build/runtime")) {
        return await import_promises.default.readFile(filepath, "utf-8");
      }
      return import_memfs.fs.readFileSync(filepath, "utf-8").toString();
    } catch (e3) {
      return null;
    }
  }
  try {
    return await import_promises.default.readFile(filepath, "utf8");
  } catch (error) {
  }
  return null;
}
function readFileSync(filepath) {
  if (houdini_mode.is_testing) {
    try {
      if (filepath.includes("build/runtime")) {
        return import_fs_extra.default.readFileSync(filepath, "utf-8");
      }
      return import_memfs.fs.readFileSync(filepath, "utf-8").toString();
    } catch (e3) {
      return null;
    }
  }
  try {
    return import_fs_extra.default.readFileSync(filepath, "utf-8");
  } catch (error) {
  }
  return null;
}
async function writeFile(filepath, data) {
  const existingFileData = await readFile(filepath);
  if (data === existingFileData) {
    return;
  }
  if (houdini_mode.is_testing) {
    import_memfs.fs.mkdirpSync(dirname(filepath));
    return import_memfs.fs.writeFileSync(filepath, data);
  }
  return await import_promises.default.writeFile(filepath, data, "utf8");
}
async function access(filepath) {
  if (!houdini_mode.is_testing) {
    return await import_promises.default.access(filepath);
  }
  if (filepath.includes("build/runtime")) {
    return await import_promises.default.access(filepath);
  }
  return import_memfs.fs.statSync(filepath);
}
async function mkdirp(filepath) {
  if (!houdini_mode.is_testing) {
    return await import_fs_extra.default.mkdirp(filepath);
  }
  return import_memfs.fs.mkdirpSync(filepath);
}
async function mkdirpSync(filepath) {
  if (!houdini_mode.is_testing) {
    return import_fs_extra.default.mkdirpSync(filepath);
  }
  return import_memfs.fs.mkdirpSync(filepath);
}
async function mkdir(filepath) {
  if (!houdini_mode.is_testing) {
    return await import_promises.default.mkdir(filepath);
  }
  return import_memfs.fs.mkdirSync(filepath);
}
async function rmdir(filepath) {
  if (!houdini_mode.is_testing) {
    return await import_promises.default.rm(filepath, {
      recursive: true
    });
  }
  return await (0, import_node_util.promisify)(import_memfs.fs.rmdir)(filepath);
}
async function stat(filepath) {
  if (!houdini_mode.is_testing) {
    return await import_promises.default.stat(filepath);
  }
  if (filepath.includes("build/runtime")) {
    return await import_promises.default.stat(filepath);
  }
  return import_memfs.fs.statSync(filepath);
}
function existsSync(dirPath) {
  if (!houdini_mode.is_testing) {
    return import_fs_extra.default.existsSync(dirPath);
  }
  return import_memfs.fs.existsSync(dirPath);
}
async function readdir(filepath, opts) {
  if (!houdini_mode.is_testing) {
    return await import_promises.default.readdir(filepath, opts);
  }
  if (filepath.includes("build/runtime")) {
    return await import_promises.default.readdir(filepath, opts);
  }
  try {
    return import_memfs.fs.readdirSync(filepath, opts);
  } catch (e3) {
    console.log(e3);
    return [];
  }
}
async function remove(filepath) {
  if (!houdini_mode.is_testing) {
    return await import_promises.default.rm(filepath);
  }
  return import_memfs.vol.rmSync(filepath);
}
async function mock(target, filepath = "") {
  await Promise.all(
    Object.entries(target).map(async ([key, value]) => {
      const childPath = join2(filepath, key);
      if (typeof value === "string") {
        await writeFile(childPath, value);
      } else {
        await mkdirp(childPath);
        return await mock(value, childPath);
      }
    })
  );
}
async function recursiveCopy(source, target, transforms, notRoot) {
  let parentDir = join2(target, basename(source));
  if (!notRoot) {
    parentDir = join2(parentDir, "..");
  }
  try {
    await access(parentDir);
  } catch (e3) {
    await mkdirp(parentDir);
  }
  if ((await stat(source)).isDirectory()) {
    await Promise.all(
      (await readdir(source)).map(async (child) => {
        const childPath = join2(source, child);
        if ((await stat(childPath)).isDirectory()) {
          await recursiveCopy(childPath, parentDir, transforms, true);
        } else {
          const targetPath = join2(parentDir, child);
          let original = await readFile(childPath) || "";
          if (transforms?.[childPath]) {
            original = await transforms[childPath](original, childPath);
          }
          await writeFile(targetPath, original);
        }
      })
    );
  }
}
function snapshot(base) {
  return Object.fromEntries(
    Object.entries(import_memfs.vol.toJSON()).filter(([key]) => !base || key.startsWith(base)).map(([key, value]) => [!base ? key : key.substring(base.length), value])
  );
}
async function glob(pattern) {
  return await (0, import_node_util.promisify)(import_glob.glob)(posixify(pattern));
}
glob.hasMagic = import_glob.glob.hasMagic;

// ../../node_modules/.pnpm/esm-env@1.0.0/node_modules/esm-env/prod-ssr.js
var BROWSER = false;

// ../../node_modules/.pnpm/@kitql+helpers@0.8.2/node_modules/@kitql/helpers/dist/colors/stylesNode.js
var stylesNode_exports = {};
__export(stylesNode_exports, {
  bgBlack: () => bgBlack,
  bgBlackBright: () => bgBlackBright,
  bgBlue: () => bgBlue,
  bgBlueBright: () => bgBlueBright,
  bgCyan: () => bgCyan,
  bgCyanBright: () => bgCyanBright,
  bgGreen: () => bgGreen,
  bgGreenBright: () => bgGreenBright,
  bgMagenta: () => bgMagenta,
  bgMagentaBright: () => bgMagentaBright,
  bgRed: () => bgRed,
  bgRedBright: () => bgRedBright,
  bgWhite: () => bgWhite,
  bgWhiteBright: () => bgWhiteBright,
  bgYellow: () => bgYellow,
  bgYellowBright: () => bgYellowBright,
  black: () => black,
  blackBright: () => blackBright,
  blue: () => blue,
  blueBright: () => blueBright,
  bold: () => bold,
  cyan: () => cyan,
  cyanBright: () => cyanBright,
  dim: () => dim,
  gray: () => gray,
  green: () => green,
  greenBright: () => greenBright,
  hidden: () => hidden,
  inverse: () => inverse,
  italic: () => italic,
  magenta: () => magenta,
  magentaBright: () => magentaBright,
  red: () => red,
  redBright: () => redBright,
  reset: () => reset,
  strikethrough: () => strikethrough,
  underline: () => underline,
  white: () => white,
  whiteBright: () => whiteBright,
  yellow: () => yellow,
  yellowBright: () => yellowBright
});
var reset = { start: "\x1B[0m", end: "\x1B[0m" };
var bold = { start: "\x1B[1m", end: "\x1B[22m" };
var dim = { start: "\x1B[2m", end: "\x1B[22m" };
var italic = { start: "\x1B[3m", end: "\x1B[23m" };
var underline = { start: "\x1B[4m", end: "\x1B[24m" };
var inverse = { start: "\x1B[7m", end: "\x1B[27m" };
var hidden = { start: "\x1B[8m", end: "\x1B[28m" };
var strikethrough = { start: "\x1B[9m", end: "\x1B[29m" };
var black = { start: "\x1B[30m", end: "\x1B[39m" };
var red = { start: "\x1B[31m", end: "\x1B[39m" };
var green = { start: "\x1B[32m", end: "\x1B[39m" };
var yellow = { start: "\x1B[33m", end: "\x1B[39m" };
var blue = { start: "\x1B[34m", end: "\x1B[39m" };
var magenta = { start: "\x1B[35m", end: "\x1B[39m" };
var cyan = { start: "\x1B[36m", end: "\x1B[39m" };
var white = { start: "\x1B[37m", end: "\x1B[39m" };
var gray = { start: "\x1B[90m", end: "\x1B[39m" };
var bgBlack = { start: "\x1B[40m", end: "\x1B[49m" };
var bgRed = { start: "\x1B[41m", end: "\x1B[49m" };
var bgGreen = { start: "\x1B[42m", end: "\x1B[49m" };
var bgYellow = { start: "\x1B[43m", end: "\x1B[49m" };
var bgBlue = { start: "\x1B[44m", end: "\x1B[49m" };
var bgMagenta = { start: "\x1B[45m", end: "\x1B[49m" };
var bgCyan = { start: "\x1B[46m", end: "\x1B[49m" };
var bgWhite = { start: "\x1B[47m", end: "\x1B[49m" };
var blackBright = { start: "\x1B[90m", end: "\x1B[39m" };
var redBright = { start: "\x1B[91m", end: "\x1B[39m" };
var greenBright = { start: "\x1B[92m", end: "\x1B[39m" };
var yellowBright = { start: "\x1B[93m", end: "\x1B[39m" };
var blueBright = { start: "\x1B[94m", end: "\x1B[39m" };
var magentaBright = { start: "\x1B[95m", end: "\x1B[39m" };
var cyanBright = { start: "\x1B[96m", end: "\x1B[39m" };
var whiteBright = { start: "\x1B[97m", end: "\x1B[39m" };
var bgBlackBright = { start: "\x1B[100m", end: "\x1B[49m" };
var bgRedBright = { start: "\x1B[101m", end: "\x1B[49m" };
var bgGreenBright = { start: "\x1B[102m", end: "\x1B[49m" };
var bgYellowBright = { start: "\x1B[103m", end: "\x1B[49m" };
var bgBlueBright = { start: "\x1B[104m", end: "\x1B[49m" };
var bgMagentaBright = { start: "\x1B[105m", end: "\x1B[49m" };
var bgCyanBright = { start: "\x1B[106m", end: "\x1B[49m" };
var bgWhiteBright = { start: "\x1B[107m", end: "\x1B[49m" };

// ../../node_modules/.pnpm/@kitql+helpers@0.8.2/node_modules/@kitql/helpers/dist/colors/index.js
var getStyleNode = (styleKey) => {
  return stylesNode_exports[styleKey] ?? void 0;
};
var color = (style, str) => {
  return BROWSER ? colorBrowser(style, str) : colorNode(style, str);
};
var colorNode = (style, str) => {
  return `${getStyleNode(style).start}${str}${getStyleNode(style).end}`;
};
var START1 = `$$KitQL_`;
var START2 = `_KitQL$$`;
var END = `$$KitQLEND$$`;
var colorBrowser = (style, str) => {
  return `${START1}${style}${START2}${str}${END}`;
};
var green2 = (str) => {
  return color("green", str);
};
var yellow2 = (str) => {
  return color("yellow", str);
};
var cyan2 = (str) => {
  return color("cyan", str);
};

// src/lib/introspection.ts
var graphql = __toESM(require("graphql"), 1);

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/index.js
var import_node_http2 = __toESM(require("node:http"), 1);
var import_node_https = __toESM(require("node:https"), 1);
var import_node_zlib = __toESM(require("node:zlib"), 1);
var import_node_stream2 = __toESM(require("node:stream"), 1);
var import_node_buffer2 = require("node:buffer");

// ../../node_modules/.pnpm/data-uri-to-buffer@4.0.0/node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default = dataUriToBuffer;

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/body.js
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_util2 = require("node:util");
var import_node_buffer = require("node:buffer");
init_fetch_blob();
init_esm_min();

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
var isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};
var isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/body.js
var pipeline = (0, import_node_util2.promisify)(import_node_stream.default.pipeline);
var INTERNALS = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = import_node_buffer.Buffer.from(body.toString());
    } else if (isBlob(body)) {
    } else if (import_node_buffer.Buffer.isBuffer(body)) {
    } else if (import_node_util2.types.isAnyArrayBuffer(body)) {
      body = import_node_buffer.Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_node_stream.default) {
    } else if (body instanceof FormData2) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = import_node_buffer.Buffer.from(String(body));
    }
    let stream = body;
    if (import_node_buffer.Buffer.isBuffer(body)) {
      stream = import_node_stream.default.Readable.from(body);
    } else if (isBlob(body)) {
      stream = import_node_stream.default.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_node_stream.default) {
      body.on("error", (error_) => {
        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData2();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = (0, import_node_util2.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: (0, import_node_util2.deprecate)(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return import_node_buffer.Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return import_node_buffer.Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c2) => typeof c2 === "string")) {
        return import_node_buffer.Buffer.from(accum.join(""));
      }
      return import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p22;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_node_stream.PassThrough({ highWaterMark });
    p22 = new import_node_stream.PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p22);
    instance[INTERNALS].stream = p1;
    body = p22;
  }
  return body;
};
var getNonSpecFormDataBoundary = (0, import_node_util2.deprecate)(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
);
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (import_node_buffer.Buffer.isBuffer(body) || import_node_util2.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData2) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof import_node_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (import_node_buffer.Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/headers.js
var import_node_util3 = require("node:util");
var import_node_http = __toESM(require("node:http"), 1);
var validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error;
  }
};
var validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
    throw error;
  }
};
var Headers = class extends URLSearchParams {
  constructor(init3) {
    let result = [];
    if (init3 instanceof Headers) {
      const raw = init3.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init3 == null) {
    } else if (typeof init3 === "object" && !import_node_util3.types.isBoxedPrimitive(init3)) {
      const method = init3[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init3));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init3].map((pair) => {
          if (typeof pair !== "object" || import_node_util3.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p3, receiver) {
        switch (p3) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p3].call(
                target,
                String(name).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p3].call(
                target,
                String(name).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p3, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = void 0) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(
  Headers.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => {
    result[property] = { enumerable: true };
    return result;
  }, {})
);
function fromRawHeaders(headers = []) {
  return new Headers(
    headers.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch {
        return false;
      }
    })
  );
}

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new Response2(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  static json(data = void 0, init3 = {}) {
    const body = JSON.stringify(data);
    if (body === void 0) {
      throw new TypeError("data is not JSON serializable");
    }
    const headers = new Headers(init3 && init3.headers);
    if (!headers.has("content-type")) {
      headers.set("content-type", "application/json");
    }
    return new Response2(body, {
      ...init3,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/request.js
var import_node_url = require("node:url");
var import_node_util4 = require("node:util");

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/utils/referrer.js
var import_node_net = require("node:net");
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var doBadDataWarn = (0, import_node_util4.deprecate)(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
);
var Request2 = class extends Body {
  constructor(input, init3 = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init3.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init3) && "data" in init3) {
      doBadDataWarn();
    }
    if ((init3.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init3.body ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init3.size || input.size || 0
    });
    const headers = new Headers(init3.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init3) {
      signal = init3.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init3.referrer == null ? input.referrer : init3.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = void 0;
    }
    this[INTERNALS3] = {
      method,
      redirect: init3.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init3.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init3.follow;
    this.compress = init3.compress === void 0 ? input.compress === void 0 ? true : input.compress : init3.compress;
    this.counter = init3.counter || input.counter || 0;
    this.agent = init3.agent || input.agent;
    this.highWaterMark = init3.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init3.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init3.referrerPolicy || input.referrerPolicy || "";
  }
  get method() {
    return this[INTERNALS3].method;
  }
  get url() {
    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
  }
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  get signal() {
    return this[INTERNALS3].signal;
  }
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return void 0;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  clone() {
    return new Request2(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request2.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const options = {
    path: parsedURL.pathname + search,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    parsedURL,
    options
  };
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// ../../node_modules/.pnpm/node-fetch@3.3.0/node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response2(body, responseOptions);
            resolve2(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer2.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}

// src/lib/introspection.ts
async function pullSchema(url, schemaPath, headers, skipWriting) {
  let content = "";
  try {
    const resp = await fetch(url, {
      method: "POST",
      body: JSON.stringify({
        query: graphql.getIntrospectionQuery()
      }),
      headers: { "Content-Type": "application/json", ...headers }
    });
    content = await resp.text();
    const jsonSchema = JSON.parse(content).data;
    let fileData = "";
    if (schemaPath.endsWith("gql") || schemaPath.endsWith("graphql")) {
      const schema = graphql.buildClientSchema(jsonSchema);
      fileData = graphql.printSchema(graphql.lexicographicSortSchema(schema));
    } else {
      fileData = JSON.stringify(jsonSchema);
    }
    if (!skipWriting) {
      await writeFile(schemaPath, fileData);
    }
    return fileData;
  } catch (e3) {
    if (content) {
      console.warn(
        `\u26A0\uFE0F  Couldn't pull your schema.
${cyan2("   Reponse:")} ${content}
${cyan2("   Error  :")} ${e3.message}`
      );
    } else {
      console.warn(`\u26A0\uFE0F  Couldn't pull your schema: ${e3.message}`);
    }
  }
  return null;
}
function extractHeadersStr(str) {
  const regex = /(\w+)=("[^"]*"|[^ ]*)/g;
  const obj = {};
  let match;
  while ((match = regex.exec(str ?? "")) !== null) {
    obj[match[1]] = match[2].replaceAll('"', "");
  }
  return obj;
}
function extractHeaders(headers) {
  if ((headers ?? []).length > 0) {
    return headers.reduce((total, header) => {
      const [key, value] = header.split(/=(.*)/s);
      return {
        ...total,
        [key]: value.replaceAll('"', "")
      };
    }, {});
  }
  return {};
}

// src/lib/plugin.ts
function plugin(name, hooks) {
  const data = {
    name,
    plugin: hooks,
    __plugin_init__: true,
    with(config) {
      return {
        ...data,
        config
      };
    }
  };
  return data;
}

// src/runtime/lib/flatten.ts
function flatten(source) {
  if (!source) {
    return [];
  }
  return source.reduce((acc, element) => {
    if (!element) {
      return acc;
    }
    if (Array.isArray(element)) {
      return acc.concat(flatten(element));
    }
    return acc.concat(element);
  }, []);
}

// src/runtime/cache/gc.ts
var GarbageCollector = class {
  cache;
  lifetimes = /* @__PURE__ */ new Map();
  get cacheBufferSize() {
    return this.cache._internal_unstable.config.cacheBufferSize ?? 10;
  }
  constructor(cache) {
    this.cache = cache;
  }
  reset() {
    this.lifetimes.clear();
  }
  resetLifetime(id, field) {
    if (!this.lifetimes.get(id)) {
      this.lifetimes.set(id, /* @__PURE__ */ new Map());
    }
    this.lifetimes.get(id).set(field, 0);
  }
  tick() {
    const dt_tick = Date.now().valueOf();
    const config_max_time = this.cache._internal_unstable.config.defaultLifetime;
    for (const [id, fieldMap] of this.lifetimes.entries()) {
      for (const [field, lifetime] of fieldMap.entries()) {
        if (this.cache._internal_unstable.subscriptions.get(id, field).length > 0) {
          continue;
        }
        fieldMap.set(field, lifetime + 1);
        if (fieldMap.get(field) > this.cacheBufferSize) {
          this.cache._internal_unstable.storage.deleteField(id, field);
          this.cache._internal_unstable.lists.deleteField(id, field);
          fieldMap.delete(field);
          if ([...fieldMap.keys()].length === 0) {
            this.lifetimes.delete(id);
          }
          this.cache._internal_unstable.staleManager.delete(id, field);
        }
        if (config_max_time && config_max_time > 0) {
          const dt_valueOf = this.cache.getFieldTime(id, field);
          if (dt_valueOf && dt_tick - dt_valueOf > config_max_time) {
            this.cache._internal_unstable.staleManager.markFieldStale(id, field);
          }
        }
      }
    }
  }
};

// src/runtime/cache/lists.ts
var ListManager = class {
  rootID;
  cache;
  constructor(cache, rootID2) {
    this.rootID = rootID2;
    this.cache = cache;
  }
  lists = /* @__PURE__ */ new Map();
  listsByField = /* @__PURE__ */ new Map();
  get(listName, id, allLists) {
    const matches = this.lists.get(listName);
    if (!matches || matches.size === 0) {
      return null;
    }
    if (allLists) {
      return new ListCollection(
        Array.from(matches, ([key, value]) => [...value.lists]).flat()
      );
    }
    const head = [...matches.values()][0];
    const { recordType } = head.lists[0];
    const parentID = id ? this.cache._internal_unstable.id(recordType || "", id) : this.rootID;
    if (matches?.size === 1) {
      if (!id) {
        return head;
      }
      return parentID === Array.from(matches.keys())[0] ? head : null;
    }
    if (!id) {
      console.error(
        `Found multiple instances of "${listName}". Please provide one of @parentID or @allLists directives to help identify which list you want modify. For more information, visit this guide: https://www.houdinigraphql.com/api/graphql#parentidvalue-string `
      );
      return null;
    }
    return this.lists.get(listName)?.get(parentID);
  }
  remove(listName, id) {
    this.lists.get(listName)?.delete(id || this.rootID);
  }
  add(list) {
    if (!this.lists.has(list.name)) {
      this.lists.set(list.name, /* @__PURE__ */ new Map());
    }
    const name = list.name;
    const parentID = list.recordID || this.rootID;
    if (this.lists.get(name)?.get(parentID)?.includes(list.key)) {
      return;
    }
    if (!this.lists.has(name)) {
      this.lists.set(name, /* @__PURE__ */ new Map());
    }
    if (!this.lists.get(name).has(parentID)) {
      this.lists.get(name).set(parentID, new ListCollection([]));
    }
    if (!this.listsByField.has(parentID)) {
      this.listsByField.set(parentID, /* @__PURE__ */ new Map());
    }
    if (!this.listsByField.get(parentID).has(list.key)) {
      this.listsByField.get(parentID)?.set(list.key, []);
    }
    const handler = new List({ ...list, manager: this });
    this.lists.get(list.name).get(parentID).lists.push(handler);
    this.listsByField.get(parentID).get(list.key).push(handler);
  }
  removeIDFromAllLists(id, layer) {
    for (const fieldMap of this.lists.values()) {
      for (const list of fieldMap.values()) {
        list.removeID(id, void 0, layer);
      }
    }
  }
  deleteField(parentID, field) {
    if (!this.listsByField.get(parentID)?.has(field)) {
      return;
    }
    for (const list of this.listsByField.get(parentID).get(field)) {
      this.lists.get(list.name)?.get(list.recordID)?.deleteListWithKey(field);
      if (this.lists.get(list.name)?.get(list.recordID)?.lists.length === 0) {
        this.lists.get(list.name)?.delete(list.recordID);
      }
    }
    this.listsByField.get(parentID).delete(field);
  }
  reset() {
    this.lists.clear();
    this.listsByField.clear();
  }
};
var List = class {
  recordID;
  recordType;
  key;
  type;
  cache;
  selection;
  _when;
  filters;
  name;
  connection;
  manager;
  abstract;
  constructor({
    name,
    recordID,
    recordType,
    key,
    listType,
    selection,
    when,
    filters,
    connection,
    manager,
    abstract
  }) {
    this.recordID = recordID || rootID;
    this.recordType = recordType;
    this.key = key;
    this.type = listType;
    this.cache = manager.cache;
    this.selection = selection;
    this._when = when;
    this.filters = filters;
    this.name = name;
    this.connection = connection;
    this.manager = manager;
    this.abstract = abstract;
  }
  when(when) {
    return this.manager.lists.get(this.name).get(this.recordID).when(when);
  }
  append({
    selection,
    data,
    variables = {},
    layer
  }) {
    return this.addToList(selection, data, variables, "last", layer);
  }
  prepend({
    selection,
    data,
    variables = {},
    layer
  }) {
    return this.addToList(selection, data, variables, "first", layer);
  }
  addToList(selection, data, variables = {}, where, layer) {
    const listType = this.listType(data);
    const dataID = this.cache._internal_unstable.id(listType, data);
    if (!this.validateWhen() || !dataID) {
      return;
    }
    let insertSelection = selection;
    let insertData = data;
    if (this.connection) {
      insertSelection = {
        fields: {
          newEntry: {
            keyRaw: this.key,
            type: "Connection",
            selection: {
              fields: {
                edges: {
                  keyRaw: "edges",
                  type: "ConnectionEdge",
                  updates: ["append", "prepend"],
                  selection: {
                    fields: {
                      __typename: {
                        keyRaw: "__typename",
                        type: "String"
                      },
                      node: {
                        type: listType,
                        keyRaw: "node",
                        selection: {
                          ...selection,
                          fields: {
                            ...selection.fields,
                            __typename: {
                              keyRaw: "__typename",
                              type: "String"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      insertData = {
        newEntry: {
          edges: [
            {
              __typename: listType + "Edge",
              node: {
                ...data,
                __typename: listType
              }
            }
          ]
        }
      };
    } else {
      insertSelection = {
        fields: {
          newEntries: {
            keyRaw: this.key,
            type: listType,
            updates: ["append", "prepend"],
            selection: {
              ...selection,
              fields: {
                ...selection.fields,
                __typename: {
                  keyRaw: "__typename",
                  type: "String"
                }
              }
            }
          }
        }
      };
      insertData = {
        newEntries: [{ ...data, __typename: listType }]
      };
    }
    this.cache.write({
      selection: insertSelection,
      data: insertData,
      variables,
      parent: this.recordID,
      applyUpdates: [where === "first" ? "prepend" : "append"],
      layer: layer?.id
    });
  }
  removeID(id, variables = {}, layer) {
    if (!this.validateWhen()) {
      return;
    }
    let parentID = this.recordID;
    let targetID = id;
    let targetKey = this.key;
    if (this.connection) {
      const { value: embeddedConnection } = this.cache._internal_unstable.storage.get(
        this.recordID,
        this.key
      );
      if (!embeddedConnection) {
        return;
      }
      const embeddedConnectionID = embeddedConnection;
      const { value: edges } = this.cache._internal_unstable.storage.get(
        embeddedConnectionID,
        "edges"
      );
      for (const edge of flatten(edges) || []) {
        if (!edge) {
          continue;
        }
        const edgeID = edge;
        const { value: nodeID } = this.cache._internal_unstable.storage.get(edgeID, "node");
        if (!nodeID) {
          continue;
        }
        if (nodeID === id) {
          targetID = edgeID;
        }
      }
      parentID = embeddedConnectionID;
      targetKey = "edges";
    }
    let value = this.cache._internal_unstable.storage.get(parentID, targetKey).value;
    if (!value || !value.includes(targetID)) {
      return;
    }
    const subscribers = this.cache._internal_unstable.subscriptions.get(this.recordID, this.key);
    this.cache._internal_unstable.subscriptions.remove(
      targetID,
      this.connection ? this.selection.fields.edges.selection : this.selection,
      subscribers.map((sub) => sub[0]),
      variables
    );
    this.cache._internal_unstable.storage.remove(parentID, targetKey, targetID, layer);
    for (const [spec] of subscribers) {
      spec.set(
        this.cache._internal_unstable.getSelection({
          parent: spec.parentID || this.manager.rootID,
          selection: spec.selection,
          variables: spec.variables?.() || {},
          ignoreMasking: false
        }).data
      );
    }
    return true;
  }
  remove(data, variables = {}, layer) {
    const targetID = this.cache._internal_unstable.id(this.listType(data), data);
    if (!targetID) {
      return;
    }
    return this.removeID(targetID, variables, layer);
  }
  listType(data) {
    return data.__typename || this.type;
  }
  validateWhen(when) {
    let filters = when || this._when;
    let ok = true;
    if (filters) {
      const targets = this.filters;
      if (filters.must && targets) {
        ok = Object.entries(filters.must).reduce(
          (prev, [key, value]) => Boolean(prev && targets[key] == value),
          ok
        );
      }
      if (filters.must_not) {
        ok = !targets || Object.entries(filters.must_not).reduce(
          (prev, [key, value]) => Boolean(prev && targets[key] != value),
          ok
        );
      }
    }
    return ok;
  }
  toggleElement({
    selection,
    data,
    variables = {},
    layer,
    where
  }) {
    if (!this.remove(data, variables, layer)) {
      this.addToList(selection, data, variables, where, layer);
    }
  }
  *[Symbol.iterator]() {
    let entries = [];
    let value = this.cache._internal_unstable.storage.get(this.recordID, this.key).value;
    if (!this.connection) {
      entries = flatten(value);
    } else {
      entries = this.cache._internal_unstable.storage.get(value, "edges").value;
    }
    for (let record2 of entries) {
      yield record2;
    }
  }
};
var ListCollection = class {
  lists = [];
  constructor(lists) {
    this.lists = lists;
  }
  get selection() {
    return this.lists[0].selection;
  }
  append(...args) {
    this.lists.forEach((list) => list.append(...args));
  }
  prepend(...args) {
    this.lists.forEach((list) => list.prepend(...args));
  }
  addToList(...args) {
    this.lists.forEach((list) => list.addToList(...args));
  }
  removeID(...args) {
    this.lists.forEach((list) => list.removeID(...args));
  }
  remove(...args) {
    this.lists.forEach((list) => list.remove(...args));
  }
  toggleElement(...args) {
    this.lists.forEach((list) => list.toggleElement(...args));
  }
  when(when) {
    return new ListCollection(
      this.lists.filter((list) => {
        return list.validateWhen(when);
      })
    );
  }
  includes(key) {
    return !!this.lists.find((list) => list.key === key);
  }
  deleteListWithKey(key) {
    return this.lists = this.lists.filter((list) => list.key !== key);
  }
  *[Symbol.iterator]() {
    for (let list of this.lists) {
      for (const entry of list) {
        yield entry;
      }
    }
  }
};

// src/runtime/cache/staleManager.ts
var StaleManager = class {
  cache;
  fieldsTime = /* @__PURE__ */ new Map();
  constructor(cache) {
    this.cache = cache;
  }
  #initMapId = (id) => {
    if (!this.fieldsTime.get(id)) {
      this.fieldsTime.set(id, /* @__PURE__ */ new Map());
    }
  };
  getFieldTime(id, field) {
    return this.fieldsTime.get(id)?.get(field);
  }
  setFieldTimeToNow(id, field) {
    this.#initMapId(id);
    this.fieldsTime.get(id)?.set(field, new Date().valueOf());
  }
  markFieldStale(id, field) {
    this.#initMapId(id);
    this.fieldsTime.get(id)?.set(field, null);
  }
  markAllStale() {
    for (const [id, fieldMap] of this.fieldsTime.entries()) {
      for (const [field] of fieldMap.entries()) {
        this.markFieldStale(id, field);
      }
    }
  }
  markRecordStale(id) {
    const fieldsTimeOfType = this.fieldsTime.get(id);
    if (fieldsTimeOfType) {
      for (const [field] of fieldsTimeOfType.entries()) {
        this.markFieldStale(id, field);
      }
    }
  }
  markTypeStale(type) {
    for (const [id, fieldMap] of this.fieldsTime.entries()) {
      if (id.startsWith(`${type}:`)) {
        for (const [field] of fieldMap.entries()) {
          this.markFieldStale(id, field);
        }
      }
    }
  }
  markTypeFieldStale(type, field, when) {
    const key = computeKey({ field, args: when });
    for (const [id, fieldMap] of this.fieldsTime.entries()) {
      if (id.startsWith(`${type}:`)) {
        for (const local_field of fieldMap.keys()) {
          if (local_field === key) {
            this.markFieldStale(id, field);
          }
        }
      }
    }
  }
  delete(id, field) {
    if (this.fieldsTime.has(id)) {
      this.fieldsTime.get(id)?.delete(field);
      if (this.fieldsTime.get(id)?.size === 0) {
        this.fieldsTime.delete(id);
      }
    }
  }
  reset() {
    this.fieldsTime.clear();
  }
};

// src/runtime/cache/storage.ts
var InMemoryStorage = class {
  data;
  idCount = 1;
  rank = 0;
  constructor() {
    this.data = [];
  }
  get layerCount() {
    return this.data.length;
  }
  get nextRank() {
    return this.rank++;
  }
  createLayer(optimistic = false) {
    const layer = new Layer(this.idCount++);
    layer.optimistic = optimistic;
    this.data.push(layer);
    return layer;
  }
  insert(id, field, location, target) {
    return this.topLayer.insert(id, field, location, target);
  }
  remove(id, field, target, layerToUser = this.topLayer) {
    return layerToUser.remove(id, field, target);
  }
  delete(id, layerToUser = this.topLayer) {
    return layerToUser.delete(id);
  }
  deleteField(id, field) {
    return this.topLayer.deleteField(id, field);
  }
  getLayer(id) {
    for (const layer of this.data) {
      if (layer.id === id) {
        return layer;
      }
    }
    throw new Error("Could not find layer with id: " + id);
  }
  replaceID(replacement) {
    for (const layer of this.data) {
      layer.replaceID(replacement);
    }
  }
  get(id, field, defaultValue) {
    const operations = {
      [OperationKind.insert]: {
        [OperationLocation.start]: [],
        [OperationLocation.end]: []
      },
      [OperationKind.remove]: /* @__PURE__ */ new Set()
    };
    const layerIDs = [];
    for (let i2 = this.data.length - 1; i2 >= 0; i2--) {
      const layer = this.data[i2];
      let [layerValue, kind] = layer.get(id, field);
      const layerOperations = layer.getOperations(id, field) || [];
      layer.deletedIDs.forEach((v2) => {
        if (layer.operations[v2]?.undoDeletesInList?.includes(field)) {
          return;
        }
        operations.remove.add(v2);
      });
      if (typeof layerValue === "undefined" && defaultValue) {
        const targetLayer = this.topLayer;
        const layerID = targetLayer.id;
        targetLayer.writeField(id, field, defaultValue);
        layerValue = defaultValue;
      }
      if (typeof layerValue === "undefined" && layerOperations.length === 0) {
        if (layer.deletedIDs.size > 0) {
          layerIDs.push(layer.id);
        }
        continue;
      }
      if (typeof layerValue !== "undefined" && !Array.isArray(layerValue)) {
        return {
          value: layerValue,
          kind,
          displayLayers: [layer.id]
        };
      }
      layerIDs.push(layer.id);
      if (layerOperations.length > 0) {
        for (const op of layerOperations) {
          if (isRemoveOperation(op)) {
            operations.remove.add(op.id);
          }
          if (isInsertOperation(op)) {
            operations.insert[op.location].unshift(op.id);
          }
          if (isDeleteOperation(op)) {
            return {
              value: void 0,
              kind: "unknown",
              displayLayers: []
            };
          }
        }
      }
      if (typeof layerValue === "undefined") {
        continue;
      }
      if (!operations.remove.size && !operations.insert.start.length && !operations.insert.end.length) {
        return { value: layerValue, displayLayers: layerIDs, kind: "link" };
      }
      return {
        value: [...operations.insert.start, ...layerValue, ...operations.insert.end].filter(
          (value) => !operations.remove.has(value)
        ),
        displayLayers: layerIDs,
        kind
      };
    }
    return {
      value: void 0,
      kind: "unknown",
      displayLayers: []
    };
  }
  writeLink(id, field, value) {
    return this.topLayer.writeLink(id, field, value);
  }
  writeField(id, field, value) {
    return this.topLayer.writeField(id, field, value);
  }
  resolveLayer(id) {
    let startingIndex = null;
    for (const [index, layer] of this.data.entries()) {
      if (layer.id !== id) {
        continue;
      }
      startingIndex = index - 1;
      this.data[index].optimistic = false;
      break;
    }
    if (startingIndex === null) {
      throw new Error("could not find layer with id: " + id);
    }
    if (startingIndex === -1) {
      startingIndex = 0;
    }
    if (this.data[startingIndex].optimistic) {
      startingIndex++;
    }
    const baseLayer = this.data[startingIndex];
    let layerIndex = startingIndex;
    while (layerIndex < this.data.length) {
      const layer = this.data[layerIndex++];
      if (layer.optimistic) {
        layerIndex--;
        break;
      }
      baseLayer.writeLayer(layer);
    }
    this.data.splice(startingIndex + 1, layerIndex - startingIndex - 1);
  }
  get topLayer() {
    if (this.data.length === 0) {
      this.createLayer();
    }
    if (this.data[this.data.length - 1]?.optimistic) {
      this.createLayer();
    }
    return this.data[this.data.length - 1];
  }
  serialize() {
    return JSON.stringify({
      rank: this.rank,
      fields: Object.fromEntries(
        Object.entries(this.topLayer.fields).map(([id, fieldMap]) => [
          id,
          Object.fromEntries(
            Object.entries(fieldMap).filter(([_3, value]) => typeof value !== "function")
          )
        ])
      ),
      links: this.topLayer.links
    });
  }
  hydrate(args, layer) {
    if (!args) {
      return;
    }
    const { rank, fields, links } = args;
    this.rank = rank;
    layer ??= this.createLayer(true);
    layer.fields = fields;
    layer.links = links;
  }
  reset() {
    this.data = [];
  }
};
var Layer = class {
  id;
  optimistic = false;
  fields = {};
  links = {};
  operations = {};
  deletedIDs = /* @__PURE__ */ new Set();
  constructor(id) {
    this.id = id;
  }
  get(id, field) {
    if (typeof this.links[id]?.[field] !== "undefined") {
      return [this.links[id][field], "link"];
    }
    return [this.fields[id]?.[field], "scalar"];
  }
  getOperations(id, field) {
    if (this.operations[id]?.deleted) {
      return [
        {
          kind: OperationKind.delete,
          target: id
        }
      ];
    }
    if (this.operations[id]?.fields?.[field]) {
      return this.operations[id].fields[field];
    }
  }
  writeField(id, field, value) {
    this.fields[id] = {
      ...this.fields[id],
      [field]: value
    };
    return this.id;
  }
  writeLink(id, field, value) {
    const valueList = Array.isArray(value) ? value : [value];
    for (const value2 of flatten(valueList)) {
      if (!value2) {
        continue;
      }
      const fieldOperations = this.operations[id]?.fields[field];
      if (this.operations[value2]?.deleted || this.deletedIDs.has(value2)) {
        this.operations[value2] = {
          ...this.operations[value2],
          undoDeletesInList: [...this.operations[id]?.undoDeletesInList || [], field]
        };
      } else if (value2 && fieldOperations?.length > 0) {
        this.operations[id].fields[field] = fieldOperations.filter(
          (op) => op.kind !== "remove" || op.id !== value2
        );
      }
    }
    this.links[id] = {
      ...this.links[id],
      [field]: value
    };
    return this.id;
  }
  isDisplayLayer(displayLayers) {
    return displayLayers.length === 0 || displayLayers.includes(this.id) || Math.max(...displayLayers) < this.id;
  }
  clear() {
    this.links = {};
    this.fields = {};
    this.operations = {};
    this.deletedIDs = /* @__PURE__ */ new Set();
  }
  replaceID({ from, to }) {
    this.fields[to] = this.fields[from];
    this.links[to] = this.links[from];
    this.operations[to] = this.operations[from] || { fields: {} };
    if (this.deletedIDs.has(from)) {
      this.deletedIDs.add(to);
    }
  }
  removeUndefinedFields() {
    for (const [id, fields] of Object.entries(this.fields)) {
      for (const [field, value] of Object.entries(fields)) {
        if (typeof value === "undefined") {
          try {
            delete this.fields[id][field];
          } catch {
          }
          try {
            delete this.links[id][field];
          } catch {
          }
        }
      }
      if (Object.keys(fields || {}).length === 0) {
        delete this.fields[id];
      }
      if (Object.keys(this.links[id] || {}).length === 0) {
        delete this.links[id];
      }
    }
  }
  delete(id) {
    this.operations = {
      ...this.operations,
      [id]: {
        ...this.operations[id],
        deleted: true,
        undoDeletesInList: []
      }
    };
    this.deletedIDs.add(id);
  }
  deleteField(id, field) {
    this.fields[id] = {
      ...this.fields[id],
      [field]: void 0
    };
  }
  insert(id, field, where, target) {
    this.addFieldOperation(id, field, {
      kind: OperationKind.insert,
      id: target,
      location: where
    });
  }
  remove(id, field, target) {
    this.addFieldOperation(id, field, {
      kind: OperationKind.remove,
      id: target
    });
  }
  writeLayer(layer) {
    if (layer.id === this.id) {
      return;
    }
    for (const [id, ops] of Object.entries(layer.operations)) {
      const fields = {};
      for (const opMap of [this.operations[id], layer.operations[id]].filter(Boolean)) {
        for (const [fieldName, operations] of Object.entries(opMap.fields || {})) {
          fields[fieldName] = [...fields[fieldName] || [], ...operations];
        }
      }
      if (Object.keys(fields).length > 0) {
        this.operations[id] = {
          ...this.operations[id],
          fields
        };
      }
      if (ops?.deleted) {
        delete this.fields[id];
        delete this.links[id];
      }
    }
    for (const [id, values] of Object.entries(layer.fields)) {
      if (!values) {
        continue;
      }
      for (const [field, value] of Object.entries(values)) {
        this.writeField(id, field, value);
      }
    }
    for (const [id, values] of Object.entries(layer.links)) {
      if (!values) {
        continue;
      }
      for (const [field, value] of Object.entries(values)) {
        this.writeLink(id, field, value);
      }
    }
    layer.deletedIDs.forEach((v2) => this.deletedIDs.add(v2));
  }
  addFieldOperation(id, field, operation) {
    this.operations = {
      ...this.operations,
      [id]: {
        ...this.operations[id],
        fields: {
          [field]: [...this.operations[id]?.fields[field] || [], operation]
        }
      }
    };
  }
};
function isDeleteOperation(value) {
  return !!value && value.kind === OperationKind.delete;
}
function isInsertOperation(value) {
  return !!value && value.kind === OperationKind.insert;
}
function isRemoveOperation(value) {
  return !!value && value.kind === OperationKind.remove;
}
var OperationLocation = {
  start: "start",
  end: "end"
};
var OperationKind = {
  delete: "delete",
  insert: "insert",
  remove: "remove"
};

// src/runtime/cache/stuff.ts
function evaluateKey(key, variables = null) {
  let evaluated = "";
  let varName = "";
  let inString = false;
  for (const char of key) {
    if (varName) {
      if (varChars.includes(char)) {
        varName += char;
        continue;
      }
      const value = variables?.[varName.slice(1)];
      evaluated += typeof value !== "undefined" ? JSON.stringify(value) : "undefined";
      varName = "";
    }
    if (char === "$" && !inString) {
      varName = "$";
      continue;
    }
    if (char === '"') {
      inString = !inString;
    }
    evaluated += char;
  }
  return evaluated;
}
var varChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789";

// src/runtime/cache/subscription.ts
var InMemorySubscriptions = class {
  cache;
  constructor(cache) {
    this.cache = cache;
  }
  subscribers = {};
  referenceCounts = {};
  keyVersions = {};
  activeFields(parent2) {
    return Object.keys(this.subscribers[parent2] || {});
  }
  add({
    parent: parent2,
    spec,
    selection,
    variables,
    parentType
  }) {
    const __typename = this.cache._internal_unstable.storage.get(parent2, "__typename").value;
    let targetSelection = getFieldsForType(selection, __typename, false);
    for (const fieldSelection of Object.values(targetSelection || {})) {
      const {
        keyRaw,
        selection: innerSelection,
        type,
        list,
        filters,
        visible
      } = fieldSelection;
      if (!visible) {
        continue;
      }
      const key = evaluateKey(keyRaw, variables);
      let targetSelection2;
      if (innerSelection) {
        const __typename2 = this.cache._internal_unstable.storage.get(parent2, "__typename").value;
        targetSelection2 = getFieldsForType(innerSelection, __typename2, false);
      }
      this.addFieldSubscription({
        id: parent2,
        key,
        selection: [spec, targetSelection2],
        type
      });
      if (list) {
        this.registerList({
          list,
          filters,
          id: parent2,
          key,
          variables,
          selection: innerSelection,
          parentType: parentType || spec.rootType
        });
      }
      if (innerSelection) {
        const { value: linkedRecord } = this.cache._internal_unstable.storage.get(
          parent2,
          key
        );
        let children = !Array.isArray(linkedRecord) ? [linkedRecord] : flatten(linkedRecord) || [];
        for (const child of children) {
          if (!child) {
            continue;
          }
          this.add({
            parent: child,
            spec,
            selection: innerSelection,
            variables,
            parentType: type
          });
        }
      }
    }
  }
  addFieldSubscription({
    id,
    key,
    selection,
    type
  }) {
    const spec = selection[0];
    if (!this.subscribers[id]) {
      this.subscribers[id] = {};
    }
    if (!this.subscribers[id][key]) {
      this.subscribers[id][key] = [];
    }
    if (!this.keyVersions[key]) {
      this.keyVersions[key] = /* @__PURE__ */ new Set();
    }
    this.keyVersions[key].add(key);
    if (!this.subscribers[id][key].map(([{ set }]) => set).includes(spec.set)) {
      this.subscribers[id][key].push([spec, selection[1]]);
    }
    if (!this.referenceCounts[id]) {
      this.referenceCounts[id] = {};
    }
    if (!this.referenceCounts[id][key]) {
      this.referenceCounts[id][key] = /* @__PURE__ */ new Map();
    }
    const counts = this.referenceCounts[id][key];
    counts.set(spec.set, (counts.get(spec.set) || 0) + 1);
    this.cache._internal_unstable.lifetimes.resetLifetime(id, key);
  }
  registerList({
    list,
    id,
    key,
    parentType,
    selection,
    filters,
    variables
  }) {
    this.cache._internal_unstable.lists.add({
      name: list.name,
      connection: list.connection,
      recordID: id,
      recordType: this.cache._internal_unstable.storage.get(id, "__typename")?.value || parentType,
      listType: list.type,
      key,
      selection,
      filters: Object.entries(filters || {}).reduce((acc, [key2, { kind, value }]) => {
        return {
          ...acc,
          [key2]: kind !== "Variable" ? value : variables[value]
        };
      }, {})
    });
  }
  addMany({
    parent: parent2,
    variables,
    subscribers,
    parentType
  }) {
    for (const [spec, targetSelection] of subscribers) {
      for (const selection of Object.values(targetSelection ?? {})) {
        const {
          type: linkedType,
          keyRaw,
          selection: innerSelection,
          list,
          filters
        } = selection;
        const key = evaluateKey(keyRaw, variables);
        const fieldSelection = innerSelection ? getFieldsForType(innerSelection, parentType, false) : void 0;
        this.addFieldSubscription({
          id: parent2,
          key,
          selection: [spec, fieldSelection],
          type: linkedType
        });
        if (list) {
          this.registerList({
            list,
            filters,
            id: parent2,
            key,
            variables,
            selection: innerSelection,
            parentType: parentType || spec.rootType
          });
        }
        const childSelection = selection.selection;
        if (childSelection) {
          const { value: link } = this.cache._internal_unstable.storage.get(parent2, key);
          const children = !Array.isArray(link) ? [link] : flatten(link);
          for (const linkedRecord of children) {
            if (!linkedRecord) {
              continue;
            }
            const __typename = this.cache._internal_unstable.storage.get(
              linkedRecord,
              "__typename"
            ).value;
            let targetSelection2 = getFieldsForType(childSelection, __typename, false);
            this.addMany({
              parent: linkedRecord,
              variables,
              subscribers: subscribers.map(([sub]) => [sub, targetSelection2]),
              parentType: linkedType
            });
          }
        }
      }
    }
  }
  get(id, field) {
    return this.subscribers[id]?.[field] || [];
  }
  remove(id, selection, targets, variables, visited = []) {
    visited.push(id);
    const linkedIDs = [];
    const __typename = this.cache._internal_unstable.storage.get(id, "__typename").value;
    let targetSelection = getFieldsForType(selection, __typename, false);
    for (const fieldSelection of Object.values(targetSelection || {})) {
      const key = evaluateKey(fieldSelection.keyRaw, variables);
      this.removeSubscribers(id, key, targets);
      if (!fieldSelection.selection) {
        continue;
      }
      const { value: previousValue } = this.cache._internal_unstable.storage.get(id, key);
      const links = !Array.isArray(previousValue) ? [previousValue] : flatten(previousValue);
      for (const link of links) {
        if (link !== null) {
          linkedIDs.push([link, fieldSelection.selection || {}]);
        }
      }
    }
    for (const [linkedRecordID, linkFields] of linkedIDs) {
      this.remove(linkedRecordID, linkFields, targets, visited);
    }
  }
  reset() {
    const subscribers = Object.entries(this.subscribers).filter(
      ([id]) => !id.startsWith(rootID)
    );
    for (const [id, _fields] of subscribers) {
      delete this.subscribers[id];
    }
    const subscriptionSpecs = subscribers.flatMap(
      ([_id, fields]) => Object.values(fields).flatMap((field) => field.map(([spec]) => spec))
    );
    return subscriptionSpecs;
  }
  removeSubscribers(id, fieldName, specs) {
    let targets = [];
    for (const spec of specs) {
      if (!this.referenceCounts[id]?.[fieldName]?.has(spec.set)) {
        continue;
      }
      const counts = this.referenceCounts[id][fieldName];
      const newVal = (counts.get(spec.set) || 0) - 1;
      counts.set(spec.set, newVal);
      if (newVal <= 0) {
        targets.push(spec.set);
        counts.delete(spec.set);
      }
    }
    if (this.subscribers[id]) {
      this.subscribers[id][fieldName] = this.get(id, fieldName).filter(
        ([{ set }]) => !targets.includes(set)
      );
    }
  }
  removeAllSubscribers(id, targets, visited = []) {
    visited.push(id);
    for (const field of Object.keys(this.subscribers[id] || [])) {
      const subscribers = targets || this.subscribers[id][field].map(([spec]) => spec);
      this.removeSubscribers(id, field, subscribers);
      const { value, kind } = this.cache._internal_unstable.storage.get(id, field);
      if (kind === "scalar") {
        continue;
      }
      const nextTargets = Array.isArray(value) ? flatten(value) : [value];
      for (const id2 of nextTargets) {
        if (visited.includes(id2)) {
          continue;
        }
        this.removeAllSubscribers(id2, subscribers, visited);
      }
    }
  }
};

// src/runtime/cache/cache.ts
var Cache = class {
  _internal_unstable;
  constructor({
    disabled,
    componentCache,
    createComponent,
    ...config
  } = {}) {
    this._internal_unstable = new CacheInternal({
      cache: this,
      storage: new InMemoryStorage(),
      subscriptions: new InMemorySubscriptions(this),
      lists: new ListManager(this, rootID),
      lifetimes: new GarbageCollector(this),
      staleManager: new StaleManager(this),
      disabled: disabled ?? typeof globalThis.window === "undefined",
      componentCache,
      createComponent
    });
    if (Object.keys(config).length > 0) {
      this.setConfig(defaultConfigValues(config));
    }
  }
  write({
    layer: layerID,
    notifySubscribers = [],
    ...args
  }) {
    const layer = layerID ? this._internal_unstable.storage.getLayer(layerID) : this._internal_unstable.storage.topLayer;
    const subscribers = this._internal_unstable.writeSelection({ ...args, layer }).map((sub) => sub[0]);
    this.#notifySubscribers(subscribers.concat(notifySubscribers));
    return subscribers;
  }
  read(...args) {
    const { data, partial, stale, hasData } = this._internal_unstable.getSelection(...args);
    if (!hasData) {
      return { data: null, partial: false, stale: false };
    }
    return {
      data,
      partial,
      stale
    };
  }
  subscribe(spec, variables = {}) {
    return this._internal_unstable.subscriptions.add({
      parent: spec.parentID || rootID,
      spec,
      selection: spec.selection,
      variables
    });
  }
  unsubscribe(spec, variables = {}) {
    return this._internal_unstable.subscriptions.remove(
      spec.parentID || rootID,
      spec.selection,
      [spec],
      variables
    );
  }
  list(name, parentID, allLists) {
    const handler = this._internal_unstable.lists.get(name, parentID, allLists);
    if (!handler) {
      throw new Error(
        `Cannot find list with name: ${name}${parentID ? " under parent " + parentID : ""}. Is it possible that the query is not mounted?`
      );
    }
    return handler;
  }
  delete(id, layer) {
    this._internal_unstable.subscriptions.removeAllSubscribers(id);
    this._internal_unstable.lists.removeIDFromAllLists(id, layer);
    this._internal_unstable.storage.delete(id, layer);
  }
  setConfig(config) {
    this._internal_unstable.setConfig(config);
  }
  markTypeStale(options) {
    if (!options) {
      this._internal_unstable.staleManager.markAllStale();
    } else if (!options.field) {
      this._internal_unstable.staleManager.markTypeStale(options.type);
    } else {
      this._internal_unstable.staleManager.markTypeFieldStale(
        options.type,
        options.field,
        options.when
      );
    }
  }
  markRecordStale(id, options) {
    if (options.field) {
      const key = computeKey({ field: options.field, args: options.when ?? {} });
      this._internal_unstable.staleManager.markFieldStale(id, key);
    } else {
      this._internal_unstable.staleManager.markRecordStale(id);
    }
  }
  getFieldTime(id, field) {
    return this._internal_unstable.staleManager.getFieldTime(id, field);
  }
  config() {
    return this._internal_unstable.config;
  }
  serialize() {
    return this._internal_unstable.storage.serialize();
  }
  hydrate(...args) {
    return this._internal_unstable.storage.hydrate(...args);
  }
  clearLayer(layerID) {
    const layer = this._internal_unstable.storage.getLayer(layerID);
    if (!layer) {
      throw new Error("Cannot find layer with id: " + layerID);
    }
    const toNotify = [];
    const allFields = [];
    for (const target of [layer.fields, layer.links]) {
      for (const [id, fields] of Object.entries(target)) {
        allFields.push(
          ...Object.entries(fields).map(([field, value]) => ({ id, field, value }))
        );
      }
    }
    const displayFields = [];
    for (const pair of allFields) {
      const { displayLayers } = this._internal_unstable.storage.get(pair.id, pair.field);
      if (!displayLayers.includes(layerID)) {
        continue;
      }
      displayFields.push(pair);
    }
    for (const [id, operation] of Object.entries(layer.operations)) {
      if (operation.deleted) {
        displayFields.push(
          ...this._internal_unstable.subscriptions.activeFields(id).map((field) => ({ id, field }))
        );
      }
      const fields = Object.keys(operation.fields ?? {});
      if (fields.length > 0) {
        displayFields.push(...fields.map((field) => ({ id, field })));
      }
    }
    layer.clear();
    for (const display of displayFields) {
      const { field, id } = display;
      const notify = !("value" in display) || this._internal_unstable.storage.get(id, field).value !== display.value;
      if (notify) {
        toNotify.push(
          ...this._internal_unstable.subscriptions.get(id, field).map((sub) => sub[0])
        );
      }
    }
    this.#notifySubscribers(toNotify);
  }
  reset() {
    const subSpecs = this._internal_unstable.subscriptions.reset();
    this._internal_unstable.staleManager.reset();
    this._internal_unstable.lifetimes.reset();
    this._internal_unstable.lists.reset();
    this._internal_unstable.storage.reset();
    this.#notifySubscribers(subSpecs);
  }
  #notifySubscribers(subs) {
    if (subs.length === 0) {
      return;
    }
    const notified = [];
    for (const spec of subs) {
      if (!notified.includes(spec.set)) {
        notified.push(spec.set);
        spec.set(
          this._internal_unstable.getSelection({
            parent: spec.parentID || rootID,
            selection: spec.selection,
            variables: spec.variables?.() || {},
            ignoreMasking: false
          }).data
        );
      }
    }
  }
};
var CacheInternal = class {
  _disabled = false;
  _config;
  storage;
  subscriptions;
  lists;
  cache;
  lifetimes;
  staleManager;
  componentCache;
  createComponent;
  constructor({
    storage,
    subscriptions,
    lists,
    cache,
    lifetimes,
    staleManager,
    disabled,
    config,
    componentCache,
    createComponent
  }) {
    this.storage = storage;
    this.subscriptions = subscriptions;
    this.lists = lists;
    this.cache = cache;
    this.lifetimes = lifetimes;
    this.staleManager = staleManager;
    this._config = config;
    this.componentCache = componentCache ?? {};
    this.createComponent = createComponent ?? (() => ({}));
    this._disabled = disabled;
    try {
      if (process.env.HOUDINI_TEST === "true") {
        this._disabled = false;
      }
    } catch {
    }
  }
  get config() {
    return this._config ?? getCurrentConfig();
  }
  setConfig(config) {
    this._config = config;
  }
  writeSelection({
    data,
    selection,
    variables = {},
    parent: parent2 = rootID,
    applyUpdates,
    layer,
    toNotify = [],
    forceNotify,
    forceStale
  }) {
    if (this._disabled) {
      return [];
    }
    let targetSelection = getFieldsForType(
      selection,
      data["__typename"],
      false
    );
    for (const [field, value] of Object.entries(data)) {
      if (!selection || !targetSelection[field]) {
        continue;
      }
      let {
        type: linkedType,
        keyRaw,
        selection: fieldSelection,
        operations,
        abstract: isAbstract,
        updates
      } = targetSelection[field];
      const key = evaluateKey(keyRaw, variables);
      if (value && typeof value === "object" && "__typename" in value && value["__typename"]) {
        linkedType = value["__typename"];
      }
      const currentSubscribers = this.subscriptions.get(parent2, key);
      const specs = currentSubscribers.map((sub) => sub[0]);
      const { value: previousValue, displayLayers } = this.storage.get(parent2, key);
      const displayLayer = layer.isDisplayLayer(displayLayers);
      if (displayLayer) {
        this.lifetimes.resetLifetime(parent2, key);
        if (forceStale) {
          this.staleManager.markFieldStale(parent2, key);
        } else {
          this.staleManager.setFieldTimeToNow(parent2, key);
        }
      }
      if (!fieldSelection) {
        let newValue = value;
        if (updates && applyUpdates && Array.isArray(value)) {
          for (const update of applyUpdates) {
            if (!updates.includes(update)) {
              continue;
            }
            if (update === "append") {
              newValue = (previousValue || []).concat(value);
            } else if (update === "prepend") {
              newValue = value.concat(previousValue || []);
            }
          }
        }
        if (updates && applyUpdates?.includes("prepend") && ["endCursor", "hasNextPage"].includes(key)) {
          newValue = previousValue;
        } else if (updates && applyUpdates?.includes("append") && ["startCursor", "hasPreviousPage"].includes(key)) {
          newValue = previousValue;
        }
        const valueChanged = !deepEquals(newValue, previousValue);
        if (displayLayer && (valueChanged || forceNotify)) {
          toNotify.push(...currentSubscribers);
        }
        layer.writeField(parent2, key, newValue);
      } else if (value === null) {
        if (previousValue === null) {
          continue;
        }
        const previousLinks = flatten([previousValue]);
        for (const link of previousLinks) {
          this.subscriptions.remove(link, fieldSelection, specs, variables);
        }
        layer.writeLink(parent2, key, null);
        toNotify.push(...currentSubscribers);
      } else if (value instanceof Object && !Array.isArray(value)) {
        if (isAbstract) {
          if (!value.__typename) {
            throw new Error(
              "Encountered interface type without __typename in the payload"
            );
          }
        }
        let linkedID = null;
        if (value !== null) {
          linkedID = !this.isEmbedded(linkedType, value) ? this.id(linkedType, value) : `${parent2}.${key}`;
        }
        let linkChange = linkedID !== previousValue;
        layer.writeLink(parent2, key, linkedID);
        if (linkedID && displayLayer && (linkChange || forceNotify)) {
          if (previousValue && typeof previousValue === "string") {
            this.subscriptions.remove(previousValue, fieldSelection, specs, variables);
          }
          this.subscriptions.addMany({
            parent: linkedID,
            subscribers: currentSubscribers,
            variables,
            parentType: linkedType
          });
          toNotify.push(...currentSubscribers);
        }
        if (linkedID) {
          this.writeSelection({
            selection: fieldSelection,
            parent: linkedID,
            data: value,
            variables,
            toNotify,
            applyUpdates,
            layer,
            forceNotify
          });
        }
      } else if (Array.isArray(value) && (typeof previousValue === "undefined" || previousValue === null || Array.isArray(previousValue))) {
        let oldIDs = [...previousValue || []];
        const emptyEdges = !updates ? [] : oldIDs.map((id) => {
          if (!id) {
            return "";
          }
          const { value: cursorField } = this.storage.get(id, "cursor");
          if (cursorField) {
            return "";
          }
          const { value: node } = this.storage.get(id, "node");
          if (!node) {
            return "";
          }
          return node;
        });
        let linkedIDs = [];
        const { newIDs, nestedIDs } = this.extractNestedListIDs({
          value,
          abstract: Boolean(isAbstract),
          specs: toNotify,
          applyUpdates,
          recordID: parent2,
          key,
          linkedType,
          variables,
          fields: fieldSelection,
          layer,
          forceNotify
        });
        if (applyUpdates && updates) {
          if (key === "edges") {
            const newNodeIDs = [];
            for (const id of newIDs) {
              if (!id) {
                continue;
              }
              const { value: node } = this.storage.get(id, "node");
              if (typeof node !== "string") {
                continue;
              }
              if (!node || !this.storage.get(node, "__typename")) {
                continue;
              }
              newNodeIDs.push(node);
            }
            oldIDs = oldIDs.filter((id) => {
              if (!id) {
                return true;
              }
              const { value: value2 } = this.storage.get(id, "node");
              const node = value2;
              if (newNodeIDs.includes(node) && emptyEdges.includes(node)) {
                return false;
              }
              return true;
            });
          }
          for (const update of applyUpdates) {
            if (update !== "replace" && !updates.includes(update)) {
              continue;
            }
            if (update === "prepend") {
              linkedIDs = newIDs.concat(oldIDs);
            } else if (update === "append") {
              linkedIDs = oldIDs.concat(newIDs);
            } else if (update === "replace") {
              linkedIDs = newIDs;
            }
          }
        } else {
          linkedIDs = nestedIDs;
        }
        const contentChanged = !deepEquals(linkedIDs, oldIDs) || previousValue === null;
        if (contentChanged || forceNotify) {
          toNotify.push(...currentSubscribers);
        }
        for (const lostID of oldIDs) {
          if (linkedIDs.includes(lostID) || !lostID) {
            continue;
          }
          this.subscriptions.remove(lostID, fieldSelection, specs, variables);
        }
        if (contentChanged || oldIDs.length === 0 && newIDs.length === 0) {
          layer.writeLink(parent2, key, linkedIDs);
        }
        for (const id of newIDs.filter((id2) => !oldIDs.includes(id2))) {
          if (id == null) {
            continue;
          }
          this.subscriptions.addMany({
            parent: id,
            subscribers: currentSubscribers,
            variables,
            parentType: linkedType
          });
        }
      }
      for (const operation of operations || []) {
        let parentID;
        if (operation.parentID) {
          if (operation.parentID.kind !== "Variable") {
            parentID = operation.parentID.value;
          } else {
            const id = variables[operation.parentID.value];
            if (typeof id !== "string") {
              throw new Error("parentID value must be a string");
            }
            parentID = id;
          }
        }
        if (operation.list && !this.lists.get(operation.list, parentID, operation.target === "all")) {
          continue;
        }
        const targets = Array.isArray(value) ? value : [value];
        for (const target of targets) {
          if (operation.action === "insert" && target instanceof Object && fieldSelection && operation.list) {
            this.cache.list(operation.list, parentID, operation.target === "all").when(operation.when).addToList(
              fieldSelection,
              target,
              variables,
              operation.position || "last",
              layer
            );
          } else if (operation.action === "toggle" && target instanceof Object && fieldSelection && operation.list) {
            this.cache.list(operation.list, parentID, operation.target === "all").when(operation.when).toggleElement({
              selection: fieldSelection,
              data: target,
              variables,
              where: operation.position || "last",
              layer
            });
          } else if (operation.action === "remove" && target instanceof Object && fieldSelection && operation.list) {
            this.cache.list(operation.list, parentID, operation.target === "all").when(operation.when).remove(target, variables, layer);
          } else if (operation.action === "delete" && operation.type) {
            if (typeof target !== "string") {
              throw new Error("Cannot delete a record with a non-string ID");
            }
            const targetID = this.id(operation.type, target);
            if (!targetID) {
              continue;
            }
            this.cache.delete(targetID, layer);
          }
        }
      }
    }
    return toNotify;
  }
  getSelection({
    selection,
    parent: parent2 = rootID,
    variables,
    stepsFromConnection = null,
    ignoreMasking,
    fullCheck = false,
    loading: generateLoading
  }) {
    if (parent2 === null) {
      return { data: null, partial: false, stale: false, hasData: true };
    }
    const target = {};
    if (selection.fragments) {
      target[fragmentKey] = {
        loading: Boolean(generateLoading),
        values: Object.fromEntries(
          Object.entries(selection.fragments).filter(([, value]) => !generateLoading || value.loading).map(([key, value]) => [
            key,
            {
              parent: parent2,
              variables: evaluateFragmentVariables(
                value.arguments,
                variables ?? {}
              )
            }
          ])
        )
      };
    }
    let hasData = !!selection.fragments;
    let partial = false;
    let cascadeNull = false;
    let stale = false;
    const typename = this.storage.get(parent2, "__typename").value;
    let targetSelection = getFieldsForType(selection, typename, !!generateLoading);
    for (const [
      attributeName,
      {
        type,
        keyRaw,
        selection: fieldSelection,
        nullable,
        list,
        visible,
        directives,
        loading: fieldLoading,
        abstractHasRequired,
        component
      }
    ] of Object.entries(targetSelection)) {
      if (!visible && !ignoreMasking && !fullCheck) {
        continue;
      }
      const includeDirective = directives?.find((d3) => {
        return d3.name === "include";
      });
      if (includeDirective) {
        if (!evaluateFragmentVariables(includeDirective.arguments, variables ?? {})["if"]) {
          continue;
        }
      }
      const skipDirective = directives?.find((d3) => {
        return d3.name === "skip";
      });
      if (skipDirective) {
        if (evaluateFragmentVariables(skipDirective.arguments, variables ?? {})["if"]) {
          continue;
        }
      }
      const fieldTarget = visible || ignoreMasking ? target : {};
      const key = evaluateKey(keyRaw, variables);
      if (generateLoading && !fieldLoading) {
        continue;
      }
      const defaultValue = !component ? void 0 : defaultComponentField({
        cache: this.cache,
        component,
        variables,
        parent: parent2
      });
      let { value } = this.storage.get(parent2, key, defaultValue);
      const dt_field = this.staleManager.getFieldTime(parent2, key);
      if (dt_field === null) {
        stale = true;
      }
      if (generateLoading) {
        value = void 0;
      }
      let nextStep = stepsFromConnection;
      if (nextStep !== null) {
        if (nextStep >= 2) {
          nextStep = null;
        } else {
          nextStep += 1;
        }
      }
      if (list?.connection) {
        nextStep = 0;
      }
      const embeddedCursor = key === "cursor" && stepsFromConnection === 1;
      if (typeof value === "undefined" && !embeddedCursor) {
        partial = true;
      }
      if (generateLoading && fieldLoading?.kind === "value") {
        fieldTarget[attributeName] = PendingValue;
        hasData = true;
      } else if (!generateLoading && typeof value === "undefined" || value === null) {
        fieldTarget[attributeName] = null;
        if (typeof value !== "undefined") {
          hasData = true;
        }
      } else if (!fieldSelection) {
        const fnUnmarshal = this.config?.scalars?.[type]?.unmarshal;
        if (fnUnmarshal) {
          fieldTarget[attributeName] = fnUnmarshal(value);
        } else {
          fieldTarget[attributeName] = value;
        }
        hasData = true;
      } else if (Array.isArray(value)) {
        const listValue = this.hydrateNestedList({
          fields: fieldSelection,
          variables,
          linkedList: value,
          stepsFromConnection: nextStep,
          ignoreMasking: !!ignoreMasking,
          fullCheck,
          loading: generateLoading,
          nullable: !!nullable
        });
        fieldTarget[attributeName] = listValue.data;
        if (listValue.partial) {
          partial = true;
        }
        if (listValue.cascadeNull) {
          cascadeNull = true;
        }
        if (listValue.stale) {
          stale = true;
        }
        if (listValue.hasData || value.length === 0) {
          hasData = true;
        }
      } else {
        const objectFields = this.getSelection({
          parent: value,
          selection: fieldSelection,
          variables,
          stepsFromConnection: nextStep,
          ignoreMasking,
          fullCheck,
          loading: generateLoading
        });
        fieldTarget[attributeName] = objectFields.data;
        if (objectFields.partial) {
          partial = true;
        }
        if (objectFields.stale) {
          stale = true;
        }
        if (objectFields.hasData) {
          hasData = true;
        }
      }
      if (generateLoading && fieldLoading?.list) {
        fieldTarget[attributeName] = wrapInLists(
          Array.from({ length: fieldLoading.list.count }).fill(
            fieldTarget[attributeName]
          ),
          fieldLoading.list.depth - 1
        );
      }
      if (fieldTarget[attributeName] === null && !nullable && !embeddedCursor) {
        if (abstractHasRequired) {
          target[attributeName] = {
            __typename: "@required field missing; don't match this"
          };
        } else {
          cascadeNull = true;
        }
      }
    }
    return {
      data: cascadeNull ? null : target,
      partial: !generateLoading && hasData && partial,
      stale: hasData && stale,
      hasData
    };
  }
  id(type, data) {
    const id = typeof data === "string" ? data : this.computeID(type, data);
    if (!id) {
      return null;
    }
    if (!type) {
      return id;
    }
    return type + ":" + id;
  }
  idFields(type) {
    return keyFieldsForType(this.config, type);
  }
  computeID(type, data) {
    return computeID(this.config, type, data);
  }
  isEmbedded(linkedType, value) {
    const idFields = this.idFields(linkedType);
    return idFields.length === 0 || idFields.filter((field) => typeof value[field] === "undefined").length > 0;
  }
  hydrateNestedList({
    fields,
    variables,
    linkedList,
    stepsFromConnection,
    ignoreMasking,
    fullCheck,
    loading,
    nullable
  }) {
    const result = [];
    let partialData = false;
    let stale = false;
    let hasValues = false;
    let cascadeNull = false;
    for (const entry of linkedList) {
      if (Array.isArray(entry)) {
        const nestedValue = this.hydrateNestedList({
          fields,
          nullable,
          variables,
          linkedList: entry,
          stepsFromConnection,
          ignoreMasking,
          fullCheck,
          loading
        });
        result.push(nestedValue.data);
        if (nestedValue.partial) {
          partialData = true;
        }
        if (nestedValue.cascadeNull) {
          cascadeNull = true;
        }
        continue;
      }
      if (entry === null) {
        result.push(entry);
        continue;
      }
      const {
        data,
        partial,
        stale: local_stale,
        hasData
      } = this.getSelection({
        parent: entry,
        selection: fields,
        variables,
        stepsFromConnection,
        ignoreMasking,
        fullCheck,
        loading
      });
      if (data === null && !nullable) {
        cascadeNull = true;
      }
      result.push(data);
      if (partial) {
        partialData = true;
      }
      if (local_stale) {
        stale = true;
      }
      if (hasData) {
        hasValues = true;
      }
    }
    return {
      data: result,
      partial: partialData,
      stale,
      hasData: hasValues,
      cascadeNull
    };
  }
  extractNestedListIDs({
    value,
    abstract,
    recordID,
    key,
    linkedType,
    fields,
    variables,
    applyUpdates,
    specs,
    layer,
    forceNotify
  }) {
    const nestedIDs = [];
    const newIDs = [];
    for (const [i2, entry] of value.entries()) {
      if (Array.isArray(entry)) {
        const inner = this.extractNestedListIDs({
          value: entry,
          abstract,
          recordID,
          key,
          linkedType,
          fields,
          variables,
          applyUpdates,
          specs,
          layer,
          forceNotify
        });
        newIDs.push(...inner.newIDs);
        nestedIDs[i2] = inner.nestedIDs;
        continue;
      }
      if (entry === null || typeof entry === "undefined") {
        newIDs.push(null);
        nestedIDs[i2] = null;
        continue;
      }
      const entryObj = entry;
      let linkedID = `${recordID}.${key}[${this.storage.nextRank}]`;
      let innerType = linkedType;
      const typename = entryObj.__typename;
      if (typename) {
        innerType = typename;
      } else if (abstract) {
        throw new Error("Encountered interface type without __typename in the payload");
      }
      if (!this.isEmbedded(linkedType, entry)) {
        const id = this.id(innerType, entry);
        if (id) {
          linkedID = id;
        } else {
          continue;
        }
      }
      this.writeSelection({
        root: rootID,
        selection: fields,
        parent: linkedID,
        data: entryObj,
        variables,
        toNotify: specs,
        applyUpdates,
        layer,
        forceNotify
      });
      newIDs.push(linkedID);
      nestedIDs[i2] = linkedID;
    }
    return { newIDs, nestedIDs };
  }
  collectGarbage() {
    this.lifetimes.tick();
    if (this.storage.layerCount === 1) {
      this.storage.topLayer.removeUndefinedFields();
    }
  }
};
function evaluateFragmentVariables(variables, args) {
  return Object.fromEntries(
    Object.entries(variables).map(([key, value]) => [key, fragmentVariableValue(value, args)])
  );
}
function wrapInLists(target, count = 0) {
  if (count === 0) {
    return target;
  }
  return wrapInLists([target], count - 1);
}
function fragmentVariableValue(value, args) {
  if (value.kind === "StringValue") {
    return value.value;
  }
  if (value.kind === "BooleanValue") {
    return value.value;
  }
  if (value.kind === "EnumValue") {
    return value.value;
  }
  if (value.kind === "FloatValue") {
    return parseFloat(value.value);
  }
  if (value.kind === "IntValue") {
    return parseInt(value.value, 10);
  }
  if (value.kind === "NullValue") {
    return null;
  }
  if (value.kind === "Variable") {
    return args[value.name.value];
  }
  if (value.kind === "ListValue") {
    return value.values.map((value2) => fragmentVariableValue(value2, args));
  }
  if (value.kind === "ObjectValue") {
    return value.fields.reduce(
      (obj, field) => ({
        ...obj,
        [field.name.value]: fragmentVariableValue(field.value, args)
      }),
      {}
    );
  }
}
var rootID = "_ROOT_";
function defaultComponentField({
  cache,
  component,
  loading,
  variables,
  parent: parent2
}) {
  return (props) => {
    const componentFn = cache._internal_unstable.componentCache[component.key];
    const args = evaluateFragmentVariables(component.variables ?? {}, variables ?? {});
    return cache._internal_unstable.createComponent(componentFn, {
      ...props,
      [component.prop]: {
        [fragmentKey]: {
          loading,
          values: {
            [component.fragment]: {
              variables: args,
              parent: parent2
            }
          }
        }
      }
    });
  };
}

// src/runtime/cache/index.ts
var cache_default = new Cache();

// src/runtime/client/plugins/cache.ts
var serverSide = typeof globalThis.window === "undefined";

// src/runtime/client/utils/documentPlugins.ts
var documentPlugin = (kind, source) => {
  return () => {
    const sourceHandlers = source();
    const enterWrapper = (handler) => {
      return !handler ? void 0 : (ctx, handlers) => {
        if (ctx.artifact.kind !== kind) {
          return handlers.next(ctx);
        }
        return handler(ctx, handlers);
      };
    };
    const exitWrapper = (handler) => {
      return !handler ? void 0 : (ctx, handlers) => {
        if (ctx.artifact.kind !== kind) {
          return handlers.resolve(ctx);
        }
        return handler(ctx, handlers);
      };
    };
    return {
      start: enterWrapper(sourceHandlers.start),
      network: enterWrapper(sourceHandlers.network),
      afterNetwork: exitWrapper(sourceHandlers.afterNetwork),
      end: exitWrapper(sourceHandlers.end),
      catch: sourceHandlers.catch ? (ctx, handlers) => sourceHandlers.catch(ctx, handlers) : void 0,
      cleanup: (...args) => sourceHandlers.cleanup?.(...args)
    };
  };
};

// src/runtime/client/plugins/query.ts
var query = documentPlugin(ArtifactKind.Query, function() {
  let subscriptionSpec = null;
  let lastVariables = null;
  return {
    start(ctx, { next }) {
      ctx.variables = {
        ...lastVariables,
        ...ctx.variables
      };
      next(ctx);
    },
    end(ctx, { resolve: resolve2, marshalVariables, variablesChanged }) {
      if (variablesChanged(ctx) && !ctx.cacheParams?.disableSubscriptions) {
        if (subscriptionSpec) {
          cache_default.unsubscribe(subscriptionSpec, subscriptionSpec.variables?.() || {});
        }
        lastVariables = { ...marshalVariables(ctx) };
        const variables = lastVariables;
        subscriptionSpec = {
          rootType: ctx.artifact.rootType,
          selection: ctx.artifact.selection,
          variables: () => variables,
          set: (newValue) => {
            resolve2(ctx, {
              data: newValue,
              errors: null,
              fetching: false,
              partial: false,
              stale: false,
              source: DataSource.Cache,
              variables: ctx.variables ?? {}
            });
          }
        };
        cache_default.subscribe(subscriptionSpec, lastVariables);
      }
      resolve2(ctx);
    },
    cleanup() {
      if (subscriptionSpec) {
        cache_default.unsubscribe(subscriptionSpec, subscriptionSpec.variables?.());
        lastVariables = null;
      }
    }
  };
});

// src/runtime/client/plugins/fragment.ts
var fragment = documentPlugin(ArtifactKind.Fragment, function() {
  let subscriptionSpec = null;
  let lastReference = null;
  return {
    start(ctx, { next, resolve: resolve2, variablesChanged, marshalVariables }) {
      if (!ctx.stuff.parentID) {
        return next(ctx);
      }
      const currentReference = {
        parent: ctx.stuff.parentID,
        variables: marshalVariables(ctx)
      };
      if (!ctx.cacheParams?.disableSubscriptions && (!deepEquals(lastReference, currentReference) || variablesChanged(ctx))) {
        if (subscriptionSpec) {
          cache_default.unsubscribe(subscriptionSpec, subscriptionSpec.variables?.() || {});
        }
        const variables = marshalVariables(ctx);
        subscriptionSpec = {
          rootType: ctx.artifact.rootType,
          selection: ctx.artifact.selection,
          variables: () => variables,
          parentID: ctx.stuff.parentID,
          set: (newValue) => {
            resolve2(ctx, {
              data: newValue,
              errors: null,
              fetching: false,
              partial: false,
              stale: false,
              source: DataSource.Cache,
              variables
            });
          }
        };
        cache_default.subscribe(subscriptionSpec, variables);
        lastReference = currentReference;
      }
      next(ctx);
    },
    cleanup() {
      if (subscriptionSpec) {
        cache_default.unsubscribe(subscriptionSpec, subscriptionSpec.variables?.());
      }
    }
  };
});

// src/runtime/client/plugins/mutation.ts
var mutation = documentPlugin(ArtifactKind.Mutation, () => {
  return {
    async start(ctx, { next, marshalVariables }) {
      const layerOptimistic = cache_default._internal_unstable.storage.createLayer(true);
      const optimisticResponse = ctx.stuff.optimisticResponse;
      let toNotify = [];
      if (optimisticResponse) {
        toNotify = cache_default.write({
          selection: ctx.artifact.selection,
          data: await marshalSelection({
            selection: ctx.artifact.selection,
            data: optimisticResponse
          }),
          variables: marshalVariables(ctx),
          layer: layerOptimistic.id
        });
      }
      ctx.cacheParams = {
        ...ctx.cacheParams,
        layer: layerOptimistic,
        notifySubscribers: toNotify,
        forceNotify: true
      };
      next(ctx);
    },
    afterNetwork(ctx, { resolve: resolve2 }) {
      if (ctx.cacheParams?.layer) {
        cache_default.clearLayer(ctx.cacheParams.layer.id);
      }
      resolve2(ctx);
    },
    end(ctx, { resolve: resolve2, value }) {
      const hasErrors = value.errors && value.errors.length > 0;
      if (hasErrors) {
        if (ctx.cacheParams?.layer) {
          cache_default.clearLayer(ctx.cacheParams.layer.id);
        }
      }
      if (ctx.cacheParams?.layer) {
        cache_default._internal_unstable.storage.resolveLayer(ctx.cacheParams.layer.id);
      }
      resolve2(ctx);
    },
    catch(ctx, { error }) {
      if (ctx.cacheParams?.layer) {
        const { layer } = ctx.cacheParams;
        cache_default.clearLayer(layer.id);
        cache_default._internal_unstable.storage.resolveLayer(layer.id);
      }
      throw error;
    }
  };
});

// src/lib/types.ts
var LogLevel = {
  Full: "full",
  Summary: "summary",
  ShortSummary: "short-summary",
  Quiet: "quiet"
};

// src/lib/config.ts
var import_meta = {};
var currentDir = dirname((0, import_node_url2.fileURLToPath)(import_meta.url));
var Config = class {
  filepath;
  rootDir;
  localSchema;
  projectRoot;
  schema;
  schemaPath;
  persistedQueriesPath = "./$houdini/persisted_queries.json";
  exclude;
  scalars;
  module = "esm";
  cacheBufferSize;
  defaultCachePolicy;
  defaultPartial;
  internalListPosition;
  defaultListTarget = null;
  defaultPaginateMode;
  definitionsFolder;
  newDocuments = "";
  defaultKeys = ["id"];
  typeConfig;
  configFile;
  logLevel;
  defaultFragmentMasking = "enable";
  configIsRoute = null;
  routesDir;
  schemaPollInterval;
  schemaPollHeaders;
  pluginMode = false;
  plugins = [];
  componentFields = {};
  constructor({
    filepath,
    loadFrameworkConfig,
    ...configFile
  }) {
    this.configFile = defaultConfigValues(configFile);
    this.localSchema = false;
    if (configFile.disableMasking !== void 0) {
      throw new HoudiniError({
        message: `"disableMasking" was replaced by "defaultFragmentMasking". Please update your config file.`
      });
    }
    let {
      schema,
      schemaPath = "./schema.graphql",
      exclude = [],
      module: module2 = "esm",
      scalars,
      cacheBufferSize,
      definitionsPath,
      defaultCachePolicy = CachePolicy.CacheOrNetwork,
      defaultPartial = false,
      defaultListPosition = "append",
      defaultListTarget = null,
      defaultPaginateMode = PaginateMode.Infinite,
      defaultKeys,
      types: types17 = {},
      logLevel,
      defaultFragmentMasking = "enable",
      watchSchema,
      projectDir,
      persistedQueriesPath
    } = this.configFile;
    if (typeof schema === "string") {
      this.schema = graphql2.buildSchema(schema);
    } else {
      this.schema = schema;
    }
    if (logLevel && !Object.values(LogLevel).includes(logLevel.toLowerCase())) {
      console.warn(
        `\u26A0\uFE0F Invalid log level provided. Valid values are: ${JSON.stringify(
          Object.values(LogLevel)
        )}`
      );
      logLevel = LogLevel.Summary;
    }
    this.schemaPath = schemaPath;
    this.filepath = filepath;
    this.exclude = Array.isArray(exclude) ? exclude : [exclude];
    this.module = module2;
    this.projectRoot = dirname(
      projectDir ? join2(process.cwd(), projectDir) : filepath
    );
    this.scalars = scalars;
    this.cacheBufferSize = cacheBufferSize;
    this.defaultCachePolicy = defaultCachePolicy;
    this.defaultPartial = defaultPartial;
    this.internalListPosition = defaultListPosition === "append" ? "last" : "first";
    this.defaultListTarget = defaultListTarget;
    this.defaultPaginateMode = defaultPaginateMode;
    this.definitionsFolder = definitionsPath;
    this.logLevel = (logLevel || LogLevel.Summary).toLowerCase();
    this.defaultFragmentMasking = defaultFragmentMasking;
    this.routesDir = join2(this.projectRoot, "src", "routes");
    this.schemaPollInterval = watchSchema?.interval === void 0 ? 2e3 : watchSchema.interval;
    this.schemaPollHeaders = watchSchema?.headers ?? {};
    this.rootDir = join2(this.projectRoot, "$houdini");
    this.#fragmentVariableMaps = {};
    if (persistedQueriesPath) {
      this.persistedQueriesPath = persistedQueriesPath;
    }
    if (defaultKeys) {
      this.defaultKeys = defaultKeys;
    }
    if (types17) {
      this.typeConfig = {
        ...this.typeConfig,
        ...types17
      };
    }
  }
  async apiURL() {
    const apiURL = this.configFile.watchSchema?.url;
    if (!apiURL) {
      return "";
    }
    const env2 = await this.getEnv();
    return this.processEnvValues(env2, apiURL);
  }
  get include() {
    if (this.configFile.include) {
      return Array.isArray(this.configFile.include) ? this.configFile.include : [this.configFile.include];
    }
    const extensions = [".graphql", ".gql", ".ts", ".js"].concat(
      this.plugins.flatMap((plugin2) => plugin2.extensions ?? [])
    );
    const include = [`src/**/*{${extensions.join(",")}}`];
    for (const plugin2 of this.plugins) {
      const runtimeDir = this.pluginRuntimeSource(plugin2);
      if (!runtimeDir) {
        continue;
      }
      const includePath = relative(this.projectRoot, runtimeDir);
      include.push(`${includePath}/**/*{${extensions.join(",")}}`);
    }
    return include;
  }
  pluginConfig(name) {
    return this.configFile.plugins?.[name] ?? {};
  }
  async getEnv() {
    let env2 = process.env;
    for (const plugin2 of this.plugins) {
      if (plugin2.env) {
        env2 = {
          ...await plugin2.env({ config: this, env: env2 })
        };
      }
    }
    return env2;
  }
  processEnvValues(env2, value) {
    let headerValue;
    if (typeof value === "function") {
      headerValue = value(env2);
    } else if (value.startsWith("env:")) {
      headerValue = env2[value.slice("env:".length)];
    } else {
      headerValue = value;
    }
    return headerValue;
  }
  async pullHeaders() {
    const env2 = await this.getEnv();
    if (typeof this.schemaPollHeaders === "function") {
      return this.schemaPollHeaders(env2);
    }
    const headers = Object.fromEntries(
      Object.entries(this.schemaPollHeaders || {}).map(([key, value]) => {
        const headerValue = this.processEnvValues(env2, value);
        if (!headerValue) {
          return [];
        }
        return [key, headerValue];
      }).filter(([key]) => key)
    );
    return headers;
  }
  pluginRuntimeSource(plugin2) {
    if (!plugin2.includeRuntime) {
      return null;
    }
    return join2(
      dirname(plugin2.filepath),
      typeof plugin2.includeRuntime === "string" ? plugin2.includeRuntime : plugin2.includeRuntime?.[this.module]
    );
  }
  async sourceFiles() {
    return [
      ...new Set(
        (await Promise.all(
          this.include.map(
            (filepath) => glob(join2(this.projectRoot, filepath))
          )
        )).flat().filter((filepath) => this.includeFile(filepath)).filter((filepath) => {
          const prefix = this.schemaPath?.startsWith("./") ? "./" : "";
          return !this.schemaPath || !(0, import_minimatch.default)(
            prefix + relative(this.projectRoot, filepath).replaceAll("\\", "/"),
            this.schemaPath
          );
        })
      )
    ];
  }
  get componentScalar() {
    return "Component";
  }
  #newSchemaInstance = null;
  schemaString = "";
  set newSchema(value) {
    this.schemaString = value;
    if (value) {
      this.#newSchemaInstance = graphql2.buildSchema(value);
    } else {
      this.#newSchemaInstance = null;
    }
  }
  get newSchema() {
    return this.schemaString;
  }
  get artifactDirectory() {
    return join2(this.rootDir, this.artifactDirectoryName);
  }
  get artifactDirectoryName() {
    return "artifacts";
  }
  get sourceDir() {
    return join2(this.projectRoot, "src");
  }
  get localApiDir() {
    return join2(this.sourceDir, "api");
  }
  get localAPIUrl() {
    return localApiEndpoint(this.configFile);
  }
  get artifactTypeDirectory() {
    return this.artifactDirectory;
  }
  get runtimeDirectory() {
    return join2(this.rootDir, "runtime");
  }
  get definitionsDirectory() {
    return this.definitionsFolder ? join2(this.projectRoot, this.definitionsFolder) : join2(this.rootDir, "graphql");
  }
  get enumRuntimeDefinitionsPath() {
    return join2(this.definitionsDirectory, "enums.js");
  }
  get enumTypesDefinitionsPath() {
    return join2(this.definitionsDirectory, "enums.d.ts");
  }
  get definitionsSchemaPath() {
    return join2(this.definitionsDirectory, "schema.graphql");
  }
  get routerBuildDirectory() {
    return join2(this.projectRoot, "dist");
  }
  get definitionsDocumentsPath() {
    return join2(this.definitionsDirectory, "documents.gql");
  }
  get typeIndexPath() {
    return join2(this.rootDir, "index.d.ts");
  }
  get typeRootDir() {
    return join2(this.rootDir, "types");
  }
  get typeRootFile() {
    return "$houdini.d.ts";
  }
  get runtimeSource() {
    let relative2;
    if (houdini_mode.is_testing) {
      relative2 = join2(currentDir, "..", "..");
    } else if (process.versions.pnp) {
      const { findPnpApi } = require("node:module");
      const pnp = findPnpApi(this.filepath);
      relative2 = pnp.resolveToUnqualified("houdini", this.filepath);
    } else {
      relative2 = findModule("houdini", join2(dirname(this.filepath)));
    }
    const which = this.module === "esm" ? "esm" : "cjs";
    return resolve(relative2, "build", `runtime-${which}`);
  }
  artifactTypePath(document) {
    return join2(this.artifactTypeDirectory, `${this.documentName(document)}.d.ts`);
  }
  artifactPath(document) {
    return join2(this.artifactDirectory, this.documentName(document) + ".js");
  }
  artifactImportPath(name) {
    return `$houdini/${this.artifactDirectoryName}/${name}`;
  }
  keyFieldsForType(type) {
    return this.schema.getQueryType()?.name === type ? [] : keyFieldsForType(this.configFile, type);
  }
  computeID(type, data) {
    return computeID(this.configFile, type, data);
  }
  documentName(document) {
    const operation = document.definitions.find(
      ({ kind }) => kind === graphql2.Kind.OPERATION_DEFINITION
    );
    if (operation) {
      if (!operation.name) {
        throw new Error("encountered operation with no name: " + graphql2.print(document));
      }
      return operation.name.value;
    }
    const fragmentDefinitions = document.definitions.filter(
      ({ kind }) => kind === graphql2.Kind.FRAGMENT_DEFINITION
    );
    if (fragmentDefinitions.length) {
      return fragmentDefinitions[0].name.value;
    }
    throw new Error("Could not generate artifact name for document: " + graphql2.print(document));
  }
  isSelectionScalar(type) {
    return ["String", "Boolean", "Float", "ID", "Int"].concat(Object.keys(this.scalars || {})).includes(type);
  }
  createDirectories() {
    mkdirpSync(this.artifactDirectory);
    mkdirpSync(this.artifactTypeDirectory);
    mkdirpSync(this.runtimeDirectory);
    mkdirpSync(this.definitionsDirectory);
  }
  get compiledAssetsDir() {
    return join2(this.rootDir, "build");
  }
  compiledAssetPath(filepath) {
    return join2(
      this.compiledAssetsDir,
      relative(process.cwd(), filepath).replaceAll(sep, "_").replace(".ts", ".js")
    );
  }
  excludeFile(filepath) {
    if (this.exclude.length > 0 && this.exclude.some((pattern) => (0, import_minimatch.default)(filepath, pattern))) {
      return true;
    }
    for (const plugin2 of this.plugins) {
      if (plugin2?.exclude?.({ config: this, filepath })) {
        return true;
      }
    }
    return false;
  }
  includeFile(filepath, {
    root = this.projectRoot,
    ignore_plugins = false
  } = {}) {
    const parsed = parse3(filepath);
    filepath = `${parsed.dir}/${parsed.name}${parsed.ext.split("?")[0]}`;
    let included = false;
    for (const plugin2 of ignore_plugins ? [] : this.plugins) {
      if (!plugin2.include) {
        continue;
      }
      if (plugin2.include({ config: this, filepath })) {
        included = true;
        break;
      }
    }
    if (!included && !this.include.some((pattern) => (0, import_minimatch.default)(filepath, join2(root, pattern)))) {
      return false;
    }
    return !this.excludeFile(filepath);
  }
  pluginRuntimeDirectory(name) {
    return join2(this.pluginDirectory(name), "runtime");
  }
  get pluginRootDirectory() {
    return houdini_mode.is_testing ? "../../../" : join2(this.rootDir, "plugins");
  }
  pluginDirectory(name) {
    return join2(this.pluginRootDirectory, name);
  }
  get loadDirective() {
    return "load";
  }
  get maskEnableDirective() {
    return "mask_enable";
  }
  get maskDisableDirective() {
    return "mask_disable";
  }
  get listDirective() {
    return "list";
  }
  get listPrependDirective() {
    return "prepend";
  }
  get listAppendDirective() {
    return "append";
  }
  get listParentDirective() {
    return "parentID";
  }
  get blockingDirective() {
    return "blocking";
  }
  get blockingDisableDirective() {
    return "blocking_disable";
  }
  get deprecatedlistDirectiveParentIDArg() {
    return "parentID";
  }
  get listAllListsDirective() {
    return "allLists";
  }
  get listOrPaginateNameArg() {
    return "name";
  }
  get insertFragmentSuffix() {
    return `_insert`;
  }
  get removeFragmentSuffix() {
    return `_remove`;
  }
  get toggleFragmentSuffix() {
    return `_toggle`;
  }
  get deleteDirectiveSuffix() {
    return `_delete`;
  }
  get loadingDirective() {
    return `loading`;
  }
  get whenDirective() {
    return "when";
  }
  get whenNotDirective() {
    return this.whenDirective + "_not";
  }
  get liveDirective() {
    return "live";
  }
  get argumentsDirective() {
    return "arguments";
  }
  get withDirective() {
    return "with";
  }
  get paginateDirective() {
    return "paginate";
  }
  get paginateModeArg() {
    return "mode";
  }
  get cacheDirective() {
    return "cache";
  }
  get cachePartialArg() {
    return "partial";
  }
  get cachePolicyArg() {
    return "policy";
  }
  get requiredDirective() {
    return "required";
  }
  paginationQueryName(documentName) {
    return documentName + "_Pagination_Query";
  }
  isDeleteDirective(name) {
    return name.endsWith(this.deleteDirectiveSuffix);
  }
  listDeleteDirective(name) {
    return name + this.deleteDirectiveSuffix;
  }
  deleteDirectiveType(name) {
    return name.slice(0, name.length - this.deleteDirectiveSuffix.length);
  }
  isInsertFragment(name) {
    return name.endsWith(this.insertFragmentSuffix);
  }
  listInsertFragment(name) {
    return name + this.insertFragmentSuffix;
  }
  listToggleFragment(name) {
    return name + this.toggleFragmentSuffix;
  }
  isRemoveFragment(name) {
    return name.endsWith(this.removeFragmentSuffix);
  }
  isToggleFragment(name) {
    return name.endsWith(this.toggleFragmentSuffix);
  }
  listRemoveFragment(name) {
    return name + this.removeFragmentSuffix;
  }
  isInternalEnum(node) {
    return node.name.value === "CachePolicy" || node.name.value === "PaginateMode";
  }
  isInternalDirective(name) {
    const internalDirectives = this.#newSchemaInstance?.getDirectives().reduce((list, directive) => {
      return list.concat(directive.name);
    }, []) ?? [];
    return !defaultDirectives.includes(name) && (internalDirectives.includes(name) || this.isDeleteDirective(name));
  }
  get componentFieldDirective() {
    return "componentField";
  }
  componentFieldFragmentName(args) {
    let fieldValue = args.entry;
    if (typeof fieldValue !== "string") {
      const field = fieldValue.arguments?.find((arg) => arg.name.value === "field")?.value;
      fieldValue = field?.kind === "StringValue" ? field.value : "";
    }
    if (!fieldValue) {
      return "";
    }
    return `__componentField__${args.type}_${fieldValue}`;
  }
  localDocumentData(document) {
    let paginated = false;
    let componentFields3 = [];
    const typeInfo = new graphql2.TypeInfo(this.schema);
    graphql2.visit(
      document,
      graphql2.visitWithTypeInfo(typeInfo, {
        Directive: (node) => {
          if ([this.paginateDirective].includes(node.name.value)) {
            paginated = true;
          }
        },
        Field: (node) => {
          const parentType = typeInfo.getParentType();
          if (this.componentFields[parentType?.name ?? ""]?.[node.name.value] && parentType?.name) {
            componentFields3.push({ type: parentType?.name, field: node.name.value });
          }
        }
      })
    );
    return { paginated, componentFields: componentFields3 };
  }
  #fragmentVariableMaps;
  registerFragmentVariablesHash({
    hash,
    args,
    fragment: fragment2
  }) {
    this.#fragmentVariableMaps[hash] = {
      args: this.serializeValueMap(args),
      fragment: fragment2
    };
  }
  getFragmentVariablesHash(hash) {
    return this.#fragmentVariableMaps[hash] ?? {
      fragment: hash,
      args: {},
      hash
    };
  }
  serializeValueMap(map) {
    if (!map) {
      return null;
    }
    return Object.fromEntries(
      Object.entries(map).map(([key, input]) => {
        const result = {
          kind: input.kind
        };
        if (typeof input === "object") {
          if ("value" in input) {
            result.value = input.value;
          }
          if ("values" in input) {
            result.values = input.values.map(
              (value) => this.serializeValueMap({ foo: value }).foo
            );
          }
          if ("name" in input) {
            result.name = input.name;
          }
          if ("fields" in input) {
            result.fields = input.fields.map((field) => ({
              name: field.name,
              value: this.serializeValueMap({ foo: field.value }).foo
            }));
          }
        }
        return [key, result];
      })
    );
  }
  isListFragment(name) {
    return name.endsWith(this.insertFragmentSuffix) || name.endsWith(this.removeFragmentSuffix) || name.endsWith(this.toggleFragmentSuffix);
  }
  isListOperationDirective(name) {
    return name.endsWith(this.deleteDirectiveSuffix);
  }
  isFragmentForList(listName, fragmentName) {
    return fragmentName.startsWith(listName);
  }
  listOperationFromFragment(fragmentName) {
    if (this.isInsertFragment(fragmentName)) {
      return "insert";
    } else if (this.isRemoveFragment(fragmentName)) {
      return "remove";
    } else if (this.isToggleFragment(fragmentName)) {
      return "toggle";
    }
    throw new Error("Could not determine list operation from fragment name: " + fragmentName);
  }
  listNameFromDirective(directiveName) {
    try {
      return this.listNameFromFragment(directiveName);
    } catch (e3) {
      throw new Error("Could not find list name from directive: " + directiveName);
    }
  }
  listNameFromFragment(fragmentName) {
    for (let i2 = fragmentName.length - 1; i2 >= 0; i2--) {
      if (fragmentName[i2] === "_") {
        return fragmentName.slice(0, i2);
      }
    }
    throw new Error("Could not find list name from fragment: " + fragmentName);
  }
  extractDefinition(document) {
    if (document.definitions.length !== 1) {
      throw new Error("Encountered document with multiple definitions");
    }
    const definition = document.definitions[0];
    if (definition.kind !== "OperationDefinition" && definition.kind !== "FragmentDefinition") {
      throw new Error("Encountered document without a fragment or operation definition");
    }
    return definition;
  }
  extractQueryDefinition(document) {
    const definition = this.extractDefinition(document);
    if (definition.kind !== "OperationDefinition" || definition.operation !== "query") {
      throw new Error("Encountered document with non query definition");
    }
    return definition;
  }
  variableFunctionName(name) {
    return name + "Variables";
  }
};
var DEFAULT_CONFIG_PATH = join2(process.cwd(), "houdini.config.js");
var _config;
var pendingConfigPromise = null;
async function getConfig({
  configPath = DEFAULT_CONFIG_PATH,
  noSchema,
  forceReload,
  ...extraConfig
} = {}) {
  if (!forceReload) {
    if (_config) {
      return _config;
    }
    if (pendingConfigPromise) {
      return await pendingConfigPromise;
    }
  }
  let resolve2 = () => {
  };
  let reject = (message) => {
  };
  pendingConfigPromise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  try {
    let configFile = await readConfigFile(configPath);
    const pluginConfigs = Object.entries(configFile.plugins ?? {});
    if (process.env.HOUDINI_CODEGEN_PLUGIN) {
      pluginConfigs.push([process.env.HOUDINI_CODEGEN_PLUGIN, {}]);
    }
    const pluginsNested = [];
    for (const [pluginName, plugin_config] of pluginConfigs) {
      let pluginFile = join2(dirname(configPath), pluginName);
      if (!pluginName.startsWith(".")) {
        pluginFile = await pluginPath(pluginName, configPath);
      }
      const { default: pluginInit } = await import((0, import_node_url2.pathToFileURL)(pluginFile).toString());
      if (!pluginInit.plugin || !pluginInit.name) {
        throw new HoudiniError({
          filepath: pluginFile,
          message: `The default export does not match the expected shape.`,
          description: "Please make sure that the file exports the default of the plugin function."
        });
      }
      const hooks = await pluginInit.plugin(plugin_config);
      const hooksList = (Array.isArray(hooks) ? hooks : [hooks]).filter(Boolean).flat();
      pluginsNested.push(
        await flattenPluginList(configPath, hooksList, pluginName, pluginFile)
      );
    }
    const plugins = pluginsNested.flat();
    for (const plugin2 of plugins) {
      if (plugin2.config) {
        try {
          const configFactory = (await import(plugin2.config)).default;
          if (configFactory) {
            configFile = typeof configFactory === "function" ? configFactory(configFile) : configFactory;
          }
        } catch {
          console.log("could not load config file " + plugin2.config);
        }
      }
    }
    _config = new Config({
      ...configFile,
      ...extraConfig,
      filepath: configPath
    });
    let localSchema = false;
    try {
      let apiDir = _config.localApiDir;
      for (const child of await readdir(apiDir)) {
        if (parse3(child).name === "+schema") {
          localSchema = true;
          break;
        }
      }
    } catch {
    }
    _config.localSchema = localSchema;
    const apiURL = await _config.apiURL();
    if (!_config.localSchema && _config.schemaPath && !_config.schema) {
      let schemaOk = true;
      if (apiURL) {
        if (glob.hasMagic(_config.schemaPath)) {
          console.log(
            `\u26A0\uFE0F  Your houdini configuration contains an apiUrl and a path pointing to multiple files.
	This will prevent your schema from being pulled.`
          );
        } else if (!await readFile(_config.schemaPath)) {
          console.log("\u231B Pulling schema from api");
          schemaOk = await pullSchema(apiURL, _config.schemaPath) !== null;
        }
      }
      if (schemaOk && !noSchema) {
        _config.schema = await loadSchemaFile(_config.schemaPath);
      }
    }
    _config.plugins = orderedPlugins(plugins);
    await Promise.all(_config.plugins.map((plugin2) => plugin2.afterLoad?.({ config: _config })));
    resolve2(_config);
    return _config;
  } catch (e3) {
    reject(e3);
    throw e3;
  }
}
async function flattenPluginList(root, list, name, pluginFile) {
  const pluginsLeft = [
    {
      ...plugin(name, async () => list),
      local: pluginFile
    }
  ];
  const result = [];
  while (pluginsLeft.length > 0) {
    const head = pluginsLeft.shift();
    if (!head) {
      break;
    }
    const nestedFile = head.local ?? await pluginPath(head.name, root);
    const nestedPlugin = await head.plugin(head.config ?? {});
    const nestedPluginValues = Array.isArray(nestedPlugin) ? nestedPlugin : [nestedPlugin];
    for (const value of nestedPluginValues) {
      if (!value) {
        continue;
      }
      if ("__plugin_init__" in value) {
        pluginsLeft.push(value);
      } else {
        result.push({
          ...value,
          name: head.name,
          filepath: nestedFile
        });
      }
    }
  }
  return result;
}
async function readConfigFile(configPath = DEFAULT_CONFIG_PATH) {
  let importPath2 = importPath(configPath);
  let imported;
  try {
    imported = await import(importPath2);
  } catch (e3) {
    throw new Error(`Could not load config file at file://${configPath}.
${e3.message}`);
  }
  const config = imported.default || imported;
  return config;
}
var orderedPlugins = (plugins) => {
  const ordered = plugins.filter(
    (plugin2) => plugin2.order === "before" || plugin2.order === void 0
  );
  ordered.push(
    ...plugins.filter((plugin2) => plugin2.order === "core"),
    ...plugins.filter((plugin2) => plugin2.order === "after")
  );
  return ordered;
};
async function pluginPath(plugin_name, config_path) {
  try {
    if (process.versions.pnp) {
      const { findPnpApi } = require("node:module");
      const pnp = findPnpApi(config_path);
      return pnp.resolveRequest(plugin_name, config_path, { conditions: /* @__PURE__ */ new Set(["import"]) });
    }
    const pluginDirectory = findModule(plugin_name, config_path);
    const packageJsonSrc = await readFile(join2(pluginDirectory, "package.json"));
    if (!packageJsonSrc) {
      throw new Error("skip");
    }
    const packageJSON2 = JSON.parse(packageJsonSrc);
    if (!packageJSON2.exports?.["."]?.import) {
      throw new Error("");
    }
    return join2(pluginDirectory, packageJSON2.exports["."].import);
  } catch {
    const err = new Error(
      `Could not find plugin: ${plugin_name}. Are you sure its installed? If so, please open a ticket on GitHub.`
    );
    throw err;
  }
}
function findModule(pkg = "houdini", currentLocation) {
  const pathEndingBy = ["node_modules", pkg];
  let locationFound = join2(currentLocation, ...pathEndingBy);
  let previousLocation = "";
  const backFolder = [];
  while (previousLocation !== locationFound && !existsSync(locationFound)) {
    previousLocation = locationFound;
    backFolder.push("../");
    locationFound = join2(currentLocation, ...backFolder, ...pathEndingBy);
  }
  if (previousLocation === locationFound) {
    throw new Error("Could not find any node_modules/houdini folder");
  }
  return locationFound;
}
async function loadSchemaFile(schemaPath) {
  if (isAbsolute(schemaPath)) {
    const relPath = relative(process.cwd(), schemaPath);
    const error = new Error(
      `Invalid config value: 'schemaPath' must now be passed as a relative directory. Please change its value to "./${relPath}".`
    );
    error.stack = "";
    throw error;
  }
  if (glob.hasMagic(schemaPath)) {
    const sourceFiles = await glob(schemaPath);
    return mergeSchemas({
      typeDefs: await Promise.all(
        sourceFiles.map(async (filepath) => await readFile(filepath))
      )
    });
  }
  try {
    await stat(schemaPath);
  } catch {
    throw new HoudiniError({
      message: `Schema file does not exist! Create it using houdini pull-schema`
    });
  }
  const contents = await readFile(schemaPath);
  if (schemaPath.endsWith("gql") || schemaPath.endsWith("graphql")) {
    return graphql2.buildSchema(contents);
  }
  const jsonContents = JSON.parse(contents);
  if (jsonContents.data) {
    return graphql2.buildClientSchema(jsonContents.data);
  }
  return graphql2.buildClientSchema(jsonContents);
}
var emptySchema = graphql2.buildSchema("type Query { hello: String }");
var defaultDirectives = emptySchema.getDirectives().map((dir) => dir.name);

// src/lib/graphql.ts
var graphql3 = __toESM(require("graphql"), 1);
var import_node_crypto = __toESM(require("node:crypto"), 1);
function getRootType(type) {
  if (graphql3.isNonNullType(type)) {
    return getRootType(type.ofType);
  }
  if (graphql3.isListType(type)) {
    return getRootType(type.ofType);
  }
  return type;
}
function hashOriginal({ document }) {
  return hashDocument(document.originalString);
}
function hashRaw({ document }) {
  return hashDocument(document.artifact?.raw);
}
function hashDocument(str) {
  return import_node_crypto.default.createHash("sha256").update(str || "").digest("hex");
}
function parentField(ancestors) {
  return walkParentField([...ancestors].sort(() => -1));
}
function walkParentField(ancestors) {
  let head = ancestors.shift();
  if (Array.isArray(head) || head.kind === "SelectionSet") {
    return walkParentField(ancestors);
  }
  return head;
}
function parentTypeFromAncestors(schema, filepath, ancestors) {
  const parents = [...ancestors];
  parents.reverse();
  return walkAncestors(schema, filepath, parents);
}
function walkAncestors(schema, filepath, ancestors) {
  let head = ancestors.shift();
  if (Array.isArray(head)) {
    return walkAncestors(schema, filepath, ancestors);
  }
  if (!head) {
    throw new HoudiniError({ filepath, message: "Could not figure out type of field" });
  }
  if (head.kind === "OperationDefinition") {
    const operationType = {
      query: schema.getQueryType(),
      mutation: schema.getMutationType(),
      subscription: schema.getSubscriptionType()
    }[head.operation];
    if (!operationType) {
      throw new HoudiniError({ filepath, message: "Could not find operation type" });
    }
    return operationType;
  }
  if (head.kind === "FragmentDefinition") {
    const result = schema.getType(head.typeCondition.name.value);
    if (!result) {
      throw new HoudiniError({
        filepath,
        message: `Could not find definition for ${head.typeCondition.name.value} in the schema`
      });
    }
    return result;
  }
  if (head.kind === "FragmentSpread") {
    throw new Error("How the hell did this happen?");
  }
  const parent2 = walkAncestors(schema, filepath, ancestors);
  if (head.kind === "InlineFragment") {
    if (!head.typeCondition) {
      return parent2;
    }
    const wrapper = schema.getType(head.typeCondition.name.value);
    if (!wrapper) {
      throw new HoudiniError({
        filepath,
        message: "Could not find type with name: " + head.typeCondition.name.value
      });
    }
    return wrapper;
  }
  if (head.kind === "SelectionSet") {
    return parent2;
  }
  const field = parent2.getFields()[head.name.value];
  if (!field) {
    throw new HoudiniError({
      filepath,
      message: `Could not find definition of ${head.name.value} in ${parent2.toString()}`
    });
  }
  return getRootType(field.type);
}
function definitionFromAncestors(ancestors) {
  let parents = [...ancestors];
  parents.shift();
  let definition = parents.shift();
  while (Array.isArray(definition) && definition) {
    definition = parents.shift();
  }
  return { parents, definition };
}
function formatErrors(e3, afterError) {
  const errors = Array.isArray(e3) ? e3 : [e3];
  for (const error of errors) {
    if ("filepath" in error && error.filepath) {
      const relative2 = relative(process.cwd(), error.filepath);
      console.error(`\u274C Encountered error in ${relative2}`);
      if (error.message) {
        console.error(error.message);
      }
    } else {
      console.error(`\u274C ${error.message}`);
      if ("description" in error && error.description) {
        console.error(`${error.description}`);
      }
    }
    afterError?.(e3);
  }
}
function unwrapType(config, type, wrappers = []) {
  if (type.kind === "NonNullType") {
    return unwrapType(config, type.type, [TypeWrapper.NonNull, ...wrappers]);
  }
  if (type instanceof graphql3.GraphQLNonNull) {
    return unwrapType(config, type.ofType, [TypeWrapper.NonNull, ...wrappers]);
  }
  if (wrappers[0] !== TypeWrapper.NonNull) {
    wrappers.unshift(TypeWrapper.Nullable);
  }
  if (type.kind === "ListType") {
    return unwrapType(config, type.type, [TypeWrapper.List, ...wrappers]);
  }
  if (type instanceof graphql3.GraphQLList) {
    return unwrapType(config, type.ofType, [TypeWrapper.List, ...wrappers]);
  }
  const namedType = config.schema.getType(type.name.value || type.name);
  if (!namedType) {
    throw new Error("Could not unwrap type: " + JSON.stringify(type));
  }
  return { type: namedType, wrappers };
}
function wrapType({
  type,
  wrappers
}) {
  const head = wrappers[0];
  const tail = wrappers.slice(1);
  let kind = graphql3.Kind.NAMED_TYPE;
  if (head === TypeWrapper.List) {
    kind = graphql3.Kind.LIST_TYPE;
  } else if (head === TypeWrapper.NonNull) {
    kind = graphql3.Kind.NON_NULL_TYPE;
  }
  if (kind === "NamedType") {
    return {
      kind,
      name: {
        kind: graphql3.Kind.NAME,
        value: type.name
      }
    };
  }
  return {
    kind,
    type: wrapType({ type, wrappers: tail })
  };
}
var TypeWrapper = /* @__PURE__ */ ((TypeWrapper2) => {
  TypeWrapper2["Nullable"] = "Nullable";
  TypeWrapper2["List"] = "List";
  TypeWrapper2["NonNull"] = "NonNull";
  return TypeWrapper2;
})(TypeWrapper || {});

// src/lib/parse.ts
var import_parser = __toESM(require_lib3(), 1);
var import_recast = __toESM(require_main2(), 1);

// src/lib/deepMerge.ts
var import_deepmerge = __toESM(require_cjs(), 1);
function deepMerge2(filepath, ...targets) {
  try {
    if (targets.length === 1) {
      return targets[0];
    } else if (targets.length === 2) {
      return (0, import_deepmerge.default)(targets[0], targets[1], {
        arrayMerge: (source, update) => [...new Set(source.concat(update))]
      });
    }
    return deepMerge2(filepath, targets[0], deepMerge2(filepath, ...targets.slice(1)));
  } catch (e3) {
    throw new HoudiniError({
      filepath,
      message: "could not merge: " + JSON.stringify(targets, null, 4),
      description: e3.message
    });
  }
}

// src/lib/parse.ts
function parseJS(str, config) {
  const defaultConfig = {
    plugins: ["typescript", "importAssertions", "decorators-legacy"],
    sourceType: "module"
  };
  return (0, import_parser.parse)(str || "", config ? deepMerge2("", defaultConfig, config) : defaultConfig).program;
}
function parseJSON(str) {
  str = str.replace(/\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g, (m3, g3) => g3 ? "" : m3);
  return JSON.parse(str);
}
async function printJS(script, options) {
  if (options?.pretty) {
    return (0, import_recast.prettyPrint)(script, options);
  } else {
    return (0, import_recast.print)(script, options);
  }
}

// src/lib/imports.ts
var recast = __toESM(require_main2(), 1);
var AST = recast.types.builders;
function ensureImports({
  config,
  body,
  import: importID,
  sourceModule,
  importKind
}) {
  if (!importID) {
    if (body.find(
      (statement) => statement.type === "ImportDeclaration" && statement.source.value === sourceModule
    )) {
      return null;
    }
    body.unshift({
      type: "ImportDeclaration",
      source: AST.stringLiteral(sourceModule),
      specifiers: [],
      importKind
    });
    return null;
  }
  const idList = Array.isArray(importID) ? importID : [importID];
  const toImport = idList.filter(
    (identifier) => !body.find(
      (statement) => statement.type === "ImportDeclaration" && statement.specifiers.find(
        (importSpecifier) => importSpecifier.type === "ImportSpecifier" && importSpecifier.imported.type === "Identifier" && importSpecifier.imported.name === identifier && importSpecifier.local.name === identifier || importSpecifier.type === "ImportDefaultSpecifier" && importSpecifier.local.type === "Identifier" && importSpecifier.local.name === identifier
      )
    )
  );
  if (toImport.length > 0) {
    body.unshift({
      type: "ImportDeclaration",
      source: AST.stringLiteral(sourceModule),
      specifiers: toImport.map(
        (identifier) => !Array.isArray(importID) ? AST.importDefaultSpecifier(AST.identifier(identifier)) : AST.importSpecifier(AST.identifier(identifier), AST.identifier(identifier))
      ),
      importKind
    });
  }
  return Array.isArray(importID) ? toImport : toImport[0];
}

// src/lib/cleanupFiles.ts
async function cleanupFiles(pathFolder, listOfObj) {
  const listFile = await readdir(pathFolder);
  const storeListFile = listFile.filter((c2) => c2.endsWith(".js") && c2 !== "index.js").map((c2) => c2.slice(0, -3)).sort();
  let allFilesNotInList = storeListFile.filter((x3) => !listOfObj.includes(x3));
  await Promise.all(
    allFilesNotInList.map(async (storeName) => {
      await remove(join2(pathFolder, `${storeName}.js`));
      await remove(join2(pathFolder, `${storeName}.d.ts`));
    })
  );
  return allFilesNotInList;
}

// src/lib/detectTools.ts
async function detectFromPackageJSON(cwd) {
  try {
    const packageJSONFile = await fs_exports.readFile(path_exports.join(cwd, "package.json"));
    if (packageJSONFile) {
      var packageJSON2 = JSON.parse(packageJSONFile);
    } else {
      throw new Error("not found");
    }
  } catch {
    throw new Error(
      "\u274C houdini init must target an existing node project (with a package.json)"
    );
  }
  const { devDependencies, dependencies } = packageJSON2;
  const hasDependency = (dep) => Boolean(devDependencies?.[dep] || dependencies?.[dep]);
  let frameworkInfo = { framework: "svelte" };
  if (hasDependency("@sveltejs/kit")) {
    frameworkInfo = { framework: "kit" };
  }
  return {
    frameworkInfo,
    module: packageJSON2["type"] === "module" ? "esm" : "commonjs"
  };
}
async function detectTools(cwd = process.cwd()) {
  let typescript = false;
  try {
    await fs_exports.stat(path_exports.join(cwd, "tsconfig.json"));
    typescript = true;
  } catch {
  }
  let package_manager = "npm";
  let dir = cwd;
  do {
    if (fs_exports.existsSync(path_exports.join(dir, "pnpm-lock.yaml"))) {
      package_manager = "pnpm";
      break;
    }
    if (fs_exports.existsSync(path_exports.join(dir, "yarn.lock"))) {
      package_manager = "yarn";
      break;
    }
  } while (dir !== (dir = path_exports.dirname(dir)));
  return {
    typescript,
    package_manager,
    ...await detectFromPackageJSON(cwd)
  };
}

// ../../node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/walker.js
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  replace(parent2, prop, index, node) {
    if (parent2) {
      if (index !== null) {
        parent2[prop][index] = node;
      } else {
        parent2[prop] = node;
      }
    }
  }
  remove(parent2, prop, index) {
    if (parent2) {
      if (index !== null) {
        parent2[prop].splice(index, 1);
      } else {
        delete parent2[prop];
      }
    }
  }
};

// ../../node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/async.js
var AsyncWalker = class extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  async visit(node, parent2, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        await this.enter.call(this.context, node, parent2, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent2, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent2, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      for (const key in node) {
        const value = node[key];
        if (typeof value !== "object") {
          continue;
        } else if (Array.isArray(value)) {
          for (let i2 = 0; i2 < value.length; i2 += 1) {
            if (value[i2] !== null && typeof value[i2].type === "string") {
              if (!await this.visit(value[i2], node, key, i2)) {
                i2--;
              }
            }
          }
        } else if (value !== null && typeof value.type === "string") {
          await this.visit(value, node, key, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        await this.leave.call(this.context, node, parent2, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent2, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent2, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
};

// ../../node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/index.js
async function asyncWalk(ast, { enter, leave }) {
  const instance = new AsyncWalker(enter, leave);
  return await instance.visit(ast, null);
}

// src/lib/walk.ts
var graphql4 = __toESM(require("graphql"), 1);
async function find_graphql(config, parsedScript, walker) {
  await asyncWalk(parsedScript, {
    async enter(node, parent2) {
      if (node.type !== "TaggedTemplateExpression" && node.type !== "CallExpression" && node.type !== "TSPropertySignature") {
        return;
      }
      let documentString = "";
      let propName = "";
      if (node.type === "TaggedTemplateExpression") {
        const expr = node;
        if (expr.tag.type !== "Identifier" || expr.tag.name !== "graphql") {
          return;
        }
        documentString = expr.quasi.quasis[0].value.raw;
      } else if (node.type === "CallExpression") {
        const expr = node;
        if (expr.callee.type !== "Identifier" || expr.callee.name !== "graphql" || expr.arguments.length !== 1) {
          return;
        }
        const argument = expr.arguments[0];
        if (argument.type === "TemplateLiteral") {
          documentString = argument.quasis[0].value.raw;
        } else if (argument.type === "StringLiteral") {
          documentString = argument.value;
        } else {
          return;
        }
      } else if (node.type === "TSPropertySignature" && !walker.skipGraphqlType) {
        const signature = node;
        if (signature.typeAnnotation?.typeAnnotation?.type !== "TSTypeReference") {
          return;
        }
        const annotation = signature.typeAnnotation?.typeAnnotation;
        if (annotation.typeName.type !== "Identifier") {
          return;
        }
        if (annotation.typeName.name !== "GraphQL") {
          return;
        }
        if (annotation.typeParameters?.params[0].type !== "TSLiteralType") {
          return;
        }
        const literal = annotation.typeParameters?.params[0];
        if (literal.literal.type === "StringLiteral") {
          documentString = literal.literal.value;
        } else if (literal.literal.type === "TemplateLiteral") {
          documentString = literal.literal.quasis[0].value.raw;
        }
        if (signature.key.type === "Identifier") {
          propName = signature.key.name;
        }
      } else if (!documentString) {
        return;
      }
      const parsedTag = graphql4.parse(documentString);
      if (walker.where && !walker.where(parsedTag, { node, parent: parent2 })) {
        return;
      }
      let anonOkay = false;
      let definitions = [
        { raw: documentString, parsed: config.extractDefinition(parsedTag) }
      ];
      const name = definitions[0].parsed.name?.value;
      let kind;
      if (definitions[0].parsed.kind === "FragmentDefinition") {
        kind = CompiledFragmentKind;
      } else {
        if (definitions[0].parsed.operation === "query") {
          kind = CompiledQueryKind;
        } else if (definitions[0].parsed.operation === "mutation") {
          kind = CompiledMutationKind;
        } else {
          kind = CompiledSubscriptionKind;
        }
      }
      if (kind === CompiledQueryKind) {
        anonOkay = definitions[0].parsed.selectionSet.selections.every(
          (selection) => selection.kind === "InlineFragment" && selection.directives?.find(
            (directive) => directive.name.value === config.componentFieldDirective
          )
        );
        if (name) {
          definitions = [{ parsed: definitions[0].parsed, raw: definitions[0].raw }];
        } else if (config.configFile.features?.componentFields) {
          definitions = extractAnonymousQuery(
            config,
            definitions[0].raw,
            definitions[0].parsed,
            propName
          );
        }
      }
      if (!name && !anonOkay) {
        throw new Error("Could not find definition name");
      }
      walker.dependency?.(config.artifactPath(parsedTag));
      for (const definition of definitions) {
        const name2 = definition.parsed.name?.value;
        if (!name2) {
          continue;
        }
        await walker.tag({
          parsedDocument: { kind: "Document", definitions: [definition.parsed] },
          node: {
            ...node,
            ...this,
            remove: this.remove,
            replaceWith: this.replace
          },
          artifact: {
            name: name2,
            kind
          },
          parent: parent2,
          tagContent: definition.raw
        });
      }
    }
  });
}
function extractAnonymousQuery(config, raw, expr, propName) {
  const definitions = expr.selectionSet.selections.reduce(
    (defs, selection) => {
      if (selection.kind !== "InlineFragment") {
        return defs;
      }
      const componentField = selection.directives.find(
        (dir) => dir.name.value === config.componentFieldDirective
      );
      const fragmentName = config.componentFieldFragmentName({
        type: selection.typeCondition.name.value,
        entry: componentField
      });
      if (componentField) {
        componentField.arguments = [
          ...componentField?.arguments ?? [],
          {
            kind: "Argument",
            name: {
              kind: "Name",
              value: "raw"
            },
            value: {
              kind: "StringValue",
              value: raw
            }
          }
        ];
      }
      if (componentField && propName && !componentField.arguments?.find((arg) => arg.name.value === "prop")) {
        componentField.arguments = [
          ...componentField?.arguments ?? [],
          {
            kind: "Argument",
            name: {
              kind: "Name",
              value: "prop"
            },
            value: {
              kind: "StringValue",
              value: propName
            }
          }
        ];
      }
      const parsed = {
        kind: "FragmentDefinition",
        typeCondition: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: selection.typeCondition?.name.value || ""
          }
        },
        name: {
          kind: "Name",
          value: fragmentName
        },
        selectionSet: {
          kind: "SelectionSet",
          selections: selection.selectionSet.selections
        },
        directives: selection.directives
      };
      return defs.concat([
        {
          raw: graphql4.print(parsed),
          parsed
        }
      ]);
    },
    []
  );
  if (definitions.length > 1) {
    throw new Error("Anonymous queries can only contain a single inline fragment");
  }
  return definitions;
}

// src/lib/router/manifest.ts
var t2 = __toESM(require_lib6(), 1);
var graphql5 = __toESM(require("graphql"), 1);

// src/lib/router/server.ts
var import_node_path2 = __toESM(require("node:path"), 1);
async function buildLocalSchema(config) {
  const { build } = await import("vite");
  process.env.HOUDINI_SECONDARY_BUILD = "true";
  const schema = import_node_path2.default.join(config.localApiDir, "+schema");
  await build({
    logLevel: "silent",
    build: {
      outDir: import_node_path2.default.join(config.rootDir, "temp"),
      rollupOptions: {
        input: {
          schema
        },
        output: {
          entryFileNames: "assets/[name].js"
        }
      },
      ssr: true,
      lib: {
        entry: {
          schema
        },
        formats: ["es"]
      }
    }
  });
  process.env.HOUDINI_SECONDARY_BUILD = "false";
}
async function loadLocalSchema(config) {
  await buildLocalSchema(config);
  const { default: schema } = await import(import_node_path2.default.join(config.rootDir, "temp", "assets", `schema.js?${Date.now().valueOf()}}`));
  return schema;
}

// src/codegen/index.ts
var graphql32 = __toESM(require("graphql"), 1);

// src/codegen/generators/artifacts/index.ts
var graphql16 = __toESM(require("graphql"), 1);
var recast5 = __toESM(require_main2(), 1);

// src/codegen/utils/commonjs.ts
var cjsIndexFilePreamble = `"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });`;
function exportStarFrom(where) {
  return `__exportStar(require("${where}"), exports);`;
}
function exportDefaultFrom(where, as) {
  return `var ${as} = require("${where}");
${exportDefault(as)}`;
}
function exportDefault(as) {
  return `Object.defineProperty(exports, "${as}", { enumerable: true, get: function () { return __importDefault(${as}).default; } });`;
}
function importDefaultFrom(where, as) {
  return `var ${as} = require("${where}")`;
}

// src/codegen/utils/flattenSelections.ts
function flattenSelections({
  config,
  filepath,
  selections,
  fragmentDefinitions,
  applyFragments
}) {
  const fields = new FieldCollection({
    config,
    filepath,
    selections,
    fragmentDefinitions,
    applyFragments: !!applyFragments
  });
  return fields.toSelectionSet();
}
var FieldCollection = class {
  config;
  fragmentDefinitions;
  filepath;
  fields;
  inlineFragments;
  fragmentSpreads;
  applyFragments;
  constructor(args) {
    this.config = args.config;
    this.fragmentDefinitions = args.fragmentDefinitions;
    this.applyFragments = args.applyFragments;
    this.fields = {};
    this.inlineFragments = {};
    this.fragmentSpreads = {};
    this.filepath = args.filepath;
    for (const selection of args.selections) {
      this.add({ selection });
    }
  }
  get size() {
    return Object.keys(this.fields).length + Object.keys(this.inlineFragments).length + Object.keys(this.fragmentSpreads).length;
  }
  add({ selection, external }) {
    let include = this.config.defaultFragmentMasking === "disable";
    const maskEnableDirective = selection.directives?.find(
      ({ name }) => name.value === this.config.maskEnableDirective
    );
    if (maskEnableDirective) {
      include = false;
    }
    const maskDisableDirective = selection.directives?.find(
      ({ name }) => name.value === this.config.maskDisableDirective
    );
    if (maskDisableDirective) {
      include = true;
    }
    if (selection.kind === "Field") {
      const key = selection.alias?.value || selection.name.value;
      if (!this.fields[key]) {
        this.fields[key] = {
          astNode: selection,
          selection: this.empty()
        };
      }
      for (const subselect of selection.selectionSet?.selections || []) {
        this.fields[key].selection.add({
          selection: subselect,
          external
        });
      }
      if (this.applyFragments && !external) {
        this.fields[key].selection.fragmentSpreads = {
          ...this.collectFragmentSpreads(selection.selectionSet?.selections ?? []),
          ...this.fields[key].selection.fragmentSpreads
        };
      }
      return;
    }
    if (selection.kind === "InlineFragment" && !selection.typeCondition) {
      for (const subselect of selection.selectionSet.selections) {
        this.add({ selection: subselect, external });
      }
    }
    if (selection.kind === "InlineFragment" && selection.typeCondition) {
      this.walkInlineFragment({ selection, external });
      return;
    }
    if (selection.kind === "FragmentSpread") {
      if (!external || include) {
        this.fragmentSpreads[selection.name.value] = selection;
      }
      const definition = this.fragmentDefinitions[selection.name.value];
      if (!definition) {
        throw new HoudiniError({
          filepath: this.filepath,
          message: "Could not find referenced fragment definition: " + selection.name.value + "\n" + JSON.stringify(Object.keys(this.fragmentDefinitions), null, 4)
        });
      }
      if (this.applyFragments || include) {
        this.add({
          selection: {
            kind: "InlineFragment",
            typeCondition: {
              kind: "NamedType",
              name: {
                kind: "Name",
                value: definition.typeCondition.name.value
              }
            },
            selectionSet: {
              kind: "SelectionSet",
              selections: [...definition.selectionSet.selections]
            }
          },
          external: !include
        });
      }
    }
  }
  collectFragmentSpreads(selections, result = {}) {
    for (const selection of selections) {
      if (selection.kind === "Field") {
        continue;
      }
      if (selection.kind === "InlineFragment") {
        this.collectFragmentSpreads(selection.selectionSet.selections, result);
        continue;
      }
      if (selection.kind === "FragmentSpread") {
        result[selection.name.value] = selection;
        continue;
      }
    }
    return result;
  }
  toSelectionSet() {
    return Object.values(this.inlineFragments).flatMap((fragment2) => {
      if (fragment2.selection.size === 0) {
        return [];
      }
      fragment2.astNode = {
        ...fragment2.astNode,
        selectionSet: {
          ...fragment2.astNode.selectionSet,
          selections: fragment2.selection.toSelectionSet()
        }
      };
      return [fragment2.astNode];
    }).concat(
      Object.values(this.fields).map((field) => {
        return {
          ...field.astNode,
          selectionSet: field.astNode.selectionSet ? {
            kind: "SelectionSet",
            selections: field.selection.toSelectionSet()
          } : void 0
        };
      })
    ).concat(
      Object.values(this.fragmentSpreads).map((spread) => {
        return {
          kind: "FragmentSpread",
          name: {
            kind: "Name",
            value: spread.name.value
          },
          directives: spread.directives
        };
      })
    );
  }
  walkInlineFragment({
    selection,
    external
  }) {
    const key = selection.typeCondition.name.value;
    if (!this.inlineFragments[key]) {
      this.inlineFragments[key] = {
        astNode: selection,
        selection: this.empty()
      };
    }
    for (const subselect of selection.selectionSet.selections || []) {
      if (subselect.kind === "Field" || subselect.kind === "InlineFragment" && !subselect.typeCondition) {
        this.inlineFragments[key].selection.add({
          selection: subselect,
          external
        });
        continue;
      } else if (subselect.kind === "FragmentSpread") {
        this.add({
          selection: subselect,
          external
        });
        continue;
      } else {
        this.walkInlineFragment({ selection: subselect, external });
      }
    }
  }
  empty() {
    return new FieldCollection({
      config: this.config,
      fragmentDefinitions: this.fragmentDefinitions,
      selections: [],
      filepath: this.filepath,
      applyFragments: this.applyFragments
    });
  }
};

// src/codegen/utils/moduleExport.ts
var recast2 = __toESM(require_main2(), 1);
var AST2 = recast2.types.builders;
function moduleExport(config, key, value) {
  if (config.module === "commonjs") {
    let target = AST2.memberExpression(AST2.identifier("module"), AST2.identifier("exports"));
    if (key !== "default") {
      target = AST2.memberExpression(target, AST2.identifier(key));
    }
    return AST2.expressionStatement(AST2.assignmentExpression("=", target, value));
  }
  return key === "default" ? AST2.exportDefaultDeclaration(value) : AST2.exportNamedDeclaration(
    AST2.variableDeclaration("const", [
      AST2.variableDeclarator(AST2.identifier(key), value)
    ])
  );
}

// src/codegen/utils/murmur.ts
var BASE62 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function murmurHash(str) {
  const length = str.length;
  const rem = length & 3;
  const len = length ^ rem;
  let h4 = 0;
  let i2 = 0;
  let k3;
  while (i2 !== len) {
    const ch4 = str.charCodeAt(i2 + 3);
    k3 = str.charCodeAt(i2) ^ str.charCodeAt(i2 + 1) << 8 ^ str.charCodeAt(i2 + 2) << 16 ^ (ch4 & 255) << 24 ^ (ch4 & 65280) >> 8;
    i2 += 4;
    k3 = k3 * 11601 + (k3 & 65535) * 3432906752 >>> 0;
    k3 = k3 << 15 | k3 >>> 17;
    k3 = k3 * 13715 + (k3 & 65535) * 461832192 >>> 0;
    h4 ^= k3;
    h4 = h4 << 13 | h4 >>> 19;
    h4 = h4 * 5 + 3864292196 >>> 0;
  }
  k3 = 0;
  switch (rem) {
    case 3:
      k3 ^= str.charCodeAt(len + 2) << 16;
    case 2:
      k3 ^= str.charCodeAt(len + 1) << 8;
    case 1:
      k3 ^= str.charCodeAt(len);
      k3 = k3 * 11601 + (k3 & 65535) * 3432906752 >>> 0;
      k3 = k3 << 15 | k3 >>> 17;
      k3 = k3 * 13715 + (k3 & 65535) * 461832192 >>> 0;
      h4 ^= k3;
  }
  h4 ^= length;
  h4 ^= h4 >>> 16;
  h4 = h4 * 51819 + (h4 & 65535) * 2246770688 >>> 0;
  h4 ^= h4 >>> 13;
  h4 = h4 * 44597 + (h4 & 65535) * 3266445312 >>> 0;
  h4 ^= h4 >>> 16;
  h4 >>>= 0;
  if (!h4) {
    return "0";
  }
  let s2 = "";
  while (h4) {
    const d3 = h4 % 62;
    s2 = BASE62[d3] + s2;
    h4 = (h4 - d3) / 62;
  }
  return s2;
}

// ../../node_modules/.pnpm/@ungap+structured-clone@1.0.2/node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// ../../node_modules/.pnpm/@ungap+structured-clone@1.0.2/node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($3, _3) => {
  const as = (out, index) => {
    $3.set(index, out);
    return out;
  };
  const unpair = (index) => {
    if ($3.has(index))
      return $3.get(index);
    const [type, value] = _3[index];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index);
      case ARRAY: {
        const arr = as([], index);
        for (const index2 of value)
          arr.push(unpair(index2));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index);
        for (const [key, index2] of value)
          object[unpair(key)] = unpair(index2);
        return object;
      }
      case DATE:
        return as(new Date(value), index);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index);
      }
      case MAP: {
        const map = as(/* @__PURE__ */ new Map(), index);
        for (const [key, index2] of value)
          map.set(unpair(key), unpair(index2));
        return map;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index);
        for (const index2 of value)
          set.add(unpair(index2));
        return set;
      }
      case ERROR: {
        const { name, message } = value;
        return as(new env[name](message), index);
      }
      case BIGINT:
        return as(BigInt(value), index);
      case "BigInt":
        return as(Object(BigInt(value)), index);
    }
    return as(new env[type](value), index);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// ../../node_modules/.pnpm/@ungap+structured-clone@1.0.2/node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString } = {};
var { keys } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $3, _3) => {
  const as = (out, value) => {
    const index = _3.push(out) - 1;
    $3.set(value, index);
    return index;
  };
  const pair = (value) => {
    if ($3.has(value))
      return $3.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type)
          return as([type, [...value]], value);
        const arr = [];
        const index = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index;
      }
      case SET: {
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize = (value, { json, lossy } = {}) => {
  const _3 = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _3)(value), _3;
};

// ../../node_modules/.pnpm/@ungap+structured-clone@1.0.2/node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize(any, options));

// src/codegen/transforms/fragmentVariables.ts
var graphql7 = __toESM(require("graphql"), 1);

// src/codegen/transforms/collectDefinitions.ts
var graphql6 = __toESM(require("graphql"), 1);
var import_graphql31 = require("graphql");
async function includeFragmentDefinitions(config, documents) {
  const fragments = collectDefinitions(config, documents);
  for (const [index, { name, document, filename }] of documents.entries()) {
    const operation = document.definitions.find(
      (def) => def.kind === import_graphql31.Kind.OPERATION_DEFINITION || def.kind === "FragmentDefinition"
    );
    if (!operation) {
      continue;
    }
    const allFragments = flattenFragments(
      filename,
      {
        requiredFragments: findRequiredFragments(
          config,
          operation
        )
      },
      fragments
    );
    documents[index].document = {
      ...document,
      definitions: [
        operation,
        ...allFragments.map((fragmentName) => fragments[fragmentName].definition)
      ]
    };
  }
}
function collectDefinitions(config, docs) {
  return docs.reduce((acc, doc) => {
    const definitions = doc.document.definitions.reduce((prev, definition) => {
      return definition.kind !== "FragmentDefinition" ? prev : {
        ...prev,
        [definition.name.value]: {
          definition,
          requiredFragments: findRequiredFragments(config, definition),
          document: doc
        }
      };
    }, {});
    return {
      ...acc,
      ...definitions
    };
  }, {});
}
function findRequiredFragments(config, definition) {
  const referencedFragments = [];
  const typeInfo = new graphql6.TypeInfo(config.schema);
  definition.selectionSet = graphql6.visit(
    definition,
    graphql6.visitWithTypeInfo(typeInfo, {
      FragmentSpread(node) {
        referencedFragments.push(node.name.value);
      }
    })
  ).selectionSet;
  return referencedFragments;
}
function flattenFragments(filepath, operation, fragments) {
  const frags = /* @__PURE__ */ new Set();
  const remaining = [...operation.requiredFragments];
  while (remaining.length > 0) {
    const nextFragment = remaining.shift();
    if (!nextFragment) {
      continue;
    }
    if (!frags.has(nextFragment)) {
      frags.add(nextFragment);
    } else {
      continue;
    }
    const targetFragment = fragments[nextFragment];
    if (!targetFragment) {
      throw new HoudiniError({
        filepath,
        message: "compose: could not find definition for fragment " + nextFragment
      });
    }
    remaining.push(...targetFragment.requiredFragments);
  }
  return [...frags];
}

// src/codegen/transforms/fragmentVariables.ts
var GraphqlKinds2 = graphql7.Kind;
async function fragmentVariables(config, documents) {
  const fragments = collectDefinitions(config, documents);
  const generatedFragments = {};
  const visitedFragments = /* @__PURE__ */ new Set();
  for (const doc2 of documents) {
    const operation = doc2.document.definitions.find(
      ({ kind }) => kind === GraphqlKinds2.OPERATION_DEFINITION
    );
    if (!operation) {
      continue;
    }
    doc2.document = inlineFragmentArgs({
      config,
      filepath: doc2.filename,
      fragmentDefinitions: fragments,
      document: doc2.document,
      generatedFragments,
      visitedFragments,
      scope: null
    });
  }
  const doc = {
    kind: graphql7.Kind.DOCUMENT,
    definitions: Object.values(generatedFragments)
  };
  documents.push({
    name: "generated::fragmentVariables",
    kind: ArtifactKind.Fragment,
    document: doc,
    originalParsed: doc,
    generateStore: false,
    generateArtifact: false,
    filename: "generated::fragmentVariables",
    originalString: "",
    artifact: null
  });
}
function inlineFragmentArgs({
  config,
  filepath,
  fragmentDefinitions,
  document,
  generatedFragments,
  visitedFragments,
  scope,
  newName
}) {
  if (!scope) {
    scope = operationScope(
      document.definitions.find(
        ({ kind }) => kind === GraphqlKinds2.OPERATION_DEFINITION
      )
    );
  }
  const definitionArgs = fragmentArguments(
    config,
    filepath,
    document
  ).reduce((acc, arg) => ({ ...acc, [arg.name]: arg }), {});
  const modifyValue = (node) => {
    if (node.kind == "ObjectValue") {
      return {
        ...node,
        fields: node.fields.map((field) => {
          const modifiedValue = modifyValue(field.value);
          if (!modifiedValue)
            return null;
          return {
            ...field,
            value: modifyValue(field.value)
          };
        })
      };
    }
    if (node.kind !== "Variable") {
      return node;
    }
    if (!scope) {
      throw new HoudiniError({
        filepath,
        message: node.name.value + " is not defined in the current scope: " + JSON.stringify(scope)
      });
    }
    const newValue = scope[node.name.value];
    if (newValue) {
      return newValue;
    }
    if (definitionArgs[node.name.value] && definitionArgs[node.name.value].required) {
      throw new HoudiniError({
        filepath,
        message: "Missing value for required arg: " + node.name.value
      });
    }
    return null;
  };
  const result = esm_default(
    graphql7.visit(document, {
      FragmentSpread(node) {
        if (!fragmentDefinitions[node.name.value]) {
          throw new Error("Could not find definition for fragment" + node.name.value);
        }
        const { definition } = fragmentDefinitions[node.name.value];
        let { args, hash } = collectWithArguments(config, filepath, node, scope);
        const newFragmentName = `${node.name.value}${hash}`;
        config.registerFragmentVariablesHash({
          hash: newFragmentName,
          fragment: node.name.value,
          args
        });
        if (!visitedFragments.has(newFragmentName)) {
          visitedFragments.add(newFragmentName);
          const defaultArguments = collectDefaultArgumentValues(
            config,
            filepath,
            definition
          );
          if (args) {
            for (const [field, value] of Object.entries(defaultArguments || {})) {
              if (!args[field]) {
                args[field] = value;
              }
            }
            generatedFragments[newFragmentName] = inlineFragmentArgs({
              config,
              filepath,
              fragmentDefinitions,
              document: fragmentDefinitions[node.name.value].definition,
              generatedFragments,
              visitedFragments,
              scope: args,
              newName: newFragmentName
            });
          } else {
            const doc = fragmentDefinitions[node.name.value].document;
            const definitionIndex = doc.document.definitions.findIndex(
              (definition2) => definition2.kind === "FragmentDefinition" && definition2.name.value === node.name.value
            );
            const localDefinitions = [...doc.document.definitions];
            localDefinitions.splice(definitionIndex, 1);
            localDefinitions.push(
              inlineFragmentArgs({
                config,
                filepath,
                fragmentDefinitions,
                document: fragmentDefinitions[node.name.value].definition,
                generatedFragments,
                visitedFragments,
                scope: defaultArguments,
                newName: ""
              })
            );
            doc.document = {
              ...doc.document,
              definitions: localDefinitions
            };
          }
        }
        if (node.name.value !== newFragmentName) {
          return {
            ...node,
            name: {
              kind: "Name",
              value: newFragmentName
            }
          };
        }
      },
      Argument(node) {
        let value = node.value;
        const newValue = modifyValue(value);
        if (newValue) {
          return {
            ...node,
            value: newValue
          };
        }
        return null;
      }
    })
  );
  if (newName) {
    result.name = {
      kind: graphql7.Kind.NAME,
      value: newName
    };
  }
  return result;
}
function withArguments(config, node) {
  const withDirectives = node.directives?.filter(
    (directive) => directive.name.value === config.withDirective
  );
  if (!withDirectives || withDirectives.length === 0) {
    return [];
  }
  return withDirectives.flatMap((directive) => removeLocKey(directive.arguments) || []);
}
function removeLocKey(value) {
  if (typeof value !== "object" || value === null) {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(removeLocKey);
  }
  return Object.fromEntries(
    Object.entries(value).map(([key, fieldValue]) => {
      if (key === "loc") {
        return [];
      }
      return [key, removeLocKey(fieldValue)];
    })
  );
}
function fragmentArguments(config, filepath, definition) {
  const directives = definition.directives?.filter(
    (directive) => directive.name.value === config.argumentsDirective
  );
  if (!directives || directives.length === 0) {
    return [];
  }
  return directives.flatMap(
    (directive) => directive.arguments?.flatMap((arg) => {
      if (arg.value.kind !== "ObjectValue") {
        throw new HoudiniError({
          filepath,
          message: "values of @argument must be objects"
        });
      }
      const typeArg = arg.value.fields?.find((arg2) => arg2.name.value === "type")?.value;
      if (!typeArg || typeArg.kind !== "StringValue") {
        return [];
      }
      let type = parseArgumentTypeString(typeArg.value);
      let defaultValue = arg.value.fields?.find((arg2) => arg2.name.value === "default")?.value || null;
      return [
        {
          name: arg.name.value,
          type,
          required: type.kind === "NonNullType",
          defaultValue
        }
      ];
    }) || []
  );
}
function parseArgumentTypeString(input) {
  if (input[input.length - 1] === "!") {
    const inner = parseArgumentTypeString(input.substring(0, input.length - 1));
    if (inner.kind === "NonNullType") {
      throw new Error("invalid type" + input);
    }
    return {
      kind: "NonNullType",
      type: inner
    };
  }
  if (input[input.length - 1] === "]") {
    const inner = parseArgumentTypeString(input.substring(1, input.length - 1));
    return {
      kind: "ListType",
      type: inner
    };
  }
  return {
    kind: "NamedType",
    name: {
      kind: "Name",
      value: input
    }
  };
}
function collectDefaultArgumentValues(config, filepath, definition) {
  let result = {};
  for (const { name, required, defaultValue } of fragmentArguments(
    config,
    filepath,
    definition
  )) {
    if (required || !defaultValue) {
      continue;
    }
    result[name] = defaultValue;
  }
  return result;
}
function collectWithArguments(config, filepath, node, scope = {}) {
  const withArgs = withArguments(config, node);
  if (withArgs.length === 0) {
    return { args: null, hash: "" };
  }
  let args = {};
  for (const arg of withArgs) {
    let value = arg.value;
    if (value.kind === GraphqlKinds2.VARIABLE) {
      if (!scope || !scope[value.name.value]) {
        throw new HoudiniError({
          filepath,
          message: "Encountered undefined variable: " + value.name.value
        });
      }
      value = scope[value.name.value];
    }
    value.loc = void 0;
    args[arg.name.value] = {
      ...value,
      loc: void 0
    };
  }
  return {
    args,
    hash: "_" + murmurHash(JSON.stringify(args))
  };
}
function operationScope(operation) {
  return operation.variableDefinitions?.reduce(
    (scope, definition) => ({
      ...scope,
      [definition.variable.name.value]: {
        kind: "Variable",
        name: {
          kind: "Name",
          value: definition.variable.name.value
        }
      }
    }),
    {}
  ) || {};
}
function fragmentArgumentsDefinitions(config, filepath, definition) {
  const args = fragmentArguments(config, filepath, definition);
  if (args.length === 0) {
    return [];
  }
  return args.map((arg) => {
    return {
      kind: "VariableDefinition",
      type: arg.type,
      variable: {
        kind: "Variable",
        name: {
          kind: "Name",
          value: arg.name
        }
      },
      defaultValue: arg.defaultValue ?? void 0
    };
  });
}

// src/codegen/generators/artifacts/indexFile.ts
async function writeIndexFile(config, docs) {
  const docsToGenerate = docs.filter((doc) => doc.generateArtifact).sort((a2, b2) => a2.name.localeCompare(b2.name));
  let body = config.module === "esm" ? docsToGenerate.reduce(
    (content, doc) => content + `
 export { default as ${doc.name}} from './${doc.name}'`,
    ""
  ) : docsToGenerate.reduce(
    (content, doc) => content + `
${exportDefaultFrom(`./${doc.name}`, doc.name)}`,
    cjsIndexFilePreamble
  );
  await fs_exports.writeFile(path_exports.join(config.artifactDirectory, "index.js"), body);
}

// src/codegen/generators/artifacts/inputs.ts
var graphql8 = __toESM(require("graphql"), 1);
var recast3 = __toESM(require_main2(), 1);
var AST3 = recast3.types.builders;
function inputObject(config, inputs) {
  const visitedTypes = /* @__PURE__ */ new Set();
  const inputObj = {
    fields: inputs.reduce((fields, input) => {
      const { type } = unwrapType(config, input.type);
      return {
        ...fields,
        [input.variable.name.value]: type.name
      };
    }, {}),
    types: {}
  };
  for (const input of inputs) {
    walkInputs(config, visitedTypes, inputObj, input.type);
  }
  return inputObj;
}
function walkInputs(config, visitedTypes, inputObj, rootType) {
  const { type } = unwrapType(config, rootType);
  if (visitedTypes.has(type.name)) {
    return;
  }
  if (graphql8.isEnumType(type) || graphql8.isScalarType(type)) {
    return;
  }
  if (graphql8.isUnionType(type)) {
    return;
  }
  visitedTypes.add(type.name);
  inputObj.types[type.name] = Object.values(type.getFields()).reduce(
    (typeFields, field) => {
      const { type: fieldType } = unwrapType(config, field.type);
      walkInputs(config, visitedTypes, inputObj, fieldType);
      return {
        ...typeFields,
        [field.name]: fieldType.toString()
      };
    },
    {}
  );
}

// src/codegen/generators/artifacts/operations.ts
var graphql10 = __toESM(require("graphql"), 1);

// src/codegen/generators/artifacts/utils.ts
var graphql9 = __toESM(require("graphql"), 1);
var recast4 = __toESM(require_main2(), 1);
var AST4 = recast4.types.builders;
function serializeValue(value) {
  if (Array.isArray(value)) {
    return AST4.arrayExpression(value.map(serializeValue));
  }
  if (typeof value === "object" && value !== null) {
    return AST4.objectExpression(
      Object.entries(value).filter(([key, value2]) => typeof value2 !== "undefined").map(([key, val]) => {
        return AST4.objectProperty(AST4.stringLiteral(key), serializeValue(val));
      })
    );
  }
  if (typeof value === "string") {
    if (value.indexOf("\n") !== -1) {
      return AST4.templateLiteral(
        [AST4.templateElement({ raw: value, cooked: value }, true)],
        []
      );
    }
    return AST4.stringLiteral(value);
  }
  return AST4.literal(value);
}
function convertValue(config, val) {
  let value;
  let kind;
  if (val.kind === graphql9.Kind.INT) {
    value = parseInt(val.value, 10);
    kind = "Int";
  } else if (val.kind === graphql9.Kind.FLOAT) {
    value = parseFloat(val.value);
    kind = "Float";
  } else if (val.kind === graphql9.Kind.BOOLEAN) {
    value = val.value;
    kind = "Boolean";
  } else if (val.kind === graphql9.Kind.VARIABLE) {
    value = val.name.value;
    kind = "Variable";
  } else if (val.kind === graphql9.Kind.STRING) {
    value = val.value;
    kind = "String";
  }
  return { kind, value };
}

// src/codegen/generators/artifacts/operations.ts
function operationsByPath(config, filepath, definition, filterTypes) {
  if (!definition) {
    return {};
  }
  const pathOperations = {};
  graphql10.visit(definition, {
    FragmentSpread(node, _3, __, ___, ancestors) {
      if (!config.isListFragment(node.name.value)) {
        return;
      }
      const path3 = ancestorKey(ancestors);
      if (!pathOperations[path3]) {
        pathOperations[path3] = [];
      }
      pathOperations[path3].push(
        operationObject({
          config,
          filepath,
          listName: config.listNameFromFragment(node.name.value),
          operationKind: config.listOperationFromFragment(node.name.value),
          type: parentTypeFromAncestors(config.schema, filepath, ancestors).name,
          selection: node
        })
      );
    },
    Directive(node, _3, __, ___, ancestors) {
      if (!config.isDeleteDirective(node.name.value)) {
        return;
      }
      const path3 = ancestorKey(ancestors);
      if (!pathOperations[path3]) {
        pathOperations[path3] = [];
      }
      pathOperations[path3].push(
        operationObject({
          config,
          filepath,
          listName: node.name.value,
          operationKind: "delete",
          type: config.listNameFromDirective(node.name.value),
          selection: ancestors[ancestors.length - 1]
        })
      );
    }
  });
  return pathOperations;
}
function operationObject({
  config,
  listName,
  operationKind,
  type,
  selection,
  filepath
}) {
  let parentID;
  let parentKind = "String";
  let position = config.internalListPosition;
  let allLists = config.defaultListTarget ?? void 0;
  let operationWhen;
  const internalDirectives = selection.directives?.filter(
    (directive) => config.isInternalDirective(directive.name.value)
  );
  if (internalDirectives && internalDirectives.length > 0) {
    const prepend = internalDirectives.find(
      ({ name }) => name.value === config.listPrependDirective
    );
    const append = internalDirectives.find(
      ({ name }) => name.value === config.listAppendDirective
    );
    if (append) {
      position = "last";
    }
    if (prepend) {
      position = "first";
    }
    const allListsDirective = internalDirectives.find(
      ({ name }) => name.value === config.listAllListsDirective
    );
    let parent2 = internalDirectives.find(
      ({ name }) => name.value === config.listParentDirective
    );
    allLists = allListsDirective ? "all" : void 0;
    const when = internalDirectives.find(({ name }) => name.value === "when");
    const when_not = internalDirectives.find(({ name }) => name.value === "when_not");
    let parentIDArg = parent2?.arguments?.find((argument) => argument.name.value === "value");
    if (parentIDArg) {
      if (parentIDArg.value.kind === "StringValue") {
        parentID = parentIDArg.value.value;
        parentKind = "String";
      } else if (parentIDArg.value.kind === "Variable") {
        parentKind = "Variable";
        parentID = parentIDArg.value.name.value;
      }
    }
    const whenArg = (append || prepend)?.arguments?.find(({ name }) => name.value === "when");
    const whenNotArg = (append || prepend)?.arguments?.find(
      ({ name }) => name.value === "when_not"
    );
    for (const [i2, arg] of [whenArg, whenNotArg].entries()) {
      if (!arg || arg.value.kind !== "ObjectValue") {
        continue;
      }
      if (!operationWhen) {
        operationWhen = {};
      }
      operationWhen[i2 ? "must_not" : "must"] = arg.value.fields.reduce(
        (obj, arg2) => ({
          ...obj,
          [arg2.name.value]: convertValue(config, arg2.value).value
        }),
        {}
      );
    }
    for (const [i2, directive] of [when, when_not].entries()) {
      if (!directive) {
        continue;
      }
      const which = i2 ? "must_not" : "must";
      if (!operationWhen) {
        operationWhen = {};
      }
      operationWhen[which] = directive.arguments?.reduce(
        (filters, argument) => ({
          ...filters,
          [argument.name.value]: convertValue(config, argument.value).value
        }),
        {}
      );
    }
  }
  const operation = {
    action: operationKind
  };
  if (operationKind !== "delete") {
    operation.list = listName;
  }
  if (operationKind === "delete" && type) {
    operation.type = type;
  }
  if (operationKind === "insert" || operationKind === "toggle") {
    operation.position = position;
  }
  if (allLists && operationKind !== "delete") {
    operation.target = "all";
  }
  if (parentID) {
    operation.parentID = {
      kind: parentKind,
      value: parentID
    };
  }
  if (operationWhen) {
    operation.when = operationWhen;
  }
  return operation;
}
function ancestorKey(ancestors) {
  return ancestors.filter(
    (entry) => !Array.isArray(entry) && entry.kind === "Field"
  ).map((field) => field.name.value).join(",");
}

// src/codegen/generators/artifacts/selection.ts
var graphql15 = __toESM(require("graphql"), 1);

// src/codegen/transforms/list.ts
var graphql13 = __toESM(require("graphql"), 1);

// src/codegen/utils/objectIdentificationSelection.ts
var graphql11 = __toESM(require("graphql"), 1);
var objectIdentificationSelection = (config, type) => {
  return config.keyFieldsForType(type.name).map((key) => {
    return {
      kind: graphql11.Kind.FIELD,
      name: {
        kind: graphql11.Kind.NAME,
        value: key
      }
    };
  });
};

// src/codegen/transforms/paginate.ts
var graphql12 = __toESM(require("graphql"), 1);
async function paginate(config, documents) {
  const newDocs = [];
  for (const doc of documents) {
    let paginated = false;
    const flags = {
      first: {
        enabled: false,
        type: "Int"
      },
      after: {
        enabled: false,
        type: "String"
      },
      last: {
        enabled: false,
        type: "Int"
      },
      before: {
        enabled: false,
        type: "String"
      },
      limit: {
        enabled: false,
        type: "Int"
      },
      offset: {
        enabled: false,
        type: "Int"
      }
    };
    let cursorType = "String";
    let paginationPath = [];
    doc.document = graphql12.visit(doc.document, {
      Field(node, _3, __, ___, ancestors) {
        const paginateDirective = node.directives?.find(
          (directive) => directive.name.value === config.paginateDirective
        );
        if (!paginateDirective || !node.selectionSet) {
          return;
        }
        paginated = true;
        const fieldTypeFields = parentTypeFromAncestors(config.schema, doc.filename, ancestors).getFields()[node.name.value];
        const args = new Set(fieldTypeFields.args.map((arg) => arg.name));
        cursorType = fieldTypeFields.args?.find((arg) => ["before", "after"].includes(arg.name))?.type?.name || "String";
        flags.after.type = cursorType;
        flags.before.type = cursorType;
        const passedArgs = new Set(node.arguments?.map((arg) => arg.name.value));
        const forwards = args.has("first") && args.has("after");
        const backwards = args.has("last") && args.has("after");
        const cursorPagination = passedArgs.has("last") || passedArgs.has("first");
        const offsetPagination = !cursorPagination && args.has("offset") && args.has("limit");
        flags.first.enabled = forwards;
        flags.after.enabled = forwards;
        flags.last.enabled = backwards;
        flags.before.enabled = backwards;
        flags.offset.enabled = offsetPagination;
        flags.limit.enabled = offsetPagination;
        paginationPath = ancestors.filter(
          (ancestor) => !Array.isArray(ancestor) && ancestor.kind === graphql12.Kind.FIELD
        ).concat(node).map((field) => field.alias?.value || field.name.value);
        return {
          ...node,
          arguments: replaceArgumentsWithVariables(node.arguments, flags),
          selectionSet: offsetPagination ? node.selectionSet : {
            ...node.selectionSet,
            selections: [...node.selectionSet.selections, ...pageInfoSelection]
          }
        };
      }
    });
    if (paginated) {
      let fragmentName = "";
      let refetchQueryName = "";
      let nodeQuery = false;
      let fragment2 = "";
      let paginateMode = config.defaultPaginateMode;
      doc.document = graphql12.visit(doc.document, {
        OperationDefinition(node) {
          if (node.operation !== "query") {
            throw new HoudiniError({
              filepath: doc.filename,
              message: `@${config.paginateDirective} can only show up in a query or fragment document`
            });
          }
          refetchQueryName = node.name?.value || "";
          const operationVariables = node.variableDefinitions?.reduce(
            (vars, definition) => ({
              ...vars,
              [definition.variable.name.value]: definition
            }),
            {}
          ) || {};
          let newVariables = Object.fromEntries(
            Object.entries(flags).filter(
              ([, spec]) => spec.enabled && spec.variableName === void 0
            ).map(([fieldName, spec]) => [
              fieldName,
              staticVariableDefinition(
                fieldName,
                spec.type,
                spec.defaultValue,
                spec.variableName
              )
            ])
          );
          const variableNames = new Set(
            Object.keys(operationVariables).concat(Object.keys(newVariables))
          );
          const finalVariables = [...variableNames].map(
            (name) => operationVariables[name] || newVariables[name]
          );
          return {
            ...node,
            variableDefinitions: finalVariables
          };
        },
        FragmentDefinition(node) {
          fragment2 = node.typeCondition.name.value;
          fragmentName = node.name.value;
          refetchQueryName = config.paginationQueryName(fragmentName);
          nodeQuery = node.typeCondition.name.value !== config.schema.getQueryType()?.name;
          const argDirective = node.directives?.find(
            (directive) => directive.name.value === config.argumentsDirective
          );
          if (!argDirective) {
            return {
              ...node,
              directives: [
                ...node.directives || [],
                {
                  kind: graphql12.Kind.DIRECTIVE,
                  name: {
                    kind: graphql12.Kind.NAME,
                    value: config.argumentsDirective
                  }
                }
              ]
            };
          }
        },
        Directive(node) {
          if (node.name.value === config.paginateDirective) {
            const paginateModeArg = node?.arguments?.find(
              (arg) => arg.name.value === config.paginateModeArg
            );
            if (paginateModeArg && paginateModeArg.value.kind === "EnumValue") {
              paginateMode = paginateModeArg.value.value;
            }
          }
          if (node.name.value !== config.argumentsDirective) {
            return;
          }
          let newArgs = [
            ...Object.entries(flags).filter(([, spec]) => spec.enabled).map(
              ([key, spec]) => argumentNode(key, [spec.type, spec.defaultValue])
            )
          ];
          return {
            ...node,
            arguments: [...node.arguments || [], ...newArgs]
          };
        }
      });
      let targetType = config.schema.getQueryType()?.name || "";
      if (fragment2) {
        const nodeInterface = config.schema.getType("Node");
        if (nodeInterface) {
          const { objects, interfaces } = config.schema.getImplementations(nodeInterface);
          if (objects.find((obj) => obj.name === fragment2) || interfaces.find((int) => int.name === fragment2)) {
            targetType = "Node";
          } else {
            targetType = fragment2;
          }
        } else {
          targetType = fragment2;
        }
      }
      const pageSize = flags.first.defaultValue ?? flags.last.defaultValue ?? flags.limit.defaultValue;
      const start = flags.after.defaultValue ?? flags.before.defaultValue ?? flags.offset.defaultValue;
      let direction = "forward";
      if (flags.before.enabled && flags.after.enabled) {
        direction = "both";
      } else if (flags.before.enabled) {
        direction = "backward";
      }
      doc.refetch = {
        path: paginationPath,
        method: flags.first.enabled || flags.last.enabled ? "cursor" : "offset",
        pageSize,
        embedded: nodeQuery,
        targetType,
        paginated: true,
        direction,
        start,
        mode: paginateMode
      };
      if (!fragment2) {
        continue;
      }
      const paginationArgs = Object.entries(flags).filter(([_3, { enabled }]) => enabled).map(([key, value]) => ({ name: key, ...value }));
      const fragmentSpreadSelection = [
        {
          kind: graphql12.Kind.FRAGMENT_SPREAD,
          name: {
            kind: graphql12.Kind.NAME,
            value: fragmentName
          },
          directives: [
            {
              kind: graphql12.Kind.DIRECTIVE,
              name: {
                kind: graphql12.Kind.NAME,
                value: config.withDirective
              },
              ["arguments"]: paginationArgs.map(
                ({ name }) => variableAsArgument(name)
              )
            },
            {
              kind: graphql12.Kind.DIRECTIVE,
              name: {
                kind: "Name",
                value: config.maskDisableDirective
              }
            }
          ]
        }
      ];
      const keys2 = config.keyFieldsForType(!nodeQuery ? config.schema.getQueryType()?.name || "" : fragment2).flatMap((key) => {
        if (fragment2 === config.schema.getQueryType()?.name) {
          return [];
        }
        const fragmentType = config.schema.getType(fragment2);
        const { type, wrappers } = unwrapType(
          config,
          fragmentType.getFields()[key].type
        );
        return [
          {
            name: key,
            type: wrapType({ type, wrappers })
          }
        ];
      });
      const typeConfig = config.typeConfig?.[fragment2];
      const queryDoc = {
        kind: graphql12.Kind.DOCUMENT,
        definitions: [
          {
            kind: graphql12.Kind.OPERATION_DEFINITION,
            name: {
              kind: graphql12.Kind.NAME,
              value: refetchQueryName
            },
            operation: "query",
            variableDefinitions: paginationArgs.map(
              (arg) => ({
                kind: graphql12.Kind.VARIABLE_DEFINITION,
                type: {
                  kind: graphql12.Kind.NAMED_TYPE,
                  name: {
                    kind: graphql12.Kind.NAME,
                    value: arg.type
                  }
                },
                variable: {
                  kind: graphql12.Kind.VARIABLE,
                  name: {
                    kind: graphql12.Kind.NAME,
                    value: arg.name
                  }
                },
                defaultValue: !flags[arg.name].defaultValue ? void 0 : {
                  kind: arg.type + "Value",
                  value: flags[arg.name].defaultValue
                }
              })
            ).concat(
              !nodeQuery ? [] : keys2.map(
                (key) => ({
                  kind: graphql12.Kind.VARIABLE_DEFINITION,
                  type: key.type,
                  variable: {
                    kind: graphql12.Kind.VARIABLE,
                    name: {
                      kind: graphql12.Kind.NAME,
                      value: key.name
                    }
                  }
                })
              )
            ),
            selectionSet: {
              kind: graphql12.Kind.SELECTION_SET,
              selections: !nodeQuery ? fragmentSpreadSelection : [
                {
                  kind: graphql12.Kind.FIELD,
                  name: {
                    kind: graphql12.Kind.NAME,
                    value: typeConfig?.resolve?.queryField || "node"
                  },
                  ["arguments"]: keys2.map((key) => ({
                    kind: graphql12.Kind.ARGUMENT,
                    name: {
                      kind: graphql12.Kind.NAME,
                      value: key.name
                    },
                    value: {
                      kind: graphql12.Kind.VARIABLE,
                      name: {
                        kind: graphql12.Kind.NAME,
                        value: key.name
                      }
                    }
                  })),
                  selectionSet: {
                    kind: graphql12.Kind.SELECTION_SET,
                    selections: [
                      {
                        kind: graphql12.Kind.FIELD,
                        name: {
                          kind: graphql12.Kind.NAME,
                          value: "__typename"
                        }
                      },
                      ...(typeConfig?.keys || [config.defaultKeys[0]]).map((key) => ({
                        kind: graphql12.Kind.FIELD,
                        name: {
                          kind: graphql12.Kind.NAME,
                          value: key
                        }
                      })),
                      ...fragmentSpreadSelection
                    ]
                  }
                }
              ]
            }
          }
        ]
      };
      newDocs.push({
        kind: ArtifactKind.Query,
        filename: doc.filename,
        name: refetchQueryName,
        document: queryDoc,
        originalParsed: queryDoc,
        generateArtifact: true,
        generateStore: false,
        refetch: doc.refetch,
        originalString: "",
        artifact: null
      });
    }
  }
  documents.push(...newDocs);
}
function replaceArgumentsWithVariables(args, flags) {
  const seenArgs = {};
  const newArgs = (args || []).map((arg) => {
    const spec = flags[arg.name.value];
    if (!spec || !spec.enabled) {
      return arg;
    }
    if (arg.value.kind !== "Variable") {
      const oldValue = arg.value.value;
      flags[arg.name.value].defaultValue = spec.type === "Int" ? parseInt(oldValue) : oldValue;
    }
    if (arg.value.kind === "Variable") {
      flags[arg.name.value].variableName = arg.value.name.value;
    }
    seenArgs[arg.name.value] = true;
    return variableAsArgument(arg.name.value, flags[arg.name.value].variableName);
  });
  for (const name of Object.keys(flags)) {
    const spec = flags[name];
    if (flags[name].defaultValue || !spec.enabled || seenArgs[name]) {
      continue;
    }
    newArgs.push(variableAsArgument(name));
  }
  return newArgs;
}
function variableAsArgument(name, variable) {
  return {
    kind: graphql12.Kind.ARGUMENT,
    name: {
      kind: graphql12.Kind.NAME,
      value: name
    },
    value: {
      kind: graphql12.Kind.VARIABLE,
      name: {
        kind: graphql12.Kind.NAME,
        value: variable ?? name
      }
    }
  };
}
function staticVariableDefinition(name, type, defaultValue, variableName) {
  return {
    kind: graphql12.Kind.VARIABLE_DEFINITION,
    type: {
      kind: graphql12.Kind.NAMED_TYPE,
      name: {
        kind: graphql12.Kind.NAME,
        value: type
      }
    },
    variable: {
      kind: graphql12.Kind.VARIABLE,
      name: {
        kind: graphql12.Kind.NAME,
        value: variableName ?? name
      }
    },
    defaultValue: !defaultValue ? void 0 : {
      kind: type + "Value",
      value: defaultValue
    }
  };
}
function argumentNode(name, value) {
  return {
    kind: graphql12.Kind.ARGUMENT,
    name: {
      kind: graphql12.Kind.NAME,
      value: name
    },
    value: objectNode(value)
  };
}
function objectNode([type, defaultValue]) {
  const node = {
    kind: graphql12.Kind.OBJECT,
    fields: [
      {
        kind: graphql12.Kind.OBJECT_FIELD,
        name: {
          kind: graphql12.Kind.NAME,
          value: "type"
        },
        value: {
          kind: graphql12.Kind.STRING,
          value: type
        }
      }
    ]
  };
  if (defaultValue) {
    node.fields.push({
      kind: graphql12.Kind.OBJECT_FIELD,
      name: { kind: graphql12.Kind.NAME, value: "default" },
      value: {
        kind: typeof defaultValue === "number" ? "IntValue" : "StringValue",
        value: defaultValue.toString()
      }
    });
  }
  return node;
}
var pageInfoSelection = [
  {
    kind: graphql12.Kind.FIELD,
    name: {
      kind: graphql12.Kind.NAME,
      value: "edges"
    },
    selectionSet: {
      kind: graphql12.Kind.SELECTION_SET,
      selections: [
        {
          kind: graphql12.Kind.FIELD,
          name: {
            kind: graphql12.Kind.NAME,
            value: "cursor"
          }
        },
        {
          kind: graphql12.Kind.FIELD,
          name: {
            kind: graphql12.Kind.NAME,
            value: "node"
          },
          selectionSet: {
            kind: graphql12.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql12.Kind.FIELD,
                name: {
                  kind: graphql12.Kind.NAME,
                  value: "__typename"
                }
              }
            ]
          }
        }
      ]
    }
  },
  {
    kind: graphql12.Kind.FIELD,
    name: {
      kind: graphql12.Kind.NAME,
      value: "pageInfo"
    },
    selectionSet: {
      kind: graphql12.Kind.SELECTION_SET,
      selections: [
        {
          kind: graphql12.Kind.FIELD,
          name: {
            kind: graphql12.Kind.NAME,
            value: "hasPreviousPage"
          }
        },
        {
          kind: graphql12.Kind.FIELD,
          name: {
            kind: graphql12.Kind.NAME,
            value: "hasNextPage"
          }
        },
        {
          kind: graphql12.Kind.FIELD,
          name: {
            kind: graphql12.Kind.NAME,
            value: "startCursor"
          }
        },
        {
          kind: graphql12.Kind.FIELD,
          name: {
            kind: graphql12.Kind.NAME,
            value: "endCursor"
          }
        }
      ]
    }
  }
];

// src/codegen/transforms/list.ts
async function addListFragments(config, documents) {
  const lists = {};
  const errors = [];
  for (const doc of documents) {
    doc.document = graphql13.visit(doc.document, {
      Directive(node, key, parent2, path3, ancestors) {
        if ([config.listDirective, config.paginateDirective].includes(node.name.value)) {
          const nameArg = node.arguments?.find(
            (arg) => arg.name.value === config.listOrPaginateNameArg
          );
          let error = {
            ...new graphql13.GraphQLError(
              "",
              node,
              new graphql13.Source(""),
              node.loc ? [node.loc.start, node.loc.end] : null,
              path3
            ),
            filepath: doc.filename
          };
          if (!nameArg) {
            if (node.name.value === config.listDirective) {
              error.message = `@${node.name.value} must have a name argument`;
              errors.push(error);
            }
            return;
          }
          if (nameArg.value.kind !== "StringValue") {
            error.message = `@${node.name.value} name must be a string`;
            errors.push(error);
            return;
          }
          if (lists[nameArg.value.value]) {
            error.message = `@${node.name.value} name must be unique`;
            errors.push(error);
          }
          const parentType = parentTypeFromAncestors(
            config.schema,
            doc.filename,
            ancestors.slice(0, -1)
          );
          const targetField = ancestors[ancestors.length - 1];
          const targetFieldDefinition = parentType.getFields()[targetField.name.value];
          const { selection, type, connection } = connectionSelection(
            config,
            targetFieldDefinition,
            parentTypeFromAncestors(
              config.schema,
              doc.filename,
              ancestors
            ),
            ancestors[ancestors.length - 1].selectionSet
          );
          lists[nameArg.value.value] = {
            selection,
            type,
            filename: doc.filename
          };
          if (connection) {
            return {
              ...node,
              arguments: [
                ...node.arguments,
                {
                  kind: "Argument",
                  name: {
                    kind: graphql13.Kind.NAME,
                    value: "connection"
                  },
                  value: {
                    kind: "BooleanValue",
                    value: true
                  }
                }
              ]
            };
          }
        }
      },
      Field(node, key, parent2, path3, ancestors) {
        if (!node.directives?.find(
          (directive) => directive.name.value === config.listDirective
        )) {
          return;
        }
        const parentType = parentTypeFromAncestors(config.schema, doc.filename, ancestors);
        const targetField = node;
        const targetFieldDefinition = parentType.getFields()[targetField.name.value];
        const { connection } = connectionSelection(
          config,
          targetFieldDefinition,
          parentTypeFromAncestors(
            config.schema,
            doc.filename,
            ancestors
          ),
          node.selectionSet
        );
        if (connection) {
          return {
            ...node,
            selectionSet: {
              ...node.selectionSet,
              selections: [...node.selectionSet.selections, ...pageInfoSelection]
            }
          };
        }
      }
    });
  }
  if (errors.length > 0) {
    throw errors;
  }
  const validDeletes = [
    ...new Set(
      Object.values(lists).map(({ type }) => {
        if (!(type instanceof graphql13.GraphQLObjectType)) {
          return "";
        }
        if (config.keyFieldsForType(type.name).length !== 1) {
          return "";
        }
        return type.name;
      })
    ).values()
  ].filter(Boolean);
  if (Object.keys(lists).length === 0) {
    return;
  }
  const generatedDoc = {
    kind: graphql13.Kind.DOCUMENT,
    definitions: Object.entries(lists).flatMap(
      ([name, { selection, type }]) => {
        const schemaType = config.schema.getType(type.name);
        if (!selection) {
          throw new HoudiniError({ message: "Lists must have a selection" });
        }
        const fragmentSelection = {
          kind: graphql13.Kind.SELECTION_SET,
          selections: [...selection.selections]
        };
        if (schemaType && fragmentSelection && !fragmentSelection?.selections.find(
          (field) => field.kind === "Field" && config.keyFieldsForType(type.name).includes(field.name.value)
        )) {
          fragmentSelection.selections = [
            ...fragmentSelection.selections,
            ...objectIdentificationSelection(config, type)
          ];
        }
        return [
          {
            name: {
              value: config.listInsertFragment(name),
              kind: graphql13.Kind.NAME
            },
            kind: graphql13.Kind.FRAGMENT_DEFINITION,
            selectionSet: fragmentSelection,
            typeCondition: {
              kind: graphql13.Kind.NAMED_TYPE,
              name: {
                kind: graphql13.Kind.NAME,
                value: type.name
              }
            }
          },
          {
            name: {
              value: config.listToggleFragment(name),
              kind: graphql13.Kind.NAME
            },
            kind: graphql13.Kind.FRAGMENT_DEFINITION,
            selectionSet: fragmentSelection,
            typeCondition: {
              kind: graphql13.Kind.NAMED_TYPE,
              name: {
                kind: graphql13.Kind.NAME,
                value: type.name
              }
            }
          },
          {
            kind: graphql13.Kind.FRAGMENT_DEFINITION,
            name: {
              value: config.listRemoveFragment(name),
              kind: graphql13.Kind.NAME
            },
            selectionSet: {
              kind: graphql13.Kind.SELECTION_SET,
              selections: [...objectIdentificationSelection(config, type)]
            },
            typeCondition: {
              kind: graphql13.Kind.NAMED_TYPE,
              name: {
                kind: graphql13.Kind.NAME,
                value: type.name
              }
            }
          }
        ];
      }
    ).concat(
      ...validDeletes.map((typeName) => ({
        kind: graphql13.Kind.DIRECTIVE_DEFINITION,
        name: {
          kind: graphql13.Kind.NAME,
          value: config.listDeleteDirective(typeName)
        },
        locations: [
          {
            kind: graphql13.Kind.NAME,
            value: "FIELD"
          }
        ],
        repeatable: true
      }))
    )
  };
  config.newSchema += "\n" + generatedDoc.definitions.filter((c2) => c2.kind !== "FragmentDefinition").map(graphql13.print).join("\n\n");
  config.newDocuments += "\n" + generatedDoc.definitions.filter((c2) => c2.kind === "FragmentDefinition").map(graphql13.print).join("\n\n");
  documents.push({
    name: "generated::lists",
    kind: ArtifactKind.Fragment,
    generateArtifact: false,
    generateStore: false,
    document: generatedDoc,
    originalParsed: generatedDoc,
    filename: "generated::lists",
    originalString: "",
    artifact: null
  });
}
function connectionSelection(config, field, type, selection) {
  const fieldArgs = field.args.reduce(
    (args, arg) => ({
      ...args,
      [arg.name]: unwrapType(config, arg.type).type.name
    }),
    {}
  );
  if (fieldArgs["limit"]) {
    return { selection, type, connection: false, error: null };
  }
  const forwardPagination = fieldArgs["first"] === "Int" && ["Cursor", "String"].includes(fieldArgs["after"]);
  const backwardsPagination = fieldArgs["last"] === "Int" && ["Cursor", "String"].includes(fieldArgs["before"]);
  if (!forwardPagination && !backwardsPagination) {
    return { selection, type, connection: false, error: missingPaginationArgMessage(config) };
  }
  const edgesField = selection?.selections.find(
    (selection2) => selection2.kind === "Field" && selection2.name.value === "edges"
  );
  if (!edgesField) {
    return { selection, type, connection: false, error: missingEdgeSelectionMessage(config) };
  }
  const nodeSelection = edgesField.selectionSet?.selections.find(
    (selection2) => selection2.kind === "Field" && selection2.name.value === "node"
  );
  if (!nodeSelection?.selectionSet) {
    return { selection, type, connection: false, error: missingNodeSelectionMessage(config) };
  }
  const edgeField = unwrapType(config, field.type).type.getFields()["edges"];
  const { wrappers, type: edgeFieldType } = unwrapType(config, edgeField.type);
  const list = wrappers[wrappers.length - 2] === "List" /* List */;
  if (!list) {
    return { selection, type, connection: false, error: edgeInvalidTypeMessage(config) };
  }
  const nodeField = edgeFieldType.getFields()["node"];
  if (!nodeField) {
    return { selection, type, connection: false, error: nodeNotDefinedMessage(config) };
  }
  return {
    selection: nodeSelection.selectionSet,
    type: unwrapType(config, nodeField.type).type,
    connection: true,
    error: null
  };
}
var missingPaginationArgMessage = (config) => `Looks like you are trying to use the ${green2(
  `@${config.paginateDirective}`
)} directive on a field but have not provided a ${yellow2("first")}, ${yellow2("last")}, or ${yellow2(
  "limit"
)} argument. Please add one and try again.
For more information, visit this link: ${siteURL}/guides/pagination`;
var missingEdgeSelectionMessage = (config) => `Looks like you are trying to use the ${green2(
  `@${config.paginateDirective}`
)} directive on a field but your selection does not contain an ${yellow2(
  "edges"
)} field. Please add one and try again.
For more information, visit this link: ${siteURL}/guides/pagination`;
var missingNodeSelectionMessage = (config) => `Looks like you are trying to use the ${green2(
  `@${config.paginateDirective}`
)} directive on a field but your selection does not contain a ${yellow2(
  "node"
)} field. Please add one and try again.
For more information, visit this link: ${siteURL}/guides/pagination`;
var edgeInvalidTypeMessage = (config) => `Looks like you are trying to use the ${green2(
  `@${config.paginateDirective}`
)} directive on a field but your field does not conform to the connection spec: your edges field seems strange.
For more information, visit this link: ${siteURL}/guides/pagination`;
var nodeNotDefinedMessage = (config) => `Looks like you are trying to use the ${green2(
  `@${config.paginateDirective}`
)} directive on a field but your field does not conform to the connection spec: your edge type does not have node as a field.
For more information, visit this link: ${siteURL}/guides/pagination`;

// src/codegen/generators/artifacts/fieldKey.ts
var graphql14 = __toESM(require("graphql"), 1);
function fieldKey(config, field) {
  const attributeName = field.alias?.value || field.name.value;
  const printed = graphql14.print(field);
  const secondParse = graphql14.parse(`{${printed}}`).definitions[0].selectionSet.selections[0];
  let paginateMode = config.defaultPaginateMode;
  const paginatedDirective = field.directives?.find(
    (directive) => directive.name.value === config.paginateDirective
  );
  if (paginatedDirective) {
    const paginateModeArg = paginatedDirective?.arguments?.find(
      (arg) => arg.name.value === config.paginateModeArg
    );
    if (paginateModeArg && paginateModeArg.value.kind === "EnumValue") {
      paginateMode = paginateModeArg.value.value;
    }
  }
  const paginationArgs = paginateMode === "SinglePage" ? [] : ["first", "after", "last", "before", "limit", "offset"];
  const argObj = (secondParse.arguments || []).reduce((acc, arg) => {
    const start = arg.value.loc?.start;
    const end = arg.value.loc?.end;
    if (paginatedDirective && paginationArgs.includes(arg.name.value)) {
      return acc;
    }
    if (!start || !end) {
      return acc;
    }
    return {
      ...acc,
      [arg.name.value]: printed.substring(start - 1, end - 1)
    };
  }, {});
  const args = Object.keys(argObj);
  args.sort();
  let key = Object.values(argObj).length > 0 ? `${attributeName}(${args.map((key2) => `${key2}: ${argObj[key2]}`).join(", ")})` : attributeName;
  if (paginatedDirective) {
    key = key + "::paginated";
  }
  return key;
}

// src/codegen/generators/artifacts/selection.ts
function selection_default(args) {
  return mergeSelection({
    config: args.config,
    rootType: args.rootType,
    object: prepareSelection(args),
    filepath: args.filepath
  });
}
function prepareSelection({
  config,
  filepath,
  rootType,
  selections,
  operations,
  path: path3 = [],
  document,
  inConnection,
  globalLoading,
  includeFragments,
  hasComponents
}) {
  let object = {};
  const loadingTypes = [];
  for (const field of selections) {
    if (field.kind === "InlineFragment") {
      if (!field.typeCondition || field.typeCondition.name.value === rootType) {
        object.fields = deepMerge2(
          filepath,
          object.fields || {},
          prepareSelection({
            config,
            filepath,
            rootType: field.typeCondition?.name.value || rootType,
            operations,
            selections: field.selectionSet.selections,
            path: path3,
            document,
            globalLoading,
            includeFragments,
            hasComponents
          }).fields || {}
        );
      } else {
        if (!object.abstractFields) {
          object.abstractFields = {
            fields: {},
            typeMap: {}
          };
        }
        const typeConditionName = field.typeCondition.name.value;
        object.abstractFields.fields = {
          ...object.abstractFields.fields,
          [typeConditionName]: prepareSelection({
            config,
            filepath,
            rootType: typeConditionName || rootType,
            operations,
            selections: field.selectionSet.selections,
            path: path3,
            document,
            globalLoading,
            includeFragments,
            hasComponents
          }).fields
        };
        if (field.directives?.find((d3) => d3.name.value === config.loadingDirective)) {
          loadingTypes.push(typeConditionName);
        }
      }
    } else if (field.kind === "Field") {
      const type = config.schema.getType(rootType);
      if (!type) {
        throw new HoudiniError({
          filepath,
          message: "Could not find type. Looking for " + JSON.stringify(rootType)
        });
      }
      const attributeName = field.alias?.value || field.name.value;
      let fieldType = null;
      let nullable = false;
      if (field.name.value === "__typename") {
        fieldType = config.schema.getType("String");
      } else if ("getFields" in type) {
        let typeRef = type.getFields()[field.name.value].type;
        fieldType = getRootType(typeRef);
        nullable = !graphql15.isNonNullType(typeRef);
      } else if (graphql15.isAbstractType(type)) {
        for (const possible of config.schema.getPossibleTypes(type)) {
          if (graphql15.isObjectType(possible)) {
            if (possible.getFields()[field.name.value]) {
              fieldType = possible.getFields()[field.name.value].type;
              nullable = !graphql15.isNonNullType(fieldType);
              break;
            }
          }
        }
      }
      if (!fieldType) {
        throw {
          message: "Could not identify field's type",
          description: `Missing definition for ${field.name.value} in ${type.name}`
        };
      }
      const typeName = getRootType(fieldType).name;
      const pathSoFar = path3.concat(attributeName);
      const keys2 = config.keyFieldsForType(rootType);
      let fieldObj = {
        type: typeName,
        keyRaw: fieldKey(config, field)
      };
      if (field.directives && field.directives.length > 0) {
        fieldObj.directives = field.directives?.map((directive) => ({
          name: directive.name.value,
          arguments: (directive.arguments ?? []).reduce(
            (acc, arg) => ({
              ...acc,
              [arg.name.value]: config.serializeValueMap({ field: arg.value })["field"]
            }),
            {}
          )
        }));
      }
      if (keys2.includes(field.name.value)) {
        fieldObj.visible = true;
      }
      if (nullable) {
        fieldObj.nullable = true;
      }
      const requiredDirective = field.directives?.find(
        (directive) => directive.name.value == config.requiredDirective
      );
      if (requiredDirective) {
        fieldObj.nullable = false;
        fieldObj.required = true;
      }
      const operationKey = pathSoFar.join(",");
      if (operations[operationKey]) {
        fieldObj.operations = operations[operationKey];
      }
      const listDirective = field.directives?.find(
        (directive) => [config.listDirective, config.paginateDirective].includes(directive.name.value)
      );
      const nameArg = listDirective?.arguments?.find(
        (arg) => arg.name.value === config.listOrPaginateNameArg
      );
      if (nameArg && nameArg.value.kind === "StringValue") {
        const { connection, type: connectionType } = connectionSelection(
          config,
          type.getFields()[field.name.value],
          fieldType,
          field.selectionSet
        );
        fieldObj.list = {
          name: nameArg.value.value,
          connection,
          type: connectionType.name
        };
      }
      const paginated = field.directives?.find(
        (directive) => directive.name.value === config.paginateDirective
      );
      if (paginated && document.refetch && document.refetch.method === "offset") {
        fieldObj.updates = [RefetchUpdateMode.append];
      }
      let continueConnection = inConnection;
      if ([
        "edges",
        "endCursor",
        "startCursor",
        "hasNextPage",
        "hasPreviousPage"
      ].includes(attributeName) && inConnection && document.refetch) {
        fieldObj.updates = [RefetchUpdateMode.append, RefetchUpdateMode.prepend];
      }
      if (attributeName === "node" && inConnection) {
        continueConnection = false;
      }
      const loadingDirective = field.directives?.find(
        (d3) => d3.name.value === config.loadingDirective
      );
      if (field.selectionSet) {
        const connectionState = paginated && document.refetch?.method === "cursor" || continueConnection;
        let forceLoading = globalLoading;
        if (loadingDirective?.arguments?.find(
          (arg) => arg.name.value === "cascade" && arg.value.kind === "BooleanValue"
        )?.value?.value) {
          forceLoading = true;
        }
        fieldObj.selection = prepareSelection({
          config,
          filepath,
          rootType: typeName,
          selections: field.selectionSet.selections,
          operations,
          path: pathSoFar,
          document,
          inConnection: connectionState,
          globalLoading: forceLoading,
          includeFragments,
          hasComponents
        });
        if (Object.values(fieldObj.selection.fields ?? {}).some((field2) => field2.required)) {
          fieldObj.nullable = true;
        }
      }
      if (field.arguments?.length && fieldObj.list) {
        fieldObj.filters = (field.arguments || []).reduce(
          (filters, arg) => ({
            ...filters,
            [arg.name.value]: convertValue(config, arg.value)
          }),
          {}
        );
      }
      if (globalLoading || loadingDirective) {
        const childFields = Object.values(fieldObj.selection?.fields ?? {}).concat(
          Object.values(fieldObj.selection?.abstractFields?.fields ?? {}).flatMap(
            (fieldMap) => Object.values(fieldMap ?? {})
          )
        );
        const loadingFragments = Object.values(fieldObj.selection?.fragments ?? {}).length > 0 && Object.values(fieldObj.selection?.fragments ?? {}).some((f5) => f5.loading);
        let deepestChild = !childFields.some((field2) => field2.loading) && !loadingFragments;
        const loadingValue = deepestChild ? {
          kind: "value"
        } : { kind: "continue" };
        const parentType = config.schema.getType(rootType);
        if (graphql15.isObjectType(parentType) || graphql15.isInterfaceType(parentType)) {
          const fieldType2 = parentType.getFields()[field.name.value]?.type;
          if (fieldType2) {
            const listCount = unwrapType(config, fieldType2).wrappers.filter(
              (w3) => w3 === "List" /* List */
            ).length;
            if (listCount > 0) {
              const countArg = loadingDirective?.arguments?.find(
                (arg) => arg.name.value === "count"
              );
              let countValue = 3;
              if (countArg?.value.kind === "IntValue") {
                countValue = parseInt(countArg.value.value);
              }
              loadingValue.list = {
                depth: listCount,
                count: countValue
              };
            }
          }
        }
        fieldObj.loading = loadingValue;
      }
      if (graphql15.isInterfaceType(fieldType) || graphql15.isUnionType(fieldType)) {
        fieldObj.abstract = true;
        if (Object.values(fieldObj.selection?.abstractFields?.fields ?? {}).some(
          (fields) => Object.values(fields ?? {}).some((field2) => field2.required)
        )) {
          fieldObj.abstractHasRequired = true;
        }
      }
      if (object.fields?.[attributeName]) {
        fieldObj = deepMerge2(filepath, object.fields[attributeName], fieldObj);
      }
      object.fields = {
        ...object.fields,
        [attributeName]: fieldObj
      };
    } else if (field.kind === "FragmentSpread") {
      const { fragment: fragment2, args } = config.getFragmentVariablesHash(field.name.value);
      object.fragments = {
        ...object.fragments,
        [fragment2]: {
          arguments: args ?? {}
        }
      };
      if (globalLoading || field.directives?.find((d3) => d3.name.value === config.loadingDirective)) {
        object.fragments[fragment2].loading = true;
      }
      const fieldDirective = field.directives?.find(
        (directive) => directive.name.value === config.componentFieldDirective
      );
      if (fieldDirective) {
        hasComponents();
        const fieldArg = fieldDirective.arguments?.find((arg) => arg.name.value === "field");
        const propArg = fieldDirective.arguments?.find((arg) => arg.name.value === "prop");
        if (fieldArg?.value.kind === "StringValue" && propArg?.value.kind === "StringValue") {
          const attributeName = fieldArg.value.value;
          const { fragment: fragment3, args: args2 } = config.getFragmentVariablesHash(field.name.value);
          object.fields = {
            ...object.fields,
            [attributeName]: {
              keyRaw: attributeName,
              type: config.componentScalar,
              component: {
                prop: propArg.value.value,
                key: `${rootType}.${attributeName}`,
                fragment: fragment3,
                variables: args2 ?? {}
              }
            }
          };
        }
      }
    }
  }
  if (loadingTypes.length > 0) {
    object.loadingTypes = loadingTypes;
  }
  return object;
}
function mergeSelection({
  config,
  filepath,
  object,
  rootType
}) {
  if (Object.keys(object.fields || {}).length > 0 && object.abstractFields && Object.keys(object.abstractFields.fields).length > 0) {
    const abstractSelection = {
      fields: {},
      typeMap: {}
    };
    const possibleSelectionTypes = {};
    for (const [typeName, typeSelection] of Object.entries(object.abstractFields.fields)) {
      const gqlType = config.schema.getType(typeName);
      abstractSelection.fields[typeName] = deepMerge2(
        filepath,
        typeSelection,
        abstractSelection.fields[typeName] ?? {}
      );
      if (graphql15.isAbstractType(gqlType)) {
        for (const possible of config.schema.getPossibleTypes(gqlType)) {
          if (!possibleSelectionTypes[typeName]) {
            possibleSelectionTypes[typeName] = [];
          }
          possibleSelectionTypes[typeName].push(possible.name);
        }
      }
    }
    const concreteSelectionImplements = {};
    for (const [typeName, possibles] of Object.entries(possibleSelectionTypes)) {
      for (const possible of possibles) {
        if (!concreteSelectionImplements[possible]) {
          concreteSelectionImplements[possible] = [];
        }
        concreteSelectionImplements[possible].push(typeName);
      }
    }
    for (const [concrete, implementations] of Object.entries(concreteSelectionImplements)) {
      if (implementations.length > 1) {
        abstractSelection.fields[concrete] = {};
      }
    }
    for (const [typeName, possibles] of Object.entries(possibleSelectionTypes)) {
      for (const possible of possibles) {
        if (abstractSelection.fields[possible]) {
          abstractSelection.fields[possible] = deepMerge2(
            filepath,
            abstractSelection.fields[typeName] ?? {},
            abstractSelection.fields[possible] ?? {}
          );
        }
      }
    }
    const parentType = config.schema.getType(rootType);
    const possibleParents = graphql15.isAbstractType(parentType) ? config.schema.getPossibleTypes(parentType)?.map((t3) => t3.name) : [parentType.name];
    for (const key of Object.keys(abstractSelection.typeMap)) {
      if (!possibleParents.includes(key) && rootType !== key || abstractSelection.fields[key]) {
        delete abstractSelection.typeMap[key];
      }
    }
    for (const [type, sel] of Object.entries(abstractSelection.fields || {})) {
      abstractSelection.fields[type] = deepMerge2(filepath, sel || {}, object.fields);
    }
    for (const [typename, possibles] of Object.entries(possibleSelectionTypes)) {
      if (possibles.every((p3) => abstractSelection.fields[p3])) {
        delete abstractSelection.fields[typename];
      }
    }
    for (const possible of possibleParents) {
      if (abstractSelection.fields[possible]) {
        continue;
      }
      for (const [abstractType, abstractTypeMembers] of Object.entries(
        possibleSelectionTypes
      )) {
        if (abstractTypeMembers.includes(possible)) {
          abstractSelection.typeMap[possible] = abstractType;
          break;
        }
      }
    }
    object.abstractFields = abstractSelection;
  }
  for (const value of Object.values(object.fields ?? {})) {
    const selection = value.selection;
    if (selection) {
      mergeSelection({
        config,
        rootType: value.type,
        filepath,
        object: selection
      });
    }
  }
  for (const [type, selection] of Object.entries(object.abstractFields?.fields ?? {})) {
    for (const value of Object.values(selection ?? {})) {
      const selection2 = value.selection;
      if (selection2) {
        mergeSelection({
          config,
          rootType: value.type,
          filepath,
          object: selection2
        });
      }
    }
  }
  return object;
}

// src/codegen/generators/artifacts/index.ts
var AST5 = recast5.types.builders;
function artifactGenerator(stats) {
  return async function(config, docs) {
    const filterTypes = {};
    for (const doc of docs) {
      graphql16.visit(doc.document, {
        Directive(node, _3, __, ___, ancestors) {
          if (node.name.value !== config.listDirective) {
            return;
          }
          const nameArg = node.arguments?.find(
            (arg) => arg.name.value === config.listOrPaginateNameArg
          );
          if (!nameArg || nameArg.value.kind !== "StringValue") {
            throw new HoudiniError({
              filepath: doc.filename,
              message: "could not find name arg in list directive"
            });
          }
          const listName = nameArg.value.value;
          let field = ancestors[ancestors.length - 1];
          let i2 = 1;
          while (Array.isArray(field)) {
            i2++;
            field = ancestors[ancestors.length - i2];
          }
          if (field.kind !== "Field") {
            return;
          }
          const parentType = parentTypeFromAncestors(config.schema, doc.filename, [
            ...ancestors.slice(0, -1)
          ]);
          const parentField2 = parentType.getFields()[field.name.value];
          if (!parentField2) {
            throw new HoudiniError({
              filepath: doc.filename,
              message: "Could not find field information when computing filters"
            });
          }
          const fieldType = getRootType(parentField2.type).toString();
          filterTypes[listName] = parentField2.args.reduce((prev, arg) => {
            return {
              ...prev,
              [arg.name]: getRootType(arg.type).toString()
            };
          }, {});
          filterTypes[`${fieldType}_delete`] = {
            ...filterTypes[`${fieldType}_delete`],
            ...filterTypes[listName]
          };
        }
      });
    }
    const listOfArtifacts = [];
    const hashPluginBaseRaw = config.plugins?.find((plugin2) => plugin2.hash)?.hash ?? hashRaw;
    await Promise.all(
      [
        writeIndexFile(config, docs)
      ].concat(
        docs.map(async (doc) => {
          const { document, name, generateArtifact, originalParsed } = doc;
          if (!generateArtifact) {
            return;
          }
          const usedVariableNames = /* @__PURE__ */ new Set();
          let documentWithoutInternalDirectives = graphql16.visit(document, {
            Directive(node) {
              if (config.isInternalDirective(node.name.value)) {
                return null;
              }
            },
            Variable(node, _key, parent2) {
              const variableIsBeingDefined = parent2 && !(parent2 instanceof Array) && parent2.kind === "VariableDefinition";
              if (!variableIsBeingDefined) {
                usedVariableNames.add(node.name.value);
              }
            }
          });
          let documentWithoutExtraVariables = graphql16.visit(
            documentWithoutInternalDirectives,
            {
              VariableDefinition(variableDefinitionNode) {
                const name2 = variableDefinitionNode.variable.name.value;
                if (!usedVariableNames.has(name2)) {
                  return null;
                }
              }
            }
          );
          let rawString = graphql16.print(documentWithoutExtraVariables);
          let docKind = doc.kind;
          const operations = document.definitions.filter(
            ({ kind }) => kind === graphql16.Kind.OPERATION_DEFINITION
          );
          const fragments = document.definitions.filter(
            ({ kind }) => kind === graphql16.Kind.FRAGMENT_DEFINITION
          );
          let rootType = "";
          let selectionSet;
          let originalSelectionSet = null;
          const fragmentDefinitions = doc.document.definitions.filter(
            (definition) => definition.kind === "FragmentDefinition"
          ).reduce(
            (prev, definition) => ({
              ...prev,
              [definition.name.value]: definition
            }),
            {}
          );
          if (docKind !== ArtifactKind.Fragment) {
            const operation = operations[0];
            if (operation.operation === "query") {
              rootType = config.schema.getQueryType()?.name;
            } else if (operation.operation === "mutation") {
              rootType = config.schema.getMutationType()?.name;
            } else if (operation.operation === "subscription") {
              rootType = config.schema.getSubscriptionType()?.name;
            }
            if (!rootType) {
              throw new HoudiniError({
                filepath: doc.filename,
                message: "could not find root type for operation: " + operation.operation + ". Maybe you need to re-run the introspection query?"
              });
            }
            selectionSet = operation.selectionSet;
            if (originalParsed.definitions[0].kind === "OperationDefinition") {
              originalSelectionSet = originalParsed.definitions[0].selectionSet;
            }
          } else {
            const matchingFragment = fragments.find(
              (fragment2) => fragment2.name.value === name
            );
            if (!matchingFragment) {
              throw new HoudiniError({
                filepath: doc.filename,
                message: `Fragment "${name}" doesn't exist in its own document?!`
              });
            }
            rootType = matchingFragment.typeCondition.name.value;
            selectionSet = matchingFragment.selectionSet;
            if (originalParsed.definitions[0].kind === "FragmentDefinition") {
              originalSelectionSet = originalParsed.definitions[0].selectionSet;
            }
          }
          if (!originalSelectionSet) {
            throw new Error("Not original selection set!");
          }
          let inputs = operations[0]?.variableDefinitions;
          let directive = fragments[0]?.directives?.find(
            (directive2) => directive2.name.value === config.argumentsDirective
          );
          if (docKind === ArtifactKind.Fragment && directive) {
            inputs = fragmentArgumentsDefinitions(config, doc.filename, fragments[0]);
          }
          let globalLoading = false;
          if (["HoudiniFragment", "HoudiniQuery"].includes(docKind)) {
            globalLoading = Boolean(
              fragments[0]?.directives?.find(
                (dir) => dir.name.value === config.loadingDirective
              ) ?? operations[0]?.directives?.find(
                (dir) => dir.name.value === config.loadingDirective
              )
            );
          }
          let hasComponents = false;
          let artifact = {
            name,
            kind: docKind,
            hash: "NOT_YET",
            refetch: doc.refetch,
            raw: rawString,
            rootType,
            selection: selection_default({
              config,
              filepath: doc.filename,
              document: doc,
              rootType,
              globalLoading,
              includeFragments: doc.kind !== ArtifactKind.Fragment,
              hasComponents: () => {
                hasComponents = true;
              },
              selections: flattenSelections({
                config,
                filepath: doc.filename,
                selections: selectionSet.selections,
                fragmentDefinitions,
                applyFragments: doc.kind !== ArtifactKind.Fragment
              }),
              operations: operationsByPath(
                config,
                doc.filename,
                operations[0],
                filterTypes
              )
            }),
            pluginData: {}
          };
          const hash_value = hashPluginBaseRaw({ config, document: { ...doc, artifact } });
          artifact.hash = hash_value;
          applyMask(
            config,
            artifact.selection,
            selection_default({
              config,
              filepath: doc.filename,
              rootType,
              operations: {},
              document: doc,
              hasComponents: () => {
                hasComponents = true;
              },
              selections: flattenSelections({
                config,
                filepath: doc.filename,
                selections: selectionSet.selections,
                fragmentDefinitions
              })
            })
          );
          if (hasComponents) {
            artifact.hasComponents = true;
          }
          if (docKind === "HoudiniQuery" || docKind === "HoudiniFragment") {
            const childFields = Object.values(artifact.selection?.fields ?? {}).concat(
              Object.values(artifact.selection?.abstractFields?.fields ?? {}).flatMap(
                (fieldMap) => Object.values(fieldMap ?? {})
              )
            );
            if (globalLoading || childFields.some((field) => field.loading)) {
              ;
              artifact.enableLoadingState = globalLoading ? "global" : "local";
            }
          }
          artifact.pluginData = {};
          for (const plugin2 of config.plugins) {
            if (!plugin2.artifactData) {
              continue;
            }
            artifact.pluginData[plugin2.name] = plugin2.artifactData({ config, document: doc }) ?? {};
          }
          if (inputs && inputs.length > 0) {
            artifact.input = inputObject(config, inputs);
          }
          if (artifact.kind === "HoudiniQuery") {
            const cacheDirective = operations[0].directives?.find(
              (directive2) => directive2.name.value === config.cacheDirective
            );
            if (cacheDirective) {
              const args = cacheDirective.arguments?.reduce(
                (acc, arg) => ({
                  ...acc,
                  [arg.name.value]: arg
                }),
                {}
              ) || {};
              const policy = args[config.cachePolicyArg];
              if (policy && policy.value.kind === "EnumValue" && policy.value.value) {
                artifact.policy = policy.value.value;
              } else {
                artifact.policy = config.defaultCachePolicy;
              }
              const partial = args[config.cachePartialArg];
              if (partial && partial.value.kind === "BooleanValue") {
                artifact.partial = partial.value.value;
              } else {
                artifact.partial = config.defaultPartial;
              }
            } else {
              artifact.policy = config.defaultCachePolicy;
              artifact.partial = config.defaultPartial;
            }
          }
          doc.artifact = artifact;
          for (const plugin2 of config.plugins) {
            if (!plugin2.artifactEnd) {
              continue;
            }
            plugin2.artifactEnd({ config, document: doc });
          }
          const _houdiniHash = hashOriginal({ document: doc });
          const file = AST5.program([
            moduleExport(config, "default", serializeValue(artifact)),
            AST5.expressionStatement(AST5.stringLiteral(`HoudiniHash=${_houdiniHash}`))
          ]);
          const artifactPath = config.artifactPath(document);
          const countDocument = doc.generateStore;
          let existingArtifact = await fs_exports.readFile(artifactPath);
          if (existingArtifact === null) {
            if (countDocument) {
              stats.new.push(artifact.name);
            }
          }
          const { code } = await printJS(file);
          await fs_exports.writeFile(artifactPath, code);
          listOfArtifacts.push(config.documentName(document));
          if (!countDocument) {
            return;
          }
          const match = existingArtifact && existingArtifact.match(/"HoudiniHash=(\w+)"/);
          if (match && match[1] !== _houdiniHash) {
            stats.changed.push(artifact.name);
          }
          stats.total.push(artifact.name);
          stats.hashSize.push(artifact.hash.length);
          stats.querySize.push(artifact.raw.length);
        })
      )
    );
    stats.deleted = await cleanupFiles(config.artifactDirectory, listOfArtifacts);
  };
}
function applyMask(config, target, mask) {
  const targetFields = Object.entries(target.fields ?? {}).concat(
    Object.values(target.abstractFields?.fields ?? {}).flatMap((typeMap) => Object.entries(typeMap))
  );
  for (const [fieldName, value] of Object.entries(mask.fields ?? {})) {
    for (const [potentialFieldName, targetSelection] of targetFields) {
      if (fieldName !== potentialFieldName) {
        continue;
      }
      if (!targetSelection) {
        continue;
      }
      targetSelection.visible = true;
      if (targetSelection.selection && value.selection) {
        applyMask(config, targetSelection.selection, value.selection);
      }
    }
  }
  for (const [type, selection] of Object.entries(mask.abstractFields?.fields ?? {})) {
    if (!selection) {
      continue;
    }
    if (target.abstractFields?.fields[type]) {
      applyMask(config, { fields: target.abstractFields.fields[type] }, { fields: selection });
    }
    const targetType = config.schema.getType(type);
    if (!targetType) {
      continue;
    }
    if (graphql16.isAbstractType(targetType)) {
      for (const possible of config.schema.getPossibleTypes(targetType)) {
        if (target.abstractFields?.fields[possible.name]) {
          applyMask(
            config,
            { fields: target.abstractFields.fields[possible.name] },
            { fields: selection }
          );
        }
      }
    }
    const mappedType = target.abstractFields?.typeMap[type];
    if (target.abstractFields && mappedType && target.abstractFields.fields[mappedType]) {
      applyMask(
        config,
        { fields: target.abstractFields.fields[mappedType] },
        { fields: selection }
      );
    }
  }
}

// src/codegen/generators/runtime/graphqlFunction.ts
var recast6 = __toESM(require_main2(), 1);
var AST6 = recast6.types.builders;
async function generateGraphqlReturnTypes(config, docs) {
  const indexPath = path_exports.join(config.runtimeDirectory, "index.d.ts");
  const fileContent = await fs_exports.readFile(indexPath) || "";
  const script = await parseJS(fileContent);
  const graphqlTagReturn = config.plugins.find(
    (plugin2) => plugin2.graphqlTagReturn
  )?.graphqlTagReturn;
  if (!graphqlTagReturn || !script) {
    return fileContent;
  }
  const overloaded_returns = {};
  for (const doc of docs) {
    const return_value = graphqlTagReturn({
      config,
      document: doc,
      ensureImport({ identifier, module: module2 }) {
        ensureImports({
          config,
          body: script.body,
          sourceModule: module2,
          import: [identifier]
        });
      }
    });
    if (return_value) {
      overloaded_returns[doc.originalString] = return_value;
    }
  }
  if (Object.keys(overloaded_returns).length > 0) {
    for (const [i2, expression] of script.body.entries()) {
      if (expression.type !== "ExportNamedDeclaration" || expression.declaration?.type !== "TSDeclareFunction" || expression.declaration.id?.name !== "graphql") {
        continue;
      }
      for (const [queryString, returnValue] of Object.entries(overloaded_returns)) {
        const input = AST6.identifier("str");
        input.typeAnnotation = AST6.tsTypeAnnotation(
          AST6.tsLiteralType(AST6.stringLiteral(queryString))
        );
        script.body.splice(
          i2,
          0,
          AST6.exportNamedDeclaration(
            AST6.tsDeclareFunction(
              AST6.identifier("graphql"),
              [input],
              AST6.tsTypeAnnotation(AST6.tsTypeReference(AST6.identifier(returnValue)))
            )
          )
        );
      }
      break;
    }
    const { code } = await printJS(script, { reuseWhitespace: false });
    await fs_exports.writeFile(indexPath, code);
  }
}

// src/codegen/generators/runtime/injectPlugins.ts
async function injectPlugins({
  config,
  content,
  importStatement,
  exportStatement
}) {
  const clientPlugins = config.plugins.filter((plugin2) => plugin2.clientPlugins).reduce((acc, plugin2) => {
    let plugins = plugin2.clientPlugins;
    if (typeof plugins === "function") {
      plugins = plugins(config, config.pluginConfig(plugin2.name));
    }
    return [...acc, ...Object.entries(plugins)];
  }, []);
  return clientPlugins.length > 0 ? `
${clientPlugins.map((plugin2, i2) => importStatement(plugin2[0], `plugin${i2}`)).join("\n")}

const plugins = [
	${clientPlugins.map((plugin2, i2) => {
    const suffix = `(${JSON.stringify(plugin2[1])})`;
    return `plugin${i2}${suffix}`;
  }).join(",\n")}
]

${exportStatement("plugins")}
				` : content;
}

// src/codegen/generators/runtime/pluginIndex.ts
async function generatePluginIndex({
  config,
  exportStatement
}) {
  const indexFile = `${exportStatement("../runtime/client/plugins/index.js")}
`;
  const typedefs = `export * from '../runtime/client/plugins'`;
  await fs_exports.mkdirp(config.pluginRootDirectory);
  await Promise.all([
    fs_exports.writeFile(path_exports.join(config.pluginRootDirectory, "index.js"), indexFile),
    fs_exports.writeFile(path_exports.join(config.pluginRootDirectory, "index.d.ts"), typedefs)
  ]);
}

// src/codegen/generators/runtime/pluginRuntime.ts
async function generatePluginRuntimes({
  config,
  docs
}) {
  if (houdini_mode.is_testing) {
    return;
  }
  const { importStatement, exportDefaultStatement, exportStarStatement } = moduleStatments(config);
  await Promise.all(
    config.plugins.filter((plugin2) => plugin2.includeRuntime).map(async (plugin2) => {
      const runtime_path = config.pluginRuntimeSource(plugin2);
      if (!runtime_path) {
        return;
      }
      try {
        await fs_exports.stat(runtime_path);
      } catch {
        throw new HoudiniError({
          message: "Cannot find runtime to generate for " + plugin2.name,
          description: "Maybe it was bundled?"
        });
      }
      const pluginDir = config.pluginRuntimeDirectory(plugin2.name);
      let transformMap = plugin2.transformRuntime ?? {};
      if (transformMap && typeof transformMap === "function") {
        transformMap = transformMap(docs, { config });
      }
      await fs_exports.mkdirp(pluginDir);
      await fs_exports.recursiveCopy(
        runtime_path,
        pluginDir,
        Object.fromEntries(
          Object.entries(transformMap).map(([key, value]) => [
            path_exports.join(runtime_path, key),
            (content) => value({
              config,
              content,
              importStatement,
              exportDefaultStatement,
              exportStarStatement
            })
          ])
        )
      );
    })
  );
}

// src/codegen/generators/runtime/runtimeConfig.ts
async function injectConfig({
  config,
  content,
  importStatement,
  exportStatement
}) {
  const extraConfigs = config.plugins.reduce((acc, plugin2) => {
    if (!plugin2.config) {
      return acc;
    }
    return [...acc, plugin2.config];
  }, []);
  return extraConfigs.length > 0 ? `
${extraConfigs.map((plugin2, i2) => importStatement(plugin2, `plugin${i2}`))}

const plugins = [
	${extraConfigs.map((_3, i2) => `plugin${i2}`).join(",\n")}
]

${exportStatement("plugins")}
				` : content;
}

// src/codegen/generators/runtime/index.ts
async function runtimeGenerator(config, docs) {
  const {
    importStatement,
    exportDefaultStatement: exportStatement,
    exportStarStatement: exportStar
  } = moduleStatments(config);
  await Promise.all([
    fs_exports.recursiveCopy(config.runtimeSource, config.runtimeDirectory, {
      [path_exports.join(config.runtimeSource, "lib", "constants.js")]: (content) => {
        return content.replace("SITE_URL", siteURL);
      },
      [path_exports.join(config.runtimeSource, "imports", "pluginConfig.js")]: (content) => {
        return injectConfig({ config, importStatement, exportStatement, content });
      },
      [path_exports.join(config.runtimeSource, "imports", "config.js")]: (content) => {
        const configFilePath = path_exports.join(config.runtimeDirectory, "imports", "config.js");
        const relativePath = path_exports.relative(path_exports.dirname(configFilePath), config.filepath);
        return `${importStatement(relativePath, "config")}
${exportStatement("config")}
`;
      },
      [path_exports.join(config.runtimeSource, "client", "plugins", "injectedPlugins.js")]: (content) => injectPlugins({ config, content, importStatement, exportStatement })
    }),
    generatePluginRuntimes({
      config,
      docs
    }),
    generatePluginIndex({ config, exportStatement: exportStar })
  ]);
  await generateGraphqlReturnTypes(config, docs);
}
function moduleStatments(config) {
  const importStatement = config.module === "commonjs" ? importDefaultFrom : (where, as) => `import ${as} from '${where}'`;
  const exportDefaultStatement = config.module === "commonjs" ? exportDefault : (as) => `export default ${as}`;
  const exportStarStatement = config.module === "commonjs" ? exportStarFrom : (where) => `export * from '${where}'`;
  return {
    importStatement,
    exportDefaultStatement,
    exportStarStatement
  };
}

// src/codegen/generators/typescript/documentTypes.ts
var recast12 = __toESM(require_main2(), 1);

// src/codegen/generators/typescript/addReferencedInputTypes.ts
var graphql19 = __toESM(require("graphql"), 1);
var recast9 = __toESM(require_main2(), 1);

// src/codegen/generators/typescript/typeReference.ts
var graphql18 = __toESM(require("graphql"), 1);
var recast8 = __toESM(require_main2(), 1);

// src/codegen/generators/typescript/types.ts
var graphql17 = __toESM(require("graphql"), 1);
var recast7 = __toESM(require_main2(), 1);
var AST7 = recast7.types.builders;
function readonlyProperty(prop, enable = true) {
  if (enable) {
    prop.readonly = true;
  }
  return prop;
}
function nullableField(inner, input = false) {
  const members = [inner, AST7.tsNullKeyword()];
  if (input) {
    members.push(AST7.tsUndefinedKeyword());
  }
  return AST7.tsUnionType(members);
}
function scalarPropertyValue(config, filepath, missingScalars, target, body, field) {
  if (config.configFile.features?.componentFields && target.name === config.componentScalar) {
    if (!field) {
      return AST7.tsNeverKeyword();
    }
    const component = config.componentFields[field.parent][field.field];
    const sourcePathRelative = path_exports.relative(
      path_exports.join(config.projectRoot, "src"),
      component.filepath
    );
    let sourcePathParsed = path_exports.parse(sourcePathRelative);
    let sourcePath = path_exports.join(sourcePathParsed.dir, sourcePathParsed.name);
    const localImport = ensureImports({
      config,
      body,
      import: "__component__" + component.fragment,
      sourceModule: path_exports.join(
        path_exports.relative(path_exports.dirname(filepath), config.projectRoot),
        "src",
        sourcePath
      )
    });
    const parameters = AST7.tsTypeReference(AST7.identifier("Parameters"));
    parameters.typeParameters = AST7.tsTypeParameterInstantiation([
      AST7.tsTypeQuery(AST7.identifier(localImport))
    ]);
    const indexed = AST7.tsIndexedAccessType(
      parameters,
      AST7.tsLiteralType(AST7.numericLiteral(0))
    );
    const omit = AST7.tsTypeReference(AST7.identifier("Omit"));
    omit.typeParameters = AST7.tsTypeParameterInstantiation([
      indexed,
      AST7.tsLiteralType(AST7.stringLiteral(component.prop))
    ]);
    const arg = AST7.identifier("props");
    arg.typeAnnotation = AST7.tsTypeAnnotation(omit);
    const returnType = AST7.tsTypeReference(AST7.identifier("ReturnType"));
    returnType.typeParameters = AST7.tsTypeParameterInstantiation([
      AST7.tsTypeQuery(AST7.identifier(localImport))
    ]);
    const fnType = AST7.tsFunctionType([arg]);
    fnType.typeAnnotation = AST7.tsTypeAnnotation(returnType);
    return fnType;
  }
  switch (target.name) {
    case "String": {
      return AST7.tsStringKeyword();
    }
    case "Int": {
      return AST7.tsNumberKeyword();
    }
    case "Float": {
      return AST7.tsNumberKeyword();
    }
    case "Boolean": {
      return AST7.tsBooleanKeyword();
    }
    case "ID": {
      return AST7.tsStringKeyword();
    }
    default: {
      if (graphql17.isNonNullType(target) && "ofType" in target) {
        return scalarPropertyValue(
          config,
          filepath,
          missingScalars,
          target.ofType,
          body,
          field
        );
      }
      if (config.scalars?.[target.name]) {
        return AST7.tsTypeReference(AST7.identifier(config.scalars?.[target.name].type));
      }
      if (target.name !== config.componentScalar) {
        missingScalars.add(target.name);
      }
      return AST7.tsAnyKeyword();
    }
  }
}

// src/codegen/generators/typescript/typeReference.ts
var AST8 = recast8.types.builders;
function tsTypeReference(config, filepath, missingScalars, definition, body) {
  const { type, wrappers } = unwrapType(config, definition.type);
  let result;
  if (graphql18.isScalarType(type)) {
    result = scalarPropertyValue(config, filepath, missingScalars, type, body, null);
  } else if (graphql18.isEnumType(type)) {
    result = enumReference(config, body, type.name);
  } else {
    result = AST8.tsTypeReference(AST8.identifier(type.name));
  }
  for (const toWrap of wrappers) {
    if (toWrap === "NonNull" /* NonNull */) {
      continue;
    } else if (toWrap === "Nullable" /* Nullable */) {
      result = nullableField(result, true);
    } else if (toWrap === "List" /* List */) {
      result = AST8.tsArrayType(AST8.tsParenthesizedType(result));
    }
  }
  return result;
}
function enumReference(config, body, name) {
  ensureImports({
    config,
    body,
    import: ["ValueOf"],
    importKind: "type",
    sourceModule: "$houdini/runtime/lib/types"
  });
  return AST8.tsTypeReference(
    AST8.identifier("ValueOf"),
    AST8.tsTypeParameterInstantiation([AST8.tsTypeQuery(AST8.identifier(name))])
  );
}

// src/codegen/generators/typescript/addReferencedInputTypes.ts
var AST9 = recast9.types.builders;
function addReferencedInputTypes(config, filepath, body, visitedTypes, missingScalars, rootType) {
  const { type } = unwrapType(config, rootType);
  if (graphql19.isScalarType(type)) {
    return;
  }
  if (visitedTypes.has(type.name)) {
    return;
  }
  if (graphql19.isUnionType(type)) {
    throw new HoudiniError({ filepath, message: "Input Unions are not supported yet. Sorry!" });
  }
  visitedTypes.add(type.name);
  if (graphql19.isEnumType(type)) {
    ensureImports({
      config,
      body,
      import: [type.name],
      sourceModule: "$houdini/graphql/enums",
      importKind: "type"
    });
    return;
  }
  const members = [];
  for (const field of Object.values(type.getFields())) {
    addReferencedInputTypes(config, filepath, body, visitedTypes, missingScalars, field.type);
    members.push(
      AST9.tsPropertySignature(
        AST9.identifier(field.name),
        AST9.tsTypeAnnotation(
          tsTypeReference(config, filepath, missingScalars, field, body)
        ),
        graphql19.isNullableType(field.type)
      )
    );
  }
  body.push(AST9.tsTypeAliasDeclaration(AST9.identifier(type.name), AST9.tsTypeLiteral(members)));
}

// src/codegen/generators/typescript/inlineType.ts
var graphql20 = __toESM(require("graphql"), 1);
var recast10 = __toESM(require_main2(), 1);
var AST10 = recast10.types.builders;
var fragmentKey2 = " $fragments";
function inlineType({
  config,
  filepath,
  rootType,
  selections,
  root,
  allowReadonly,
  body,
  visitedTypes,
  missingScalars,
  includeFragments,
  allOptional,
  forceNonNull,
  field
}) {
  const { type, wrappers } = unwrapType(config, rootType);
  let result;
  let forceNullable = false;
  if (graphql20.isScalarType(type)) {
    result = scalarPropertyValue(
      config,
      filepath,
      missingScalars,
      type,
      body,
      field
    );
  } else if (graphql20.isEnumType(type)) {
    ensureImports({
      config,
      body,
      importKind: "type",
      import: ["ValueOf"],
      sourceModule: "$houdini/runtime/lib/types"
    });
    if (!visitedTypes.has(type.name)) {
      ensureImports({
        config,
        body,
        import: [type.name],
        sourceModule: "$houdini/graphql/enums"
      });
      visitedTypes.add(type.name);
    }
    result = enumReference(config, body, type.name);
  } else if (selections) {
    const rootObj = type;
    const inlineFragments = {};
    const selectedFields = [];
    for (const selection of selections) {
      if (selection.kind === "InlineFragment" && selection.typeCondition) {
        const fragmentType = config.schema.getType(selection.typeCondition.name.value);
        if (!graphql20.isInterfaceType(type) && !graphql20.isUnionType(type)) {
          selectedFields.push(...selection.selectionSet.selections);
          continue;
        }
        if (!graphql20.isInterfaceType(fragmentType) && !graphql20.isUnionType(fragmentType)) {
          if (!inlineFragments[fragmentType.name]) {
            inlineFragments[fragmentType.name] = [];
          }
          inlineFragments[fragmentType.name].push(...selection.selectionSet.selections);
          continue;
        }
        const possibleParents = config.schema.getPossibleTypes(type).map((t3) => t3.name);
        const freeSelections = [];
        const typeSpecificSelections = {};
        for (const node of selection.selectionSet.selections) {
          if (node.kind !== "InlineFragment") {
            freeSelections.push(node);
          } else if (node.typeCondition) {
            typeSpecificSelections[node.typeCondition.name.value] = node.selectionSet.selections;
          } else {
            freeSelections.push(...node.selectionSet.selections);
          }
        }
        for (const possibleType of config.schema.getPossibleTypes(fragmentType)) {
          if (!possibleParents.includes(possibleType.name)) {
            continue;
          }
          if (!inlineFragments[possibleType.name]) {
            inlineFragments[possibleType.name] = [];
          }
          inlineFragments[possibleType.name].push(...freeSelections);
          if (typeSpecificSelections[possibleType.name]) {
            inlineFragments[possibleType.name].push(
              ...typeSpecificSelections[possibleType.name]
            );
          }
        }
      } else if (selection.kind === "InlineFragment" && !selection.typeCondition) {
        selectedFields.push(...selection.selectionSet.selections);
      } else {
        selectedFields.push(selection);
      }
    }
    const fields = Object.values(
      selectedFields.filter((field2) => field2.kind === "Field").reduce(
        (sel, field2) => ({
          ...sel,
          [field2.alias?.value ?? field2.name.value]: field2
        }),
        {}
      )
    );
    result = AST10.tsTypeLiteral([
      ...fields.map((selection) => {
        const { field: field2 } = selectionTypeInfo(config.schema, filepath, rootObj, selection);
        const attributeName = selection.alias?.value || selection.name.value;
        const hasRequiredDirective = selection.directives?.some(
          (directive) => directive.name.value === config.requiredDirective
        );
        if (hasRequiredDirective) {
          forceNullable = true;
        }
        let attributeType = inlineType({
          config,
          filepath,
          rootType: field2.type,
          selections: selection.selectionSet?.selections,
          root: false,
          allowReadonly,
          visitedTypes,
          body,
          missingScalars,
          includeFragments,
          allOptional,
          forceNonNull: hasRequiredDirective,
          field: {
            field: attributeName,
            parent: type.name
          }
        });
        const hasIncludeOrSkipDirective = selection.directives && selection.directives.filter(
          (directive) => directive.name.value === "include" || directive.name.value === "skip"
        ).length > 0;
        if (hasIncludeOrSkipDirective) {
          attributeType = AST10.tsUnionType([attributeType, AST10.tsUndefinedKeyword()]);
        }
        const prop = readonlyProperty(
          AST10.tsPropertySignature(
            AST10.identifier(attributeName),
            AST10.tsTypeAnnotation(attributeType)
          ),
          allowReadonly
        );
        if (allOptional) {
          prop.optional = true;
        }
        return prop;
      })
    ]);
    const fragmentSpreads = selections?.filter(({ kind }) => kind === "FragmentSpread");
    if (includeFragments && fragmentSpreads && fragmentSpreads.length) {
      result.members.push(
        readonlyProperty(
          AST10.tsPropertySignature(
            AST10.stringLiteral(fragmentKey2),
            AST10.tsTypeAnnotation(
              AST10.tsTypeLiteral(
                (fragmentSpreads || []).map(
                  (fragmentSpread) => AST10.tsPropertySignature(
                    AST10.identifier(fragmentSpread.name.value),
                    AST10.tsTypeAnnotation(AST10.tsTypeLiteral([]))
                  )
                )
              )
            )
          ),
          allowReadonly
        )
      );
    }
    const inlineFragmentSelections = Object.entries(inlineFragments).flatMap(([typeName, fragment2]) => {
      const fragmentRootType = config.schema.getType(typeName);
      if (!fragmentRootType) {
        return [];
      }
      const fragmentType = inlineType({
        config,
        filepath,
        rootType: fragmentRootType,
        selections: fragment2,
        allowReadonly,
        visitedTypes,
        root,
        body,
        missingScalars,
        includeFragments,
        allOptional,
        field: null
      });
      let objectType = fragmentType;
      if (fragmentType.type === "TSUnionType") {
        for (const inner of fragmentType.types) {
          if (inner.type === "TSTypeLiteral") {
            objectType = inner;
          }
        }
      }
      if (objectType.type === "TSTypeLiteral" && !graphql20.isInterfaceType(fragmentRootType) && !graphql20.isUnionType(fragmentRootType)) {
        const existingTypenameIndex = objectType.members.findIndex(
          (member) => member.type === "TSPropertySignature" && member.key.type === "Identifier" && member.key.name === "__typename"
        );
        if (existingTypenameIndex !== -1) {
          objectType.members.splice(existingTypenameIndex, 1);
        }
        objectType.members.push(
          readonlyProperty(
            AST10.tsPropertySignature(
              AST10.identifier("__typename"),
              AST10.tsTypeAnnotation(AST10.tsLiteralType(AST10.stringLiteral(typeName)))
            ),
            allowReadonly
          )
        );
      }
      function interfaceCoveredTypenames(interfaceType) {
        let { objects, interfaces } = config.schema.getImplementations(interfaceType);
        return [
          ...interfaces.flatMap(interfaceCoveredTypenames),
          ...objects.map((type2) => type2.name)
        ];
      }
      let coveredTypenames;
      if (graphql20.isInterfaceType(fragmentRootType)) {
        coveredTypenames = interfaceCoveredTypenames(fragmentRootType);
      } else if (graphql20.isUnionType(fragmentRootType)) {
        coveredTypenames = fragmentRootType.getTypes().map((type2) => type2.name);
      } else if (graphql20.isObjectType(fragmentRootType)) {
        coveredTypenames = [fragmentRootType.name];
      } else {
        throw Error("unreachable code");
      }
      const hasRequiredField = fragment2.some(
        (sel) => sel.directives?.some(
          (directive) => directive.name.value === config.requiredDirective
        )
      );
      return [
        {
          type: fragmentRootType,
          tsType: fragmentType,
          coveredTypenames,
          hasRequiredField
        }
      ];
    });
    if (Object.keys(inlineFragmentSelections).length > 0) {
      let selectionTypes = Object.entries(inlineFragmentSelections).map(
        ([typeName, { type: type2, tsType }]) => {
          return AST10.tsParenthesizedType(
            AST10.tsIntersectionType(
              [tsType].flatMap((type3) => {
                if (type3.type === "TSUnionType") {
                  return type3.types.filter(
                    (innerType) => innerType.type !== "TSNullKeyword" && innerType.type !== "TSUndefinedKeyword"
                  );
                }
                return type3;
              })
            )
          );
        }
      );
      const parentIsUnionOrInterface = !graphql20.isInterfaceType(type) && !graphql20.isUnionType(type);
      const possibleTypenames = parentIsUnionOrInterface ? [parent.name] : config.schema.getPossibleTypes(type).map((type2) => type2.name);
      const coveredTypenames = new Set(
        Object.values(inlineFragmentSelections).flatMap((sel) => sel.coveredTypenames)
      );
      const areAllTypenamesCovered = possibleTypenames.every(
        (name) => coveredTypenames.has(name)
      );
      let anySelectionHasRequiredField = Object.values(inlineFragmentSelections).some(
        (sel) => sel.hasRequiredField
      );
      if (!areAllTypenamesCovered || anySelectionHasRequiredField) {
        selectionTypes.push(
          AST10.tsParenthesizedType(
            AST10.tsTypeLiteral([
              readonlyProperty(
                AST10.tsPropertySignature(
                  AST10.identifier("__typename"),
                  AST10.tsTypeAnnotation(
                    AST10.tsLiteralType(
                      AST10.stringLiteral("non-exhaustive; don't match this")
                    )
                  )
                ),
                allowReadonly
              )
            ])
          )
        );
      }
      result = AST10.tsIntersectionType([
        result,
        AST10.tsParenthesizedType(AST10.tsUnionType(selectionTypes))
      ]);
    }
  } else {
    throw Error("Could not convert selection to typescript");
  }
  return wrapType2(wrappers, result, root, forceNullable, forceNonNull);
}
function wrapType2(wrappers, result, root, forceNullable, forceNonNull) {
  if (forceNullable && !wrappers.includes("Nullable" /* Nullable */)) {
    wrappers.push("Nullable" /* Nullable */);
  }
  for (const toWrap of wrappers) {
    if (toWrap === "Nullable" /* Nullable */ && !(root && !forceNullable) && !forceNonNull) {
      result = nullableField(result);
    } else if (toWrap === "NonNull" /* NonNull */) {
      continue;
    } else if (toWrap === "List" /* List */) {
      result = AST10.tsArrayType(AST10.tsParenthesizedType(result));
    }
  }
  return result;
}
function selectionTypeInfo(schema, filepath, rootType, selection) {
  const selectionName = selection.name.value;
  let fields = {};
  if (selection.kind === "Field" && selection.name.value === "__typename") {
    return {
      field: {
        name: "__typename",
        type: schema.getType("String"),
        args: []
      },
      type: schema.getType("String")
    };
  } else if (graphql20.isNonNullType(rootType) && "getFields" in rootType.ofType) {
    fields = rootType.ofType.getFields();
  } else {
    fields = rootType.getFields();
  }
  const field = fields[selectionName];
  if (!field) {
    throw new HoudiniError({
      filepath,
      message: `Could not find type information for field ${rootType.toString()}.${selectionName} ${field}`
    });
  }
  const fieldType = graphql20.getNamedType(field.type);
  if (!fieldType) {
    throw new HoudiniError({
      filepath,
      message: `Could not find type information for field ${rootType.toString()}.${selectionName} ${field}`
    });
  }
  const fieldTypeName = fieldType.name;
  const selectionType = schema.getType(fieldTypeName);
  if (!selectionType) {
    throw new HoudiniError({ filepath, message: "Could not find type for " + fieldTypeName });
  }
  return { field, type: selectionType };
}

// src/codegen/generators/typescript/loadingState.ts
var recast11 = __toESM(require_main2(), 1);
var AST11 = recast11.types.builders;
function withLoadingState(args) {
  if (!("enableLoadingState" in args.document.artifact) || !args.document.artifact.enableLoadingState) {
    return args.base;
  }
  return AST11.tsUnionType([
    args.base,
    loadingState({
      parentType: args.document.artifact.rootType,
      config: args.config,
      selection: args.document.artifact.selection,
      body: args.body,
      global: args.document.artifact.enableLoadingState === "global"
    })
  ]);
}
function loadingState(args) {
  const selection = getFieldsForType(args.selection, args.parentType, true);
  ensureImports({
    config: args.config,
    body: args.body,
    import: ["LoadingType"],
    sourceModule: "$houdini/runtime/lib/types"
  });
  const result = AST11.tsTypeLiteral(
    Object.entries(selection).reduce(
      (rest, [attributeName, value]) => {
        if (!value.loading) {
          return rest;
        }
        let keyType = null;
        if (value.loading.kind === "value") {
          keyType = AST11.tsTypeReference(AST11.identifier("LoadingType"));
        }
        if (value.loading.kind === "continue" && value.selection) {
          keyType = loadingState({
            config: args.config,
            selection: value.selection,
            parentType: value.type,
            body: args.body,
            global: args.global
          });
        }
        if (!keyType) {
          return rest;
        }
        if (value.loading.list) {
          for (const _3 of Array.from({ length: value.loading.list.depth })) {
            keyType = AST11.tsArrayType(keyType);
          }
        }
        return [
          ...rest,
          readonlyProperty(
            AST11.tsPropertySignature(
              AST11.identifier(attributeName),
              AST11.tsTypeAnnotation(keyType)
            )
          )
        ];
      },
      []
    )
  );
  if (args.selection.fragments) {
    result.members.push(
      readonlyProperty(
        AST11.tsPropertySignature(
          AST11.stringLiteral(fragmentKey),
          AST11.tsTypeAnnotation(
            AST11.tsTypeLiteral(
              Object.keys(args.selection.fragments).map((name) => {
                return AST11.tsPropertySignature(
                  AST11.identifier(name),
                  AST11.tsTypeAnnotation(AST11.tsTypeLiteral([]))
                );
              })
            )
          )
        )
      )
    );
  }
  return result;
}

// src/codegen/generators/typescript/documentTypes.ts
var AST12 = recast12.types.builders;
async function generateDocumentTypes(config, docs) {
  const typePaths = [];
  const fragmentDefinitions = {};
  for (const document of docs) {
    for (const defn of document.originalParsed.definitions.filter(
      ({ kind }) => kind === "FragmentDefinition"
    )) {
      fragmentDefinitions[defn.name.value] = defn;
    }
  }
  const missingScalars = /* @__PURE__ */ new Set();
  await Promise.all(
    docs.map(async (document) => {
      const {
        originalParsed: originalDocument,
        name,
        filename,
        generateArtifact,
        artifact
      } = document;
      if (!generateArtifact) {
        return;
      }
      const typeDefPath = config.artifactTypePath(originalDocument);
      const program3 = AST12.program([]);
      const visitedTypes = /* @__PURE__ */ new Set();
      let definition = originalDocument.definitions.find(
        (def) => (def.kind === "OperationDefinition" || def.kind === "FragmentDefinition") && def.name?.value === name
      );
      const selections = flattenSelections({
        config,
        filepath: filename,
        selections: definition.selectionSet.selections,
        fragmentDefinitions
      });
      if (definition?.kind === "OperationDefinition") {
        await generateOperationTypeDefs(
          config,
          typeDefPath,
          document,
          program3.body,
          definition,
          selections,
          visitedTypes,
          missingScalars,
          artifact
        );
      } else {
        await generateFragmentTypeDefs(
          config,
          typeDefPath,
          program3.body,
          selections,
          originalDocument.definitions,
          visitedTypes,
          missingScalars,
          document
        );
      }
      program3.body.push(
        AST12.exportNamedDeclaration(
          AST12.tsTypeAliasDeclaration(
            AST12.identifier(`${name}$artifact`),
            convertToTs(serializeValue(artifact))
          )
        )
      );
      const { code } = await printJS(program3);
      await fs_exports.writeFile(typeDefPath, code);
      typePaths.push(typeDefPath);
    })
  );
  const typeIndex = AST12.program(
    typePaths.sort((a2, b2) => a2.localeCompare(b2)).map((typePath) => {
      return AST12.exportAllDeclaration(
        AST12.literal(
          "./" + path_exports.relative(path_exports.resolve(config.typeIndexPath, ".."), typePath).replace(/\.[^/.]+\.[^/.]+$/, "")
        ),
        null
      );
    }).concat([
      AST12.exportAllDeclaration(AST12.literal("./runtime"), null),
      AST12.exportAllDeclaration(AST12.literal("./graphql"), null)
    ])
  );
  const exportDefaultAs = ({ module: module2, as }) => `
export { default as ${as} } from "${module2}"
`;
  const exportStarFrom2 = ({ module: module2 }) => `
export * from "${module2}"
`;
  let { code: indexContent } = await printJS(typeIndex);
  for (const plugin2 of config.plugins) {
    if (plugin2.indexFile) {
      indexContent = plugin2.indexFile({
        config,
        content: indexContent,
        exportDefaultAs,
        exportStarFrom: exportStarFrom2,
        pluginRoot: config.pluginDirectory(plugin2.name),
        typedef: true,
        documents: docs
      });
    }
    if (plugin2.includeRuntime) {
      indexContent += exportStarFrom2({
        module: "./" + path_exports.relative(config.rootDir, config.pluginRuntimeDirectory(plugin2.name))
      });
    }
  }
  await fs_exports.writeFile(config.typeIndexPath, indexContent);
  if (missingScalars.size > 0) {
    console.warn(`\u26A0\uFE0F  Missing definitions for the following scalars: ${[...missingScalars].join(
      ", "
    )}
Generated types will contain an any type in place of these values. To fix this, provide an equivalent
type in your config file:

{
  scalars: {
    ${cyan2(`/* in your case, something like */`)}
${[...missingScalars].map(
      (c2) => `    ${c2}: {                  ${green2(`// <- The GraphQL Scalar`)}
      type: "${cyan2(`YourType_${c2}`)}"  ${green2(`// <-  The TypeScript type`)}
    }`
    ).join(
      `,
`
    )}
  }
}

For more information, please visit this link: ${siteURL}/api/config#custom-scalars`);
  }
}
function convertToTs(source) {
  if (source.type === "ObjectExpression") {
    return AST12.tsTypeLiteral(
      source.properties.reduce(
        (props, prop) => {
          if (prop.type !== "ObjectProperty" || prop.key.type !== "StringLiteral" && prop.key.type === "Identifier") {
            return props;
          }
          return [
            ...props,
            AST12.tsPropertySignature(
              prop.key,
              AST12.tsTypeAnnotation(convertToTs(prop.value))
            )
          ];
        },
        []
      )
    );
  }
  if (source.type === "ArrayExpression") {
    return AST12.tsTupleType(
      source.elements.map((element) => convertToTs(element))
    );
  }
  if (source.type === "Literal" && typeof source.value === "boolean") {
    return AST12.tsLiteralType(AST12.booleanLiteral(source.value));
  }
  if (source.type === "Literal" && typeof source.value === "number") {
    return AST12.tsLiteralType(AST12.numericLiteral(source.value));
  }
  if (source.type === "Literal" && typeof source.value === "string") {
    return AST12.tsLiteralType(AST12.stringLiteral(source.value));
  }
  return AST12.tsLiteralType(source);
}
async function generateOperationTypeDefs(config, filepath, document, body, definition, selections, visitedTypes, missingScalars, artifact) {
  let parentType = null;
  if (definition.operation === "query") {
    parentType = config.schema.getQueryType();
  } else if (definition.operation === "mutation") {
    parentType = config.schema.getMutationType();
  } else if (definition.operation === "subscription") {
    parentType = config.schema.getSubscriptionType();
  }
  if (!parentType) {
    throw new HoudiniError({ filepath, message: "Could not find root type for document" });
  }
  const inputTypeName = `${definition.name.value}$input`;
  const shapeTypeName = `${definition.name.value}$result`;
  const optimisticTypeName = `${definition.name.value}$optimistic`;
  const hasInputs = definition.variableDefinitions && definition.variableDefinitions.length > 0;
  let resultType = inlineType({
    config,
    filepath,
    rootType: parentType,
    selections,
    root: true,
    allowReadonly: true,
    visitedTypes,
    body,
    missingScalars,
    includeFragments: true,
    field: null
  });
  if (artifact.kind === "HoudiniQuery") {
    resultType = withLoadingState({
      body,
      base: resultType,
      config,
      document
    });
  }
  body.push(
    AST12.exportNamedDeclaration(
      AST12.tsTypeAliasDeclaration(
        AST12.identifier(definition.name.value),
        AST12.tsTypeLiteral([
          readonlyProperty(
            AST12.tsPropertySignature(
              AST12.stringLiteral("input"),
              AST12.tsTypeAnnotation(AST12.tsTypeReference(AST12.identifier(inputTypeName)))
            )
          ),
          readonlyProperty(
            AST12.tsPropertySignature(
              AST12.stringLiteral("result"),
              AST12.tsTypeAnnotation(
                definition.operation === "mutation" ? AST12.tsTypeReference(AST12.identifier(shapeTypeName)) : AST12.tsUnionType([
                  AST12.tsTypeReference(AST12.identifier(shapeTypeName)),
                  AST12.tsUndefinedKeyword()
                ])
              )
            )
          )
        ])
      )
    ),
    AST12.exportNamedDeclaration(
      AST12.tsTypeAliasDeclaration(AST12.identifier(shapeTypeName), resultType)
    )
  );
  if (hasInputs && definition.variableDefinitions && definition.variableDefinitions.length > 0) {
    for (const variableDefinition of definition.variableDefinitions) {
      addReferencedInputTypes(
        config,
        filepath,
        body,
        visitedTypes,
        missingScalars,
        variableDefinition.type
      );
    }
    body.push(
      AST12.exportNamedDeclaration(
        AST12.tsTypeAliasDeclaration(
          AST12.identifier(inputTypeName),
          AST12.tsTypeLiteral(
            (definition.variableDefinitions || []).map(
              (definition2) => {
                return AST12.tsPropertySignature(
                  AST12.identifier(definition2.variable.name.value),
                  AST12.tsTypeAnnotation(
                    tsTypeReference(
                      config,
                      filepath,
                      missingScalars,
                      definition2,
                      body
                    )
                  ),
                  definition2.type.kind !== "NonNullType"
                );
              }
            )
          )
        )
      )
    );
  } else {
    body.push(
      AST12.exportNamedDeclaration(
        AST12.tsTypeAliasDeclaration(AST12.identifier(inputTypeName), AST12.tsNullKeyword())
      )
    );
  }
  if (definition.operation === "mutation") {
    body.push(
      AST12.exportNamedDeclaration(
        AST12.tsTypeAliasDeclaration(
          AST12.identifier(optimisticTypeName),
          inlineType({
            config,
            filepath,
            rootType: parentType,
            selections,
            root: true,
            allowReadonly: true,
            visitedTypes,
            body,
            missingScalars,
            includeFragments: false,
            allOptional: true,
            field: null
          })
        )
      )
    );
  }
}
async function generateFragmentTypeDefs(config, filepath, body, selections, definitions, visitedTypes, missingScalars, document) {
  for (const definition of definitions) {
    if (definition.kind !== "FragmentDefinition") {
      continue;
    }
    const propTypeName = definition.name.value;
    const shapeTypeName = `${definition.name.value}$data`;
    const inputTypeName = `${definition.name.value}$input`;
    const type = config.schema.getType(definition.typeCondition.name.value);
    if (!type) {
      throw new Error("Should not get here");
    }
    let directive = definition.directives?.find(
      (directive2) => directive2.name.value === config.argumentsDirective
    );
    let inputValue = !directive ? AST12.tsTypeLiteral([]) : AST12.tsTypeLiteral(
      (fragmentArgumentsDefinitions(config, filepath, definition) || []).map(
        (definition2) => {
          return AST12.tsPropertySignature(
            AST12.identifier(definition2.variable.name.value),
            AST12.tsTypeAnnotation(
              tsTypeReference(
                config,
                filepath,
                missingScalars,
                definition2,
                body
              )
            ),
            definition2.type.kind !== "NonNullType"
          );
        }
      )
    );
    body.push(
      AST12.exportNamedDeclaration(
        AST12.tsTypeAliasDeclaration(AST12.identifier(inputTypeName), inputValue)
      ),
      AST12.exportNamedDeclaration(
        AST12.tsTypeAliasDeclaration(
          AST12.identifier(propTypeName),
          AST12.tsTypeLiteral([
            readonlyProperty(
              AST12.tsPropertySignature(
                AST12.stringLiteral("shape"),
                AST12.tsTypeAnnotation(
                  AST12.tsTypeReference(AST12.identifier(shapeTypeName))
                ),
                true
              )
            ),
            readonlyProperty(
              AST12.tsPropertySignature(
                AST12.stringLiteral(fragmentKey2),
                AST12.tsTypeAnnotation(
                  AST12.tsTypeLiteral([
                    AST12.tsPropertySignature(
                      AST12.stringLiteral(propTypeName),
                      AST12.tsTypeAnnotation(AST12.tsAnyKeyword())
                    )
                  ])
                )
              )
            )
          ])
        )
      ),
      AST12.exportNamedDeclaration(
        AST12.tsTypeAliasDeclaration(
          AST12.identifier(shapeTypeName),
          withLoadingState({
            config,
            document,
            body,
            base: inlineType({
              config,
              filepath,
              rootType: type,
              selections,
              root: true,
              allowReadonly: true,
              body,
              visitedTypes,
              missingScalars,
              includeFragments: true,
              field: null
            })
          })
        )
      )
    );
  }
}

// src/codegen/generators/typescript/imperativeTypeDef.ts
var graphql21 = __toESM(require("graphql"), 1);
var recast13 = __toESM(require_main2(), 1);
var AST13 = recast13.types.builders;
async function imperativeCacheTypef(config, docs) {
  const returnType = (doc) => config.plugins.find((plugin2) => plugin2.graphqlTagReturn)?.graphqlTagReturn?.({
    config,
    document: doc,
    ensureImport({ identifier, module: module2 }) {
      ensureImports({
        config,
        body,
        sourceModule: module2,
        import: [identifier]
      });
    }
  }) ?? "any";
  const target = path_exports.join(config.runtimeDirectory, "generated.d.ts");
  const body = [];
  const declaration = AST13.tsTypeAliasDeclaration(
    AST13.identifier(CacheTypeDefName),
    AST13.tsTypeLiteral([
      AST13.tsPropertySignature(
        AST13.identifier("types"),
        AST13.tsTypeAnnotation(typeDefinitions(config, target, body, docs, returnType))
      ),
      AST13.tsPropertySignature(
        AST13.identifier("lists"),
        AST13.tsTypeAnnotation(listDefinitions(config, target, body, docs))
      ),
      AST13.tsPropertySignature(
        AST13.identifier("queries"),
        AST13.tsTypeAnnotation(queryDefinitions(config, body, docs, returnType))
      )
    ])
  );
  declaration.declare = true;
  const importRecord = AST13.importDeclaration(
    [AST13.importSpecifier(AST13.identifier("Record"))],
    AST13.stringLiteral("./public/record")
  );
  importRecord.importKind = "type";
  await fs_exports.writeFile(
    target,
    recast13.prettyPrint(
      AST13.program([importRecord, ...body, AST13.exportNamedDeclaration(declaration)])
    ).code
  );
}
function typeDefinitions(config, filepath, body, docs, returnType) {
  const operationTypes = [config.schema.getMutationType(), config.schema.getSubscriptionType()].filter(Boolean).map((type) => type?.name);
  const visitedTypes = /* @__PURE__ */ new Set();
  const types17 = Object.values(config.schema.getTypeMap()).filter(
    (type) => !graphql21.isAbstractType(type) && !graphql21.isScalarType(type) && !graphql21.isEnumType(type) && !graphql21.isInputObjectType(type) && !type.name.startsWith("__") && !operationTypes.includes(type.name)
  );
  const fragmentMap = fragmentListMap(
    config,
    types17.map((type) => type.name),
    body,
    docs,
    returnType
  );
  return AST13.tsTypeLiteral(
    types17.map((type) => {
      let typeName = type.name;
      if (config.schema.getQueryType() && config.schema.getQueryType()?.name === type.name) {
        typeName = "__ROOT__";
      }
      let idFields = AST13.tsNeverKeyword();
      const keys2 = keyFieldsForType(config.configFile, type.name);
      if (graphql21.isObjectType(type) && keys2.length > 0 && keys2.every((key) => type.getFields()[key])) {
        idFields = AST13.tsTypeLiteral(
          keys2.map((key) => {
            const fieldType = type.getFields()[key];
            const unwrapped = unwrapType(config, fieldType.type);
            return AST13.tsPropertySignature(
              AST13.identifier(key),
              AST13.tsTypeAnnotation(
                scalarPropertyValue(
                  config,
                  filepath,
                  /* @__PURE__ */ new Set(),
                  unwrapped.type,
                  body,
                  {
                    field: key,
                    parent: type.name
                  }
                )
              )
            );
          })
        );
      } else if (typeName === "__ROOT__") {
        idFields = AST13.tsTypeLiteral([]);
      }
      let fields = AST13.tsTypeLiteral([]);
      if (graphql21.isObjectType(type)) {
        fields = AST13.tsTypeLiteral(
          Object.entries(type.getFields()).map(
            ([key, fieldType]) => {
              const unwrapped = unwrapType(config, fieldType.type);
              let typeOptions = AST13.tsUnionType([]);
              if (graphql21.isScalarType(unwrapped.type)) {
                typeOptions.types.push(
                  scalarPropertyValue(
                    config,
                    filepath,
                    /* @__PURE__ */ new Set(),
                    unwrapped.type,
                    body,
                    {
                      field: key,
                      parent: type.name
                    }
                  )
                );
              } else if (graphql21.isEnumType(unwrapped.type)) {
                typeOptions.types.push(
                  AST13.tsTypeReference(AST13.identifier(unwrapped.type.name))
                );
              } else if (!graphql21.isAbstractType(unwrapped.type)) {
                typeOptions.types.push(record(unwrapped.type.name));
              } else {
                typeOptions.types.push(
                  ...config.schema.getPossibleTypes(unwrapped.type).map((type2) => record(type2.name))
                );
              }
              for (const wrapper of unwrapped.wrappers) {
                if (wrapper === "Nullable" /* Nullable */) {
                  typeOptions = AST13.tsParenthesizedType(
                    AST13.tsUnionType([typeOptions, AST13.tsNullKeyword()])
                  );
                } else if (wrapper === "List" /* List */) {
                  typeOptions = AST13.tsArrayType(
                    AST13.tsParenthesizedType(typeOptions)
                  );
                }
              }
              if (typeOptions.type === "TSParenthesizedType") {
                typeOptions = typeOptions.typeAnnotation;
              }
              let args = AST13.tsNeverKeyword();
              if (fieldType.args?.length > 0) {
                args = AST13.tsTypeLiteral(
                  fieldType.args.map((arg) => {
                    addReferencedInputTypes(
                      config,
                      "",
                      body,
                      visitedTypes,
                      /* @__PURE__ */ new Set(),
                      arg.type
                    );
                    const prop = AST13.tsPropertySignature(
                      AST13.identifier(arg.name),
                      AST13.tsTypeAnnotation(
                        tsTypeReference(
                          config,
                          filepath,
                          /* @__PURE__ */ new Set(),
                          arg,
                          body
                        )
                      )
                    );
                    const unwrapped2 = unwrapType(config, arg.type);
                    prop.optional = unwrapped2.wrappers[unwrapped2.wrappers.length - 1] === "Nullable" /* Nullable */;
                    return prop;
                  })
                );
              }
              return AST13.tsPropertySignature(
                AST13.identifier(key),
                AST13.tsTypeAnnotation(
                  AST13.tsTypeLiteral([
                    AST13.tsPropertySignature(
                      AST13.identifier("type"),
                      AST13.tsTypeAnnotation(typeOptions)
                    ),
                    AST13.tsPropertySignature(
                      AST13.identifier("args"),
                      AST13.tsTypeAnnotation(args)
                    )
                  ])
                )
              );
            }
          )
        );
      }
      return AST13.tsPropertySignature(
        AST13.identifier(typeName),
        AST13.tsTypeAnnotation(
          AST13.tsTypeLiteral([
            AST13.tsPropertySignature(
              AST13.identifier("idFields"),
              AST13.tsTypeAnnotation(idFields)
            ),
            AST13.tsPropertySignature(
              AST13.identifier("fields"),
              AST13.tsTypeAnnotation(fields)
            ),
            AST13.tsPropertySignature(
              AST13.identifier("fragments"),
              AST13.tsTypeAnnotation(fragmentMap[typeName] ?? AST13.tsTupleType([]))
            )
          ])
        )
      );
    })
  );
}
function listDefinitions(config, filepath, body, docs) {
  const lists = [];
  const visitedLists = /* @__PURE__ */ new Set();
  for (const doc of docs) {
    graphql21.visit(doc.document, {
      Directive(node, key, parent2, path3, ancestors) {
        if (![config.listDirective, config.paginateDirective].includes(node.name.value)) {
          return;
        }
        const nameArg = node.arguments?.find(
          (arg) => arg.name.value === config.listOrPaginateNameArg
        );
        const nameValue = nameArg?.value?.value || "";
        if (!nameValue || visitedLists.has(nameValue)) {
          return;
        }
        visitedLists.add(nameValue);
        const parentType = parentTypeFromAncestors(
          config.schema,
          doc.filename,
          ancestors.slice(0, -1)
        );
        const targetField = ancestors[ancestors.length - 1];
        const targetFieldDefinition = parentType.getFields()[targetField.name.value];
        const { type: listType } = unwrapType(config, targetFieldDefinition.type);
        const possibleTypes = [];
        if (graphql21.isAbstractType(listType)) {
          possibleTypes.push(
            ...config.schema.getPossibleTypes(listType).map((possible) => possible.name)
          );
        } else {
          possibleTypes.push(listType.name);
        }
        lists.push(
          AST13.tsPropertySignature(
            AST13.identifier(nameValue),
            AST13.tsTypeAnnotation(
              AST13.tsTypeLiteral([
                AST13.tsPropertySignature(
                  AST13.identifier("types"),
                  AST13.tsTypeAnnotation(
                    AST13.tsUnionType(
                      possibleTypes.map(
                        (possible) => AST13.tsLiteralType(AST13.stringLiteral(possible))
                      )
                    )
                  )
                ),
                AST13.tsPropertySignature(
                  AST13.identifier("filters"),
                  AST13.tsTypeAnnotation(
                    targetFieldDefinition.args.length === 0 ? AST13.tsNeverKeyword() : AST13.tsTypeLiteral(
                      targetFieldDefinition.args.map((arg) => {
                        const argDef = AST13.tsPropertySignature(
                          AST13.identifier(arg.name),
                          AST13.tsTypeAnnotation(
                            tsTypeReference(
                              config,
                              filepath,
                              /* @__PURE__ */ new Set(),
                              arg,
                              body
                            )
                          )
                        );
                        argDef.optional = true;
                        return argDef;
                      })
                    )
                  )
                )
              ])
            )
          )
        );
      }
    });
  }
  return AST13.tsTypeLiteral(lists);
}
function queryDefinitions(config, body, docs, returnType) {
  return AST13.tsTupleType(
    docs.reduce((prev, doc) => {
      if (doc.kind !== ArtifactKind.Query || !doc.generateStore) {
        return prev;
      }
      const definition = doc.document.definitions.find(
        (def) => def.kind === "OperationDefinition" && def.operation === "query"
      );
      if (!definition) {
        return prev;
      }
      const runtimeType = returnType(doc);
      const [shapeType, inputType] = ensureImports({
        config,
        body,
        sourceModule: path_exports.relative(
          config.runtimeDirectory,
          config.artifactImportPath(doc.name)
        ),
        import: [`${doc.name}$result`, `${doc.name}$input`]
      });
      return prev.concat(
        AST13.tsTupleType([
          AST13.tsTypeReference(AST13.identifier(runtimeType)),
          AST13.tsTypeReference(AST13.identifier(shapeType)),
          AST13.tsTypeReference(AST13.identifier(inputType))
        ])
      );
    }, [])
  );
}
function fragmentListMap(config, concreteTypes, body, docs, return_type) {
  return docs.reduce((prev, doc) => {
    if (doc.kind !== ArtifactKind.Fragment) {
      return prev;
    }
    const definition = doc.document.definitions.find(
      (def) => def.kind === "FragmentDefinition" && def.name.value === doc.name
    );
    if (!definition || !concreteTypes.includes(definition.typeCondition.name.value)) {
      return prev;
    }
    const typeName = definition.typeCondition.name.value;
    const previousValue = prev[typeName]?.elementTypes ?? [];
    const tagResult = return_type(doc);
    const [shapeType] = ensureImports({
      config,
      body,
      sourceModule: path_exports.relative(
        config.runtimeDirectory,
        config.artifactImportPath(doc.name)
      ),
      import: [`${definition.name.value}$data`]
    });
    let inputType = AST13.tsNeverKeyword();
    let directive = definition.directives?.find(
      (directive2) => directive2.name.value === config.argumentsDirective
    );
    if (directive) {
      inputType = AST13.tsTypeReference(
        AST13.identifier(
          ensureImports({
            config,
            body,
            sourceModule: path_exports.relative(
              config.runtimeDirectory,
              config.artifactImportPath(doc.name)
            ),
            import: [`${definition.name.value}$input`]
          })[0]
        )
      );
    }
    return {
      ...prev,
      [typeName]: AST13.tsTupleType(
        previousValue.concat(
          AST13.tsTupleType([
            AST13.tsTypeReference(AST13.identifier(tagResult)),
            AST13.tsTypeReference(AST13.identifier(shapeType)),
            inputType
          ])
        )
      )
    };
  }, {});
}
var CacheTypeDefName = "CacheTypeDef";
function record(name) {
  return AST13.tsTypeReference(
    AST13.identifier("Record"),
    AST13.tsTypeParameterInstantiation([
      AST13.tsTypeReference(AST13.identifier(CacheTypeDefName)),
      AST13.tsLiteralType(AST13.stringLiteral(name))
    ])
  );
}

// src/codegen/generators/typescript/index.ts
async function typescriptGenerator(config, docs) {
  await Promise.all([
    generateDocumentTypes(config, docs),
    imperativeCacheTypef(config, docs)
  ]);
}

// src/codegen/generators/persistedQueries/index.ts
var graphql22 = __toESM(require("graphql"), 1);
async function persistOutputGenerator(config, docs) {
  if (!config.persistedQueriesPath.endsWith(".json")) {
    throw new Error('Can write Persisted Queries only in a ".json" file.');
  }
  const queryMap = docs.reduce((acc, doc) => {
    const { document, generateArtifact, artifact } = doc;
    if (!generateArtifact) {
      return acc;
    }
    let rawString = graphql22.print(
      graphql22.visit(document, {
        Directive(node) {
          if (config.isInternalDirective(node.name.value)) {
            return null;
          }
        }
      })
    );
    const operations = document.definitions.filter(
      ({ kind }) => kind === graphql22.Kind.OPERATION_DEFINITION
    );
    if (operations.length > 0 && operations[0].kind === "OperationDefinition") {
      if (artifact) {
        acc[artifact.hash] = rawString;
      }
    }
    return acc;
  }, {});
  if (Object.keys(queryMap).length === 0)
    return;
  await fs_exports.writeFile(config.persistedQueriesPath, JSON.stringify(queryMap, null, 4));
}

// src/codegen/generators/definitions/index.ts
var graphql24 = __toESM(require("graphql"), 1);

// src/codegen/generators/definitions/enums.ts
var graphql23 = __toESM(require("graphql"), 1);
var recast14 = __toESM(require_main2(), 1);
var AST14 = recast14.types.builders;
async function definitionsGenerator(config) {
  const enums = graphql23.parse(graphql23.printSchema(config.schema)).definitions.filter(
    (definition) => definition.kind === "EnumTypeDefinition"
  ).filter((def) => !config.isInternalEnum(def));
  const { code: runtimeDefinitions } = await printJS(
    AST14.program(
      enums.map((defn) => {
        const name = defn.name.value;
        return moduleExport(
          config,
          name,
          AST14.objectExpression(
            defn.values?.map((value) => {
              const str = value.name.value;
              return AST14.objectProperty(
                AST14.stringLiteral(str),
                AST14.stringLiteral(str)
              );
            }) || []
          )
        );
      })
    )
  );
  const typeDefinitions2 = `
type ValuesOf<T> = T[keyof T]
	` + enums.sort((a2, b2) => a2.name.value.localeCompare(b2.name.value)).map((definition) => {
    const name = definition.name.value;
    const values = definition.values;
    return `
export declare const ${name}: {
${values?.map((value) => `    readonly ${value.name.value}: "${value.name.value}";`).join("\n")}
}

export type ${name}$options = ValuesOf<typeof ${name}>
 `;
  }).join("");
  const definitionsIndex = `
export * from './enums.js'
	`;
  await Promise.all([
    fs_exports.writeFile(config.enumTypesDefinitionsPath, typeDefinitions2),
    fs_exports.writeFile(config.enumRuntimeDefinitionsPath, runtimeDefinitions),
    fs_exports.writeFile(path_exports.join(config.definitionsDirectory, "index.js"), definitionsIndex),
    fs_exports.writeFile(path_exports.join(config.definitionsDirectory, "index.d.ts"), definitionsIndex)
  ]);
}

// src/codegen/generators/definitions/index.ts
async function schemaGenerator(config) {
  await Promise.all([
    fs_exports.writeFile(
      config.definitionsSchemaPath,
      config.localSchema ? graphql24.printSchema(config.schema) : config.newSchema
    ),
    fs_exports.writeFile(config.definitionsDocumentsPath, config.newDocuments),
    definitionsGenerator(config)
  ]);
}

// src/codegen/generators/indexFile/index.ts
async function writeIndexFile2(config, docs) {
  const relative2 = (target) => "./" + path_exports.relative(config.rootDir, target);
  const runtimeDir = relative2(config.runtimeDirectory);
  const artifactDir = relative2(config.artifactDirectory);
  const definitionsDir = relative2(config.definitionsDirectory);
  const cjs = config.module === "commonjs";
  let body = cjs ? cjsIndexFilePreamble : "";
  const exportStar = ({ module: module2 }) => "\n" + (cjs ? exportStarFrom(module2) : `export * from "${module2}"`) + "\n";
  const exportDefaultAs = ({ module: module2, as }) => "\n" + (cjs ? exportDefaultFrom(module2, as) : `export { default as ${as} } from "${module2}"`) + "\n";
  body += [
    exportStar({ module: "./" + path_exports.join(runtimeDir, "client") }),
    exportStar({ module: runtimeDir }),
    exportStar({ module: artifactDir }),
    exportStar({ module: definitionsDir })
  ].join("");
  for (const plugin2 of config.plugins) {
    if (plugin2.indexFile) {
      body = plugin2.indexFile({
        config,
        content: body,
        exportDefaultAs,
        exportStarFrom: exportStar,
        pluginRoot: config.pluginDirectory(plugin2.name),
        typedef: false,
        documents: docs
      });
    }
    if (plugin2.includeRuntime) {
      body += exportStar({
        module: relative2(config.pluginRuntimeDirectory(plugin2.name))
      });
    }
  }
  await fs_exports.writeFile(path_exports.join(config.rootDir, "index.js"), body);
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/helpers.js
var import_graphql32 = require("graphql");
function compareStrings2(a2, b2) {
  if (String(a2) < String(b2)) {
    return -1;
  }
  if (String(a2) > String(b2)) {
    return 1;
  }
  return 0;
}
function nodeToString2(a2) {
  let name;
  if ("alias" in a2) {
    name = a2.alias?.value;
  }
  if (name == null && "name" in a2) {
    name = a2.name?.value;
  }
  if (name == null) {
    name = a2.kind;
  }
  return name;
}
function compareNodes2(a2, b2, customFn) {
  const aStr = nodeToString2(a2);
  const bStr = nodeToString2(b2);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings2(aStr, bStr);
}
function isSome2(input) {
  return input != null;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/inspect.js
var import_graphql33 = require("graphql");
var MAX_RECURSIVE_DEPTH2 = 3;
function inspect2(value) {
  return formatValue2(value, []);
}
function formatValue2(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value, seenValues);
    default:
      return String(value);
  }
}
function formatError2(value) {
  if (value instanceof import_graphql33.GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue2(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable2(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray2(value, seenValues);
  }
  return formatObject2(value, seenValues);
}
function isJSONable2(value) {
  return typeof value.toJSON === "function";
}
function formatObject2(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray2(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue2(array[i2], seenValues));
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag2(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions2(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node?.extensions);
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
var import_graphql37 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/astFromType.js
var import_graphql34 = require("graphql");
function astFromType2(type) {
  if ((0, import_graphql34.isNonNullType)(type)) {
    const innerType = astFromType2(type.ofType);
    if (innerType.kind === import_graphql34.Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect2(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: import_graphql34.Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if ((0, import_graphql34.isListType)(type)) {
    return {
      kind: import_graphql34.Kind.LIST_TYPE,
      type: astFromType2(type.ofType)
    };
  }
  return {
    kind: import_graphql34.Kind.NAMED_TYPE,
    name: {
      kind: import_graphql34.Kind.NAME,
      value: type.name
    }
  };
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/astFromValue.js
var import_graphql36 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
var import_graphql35 = require("graphql");
function astFromValueUntyped2(value) {
  if (value === null) {
    return { kind: import_graphql35.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped2(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: import_graphql35.Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped2(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: import_graphql35.Kind.OBJECT_FIELD,
          name: { kind: import_graphql35.Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: import_graphql35.Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: import_graphql35.Kind.BOOLEAN, value };
  }
  if (typeof value === "bigint") {
    return { kind: import_graphql35.Kind.INT, value: String(value) };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp2.test(stringNum) ? { kind: import_graphql35.Kind.INT, value: stringNum } : { kind: import_graphql35.Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: import_graphql35.Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/astFromValue.js
function astFromValue2(value, type) {
  if ((0, import_graphql36.isNonNullType)(type)) {
    const astValue = astFromValue2(value, type.ofType);
    if (astValue?.kind === import_graphql36.Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return { kind: import_graphql36.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if ((0, import_graphql36.isListType)(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue2(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: import_graphql36.Kind.LIST, values: valuesNodes };
    }
    return astFromValue2(value, itemType);
  }
  if ((0, import_graphql36.isInputObjectType)(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue2(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: import_graphql36.Kind.OBJECT_FIELD,
          name: { kind: import_graphql36.Kind.NAME, value: field.name },
          value: fieldValue
        });
      }
    }
    return { kind: import_graphql36.Kind.OBJECT, fields: fieldNodes };
  }
  if ((0, import_graphql36.isLeafType)(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if ((0, import_graphql36.isEnumType)(type)) {
      return { kind: import_graphql36.Kind.ENUM, value: serialized };
    }
    if (type.name === "ID" && typeof serialized === "string" && integerStringRegExp3.test(serialized)) {
      return { kind: import_graphql36.Kind.INT, value: serialized };
    }
    return astFromValueUntyped2(serialized);
  }
  console.assert(false, "Unexpected input type: " + inspect2(type));
}
var integerStringRegExp3 = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/memoize.js
function memoize12(fn) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/rootTypes.js
var getRootTypeNames3 = memoize12(function getRootTypeNames4(schema) {
  const rootTypes = getRootTypes3(schema);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes3 = memoize12(function getRootTypes4(schema) {
  const rootTypeMap = getRootTypeMap3(schema);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap3 = memoize12(function getRootTypeMap4(schema) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
function getDocumentNodeFromSchema2(schema, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema.getTypeMap();
  const schemaNode = astFromSchema2(schema, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema.getDirectives();
  for (const directive of directives) {
    if ((0, import_graphql37.isSpecifiedDirective)(directive)) {
      continue;
    }
    definitions.push(astFromDirective2(directive, schema, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = (0, import_graphql37.isSpecifiedScalarType)(type);
    const isIntrospection = (0, import_graphql37.isIntrospectionType)(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if ((0, import_graphql37.isObjectType)(type)) {
      definitions.push(astFromObjectType2(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql37.isInterfaceType)(type)) {
      definitions.push(astFromInterfaceType2(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql37.isUnionType)(type)) {
      definitions.push(astFromUnionType2(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql37.isInputObjectType)(type)) {
      definitions.push(astFromInputObjectType2(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql37.isEnumType)(type)) {
      definitions.push(astFromEnumType2(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql37.isScalarType)(type)) {
      definitions.push(astFromScalarType2(type, schema, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: import_graphql37.Kind.DOCUMENT,
    definitions
  };
}
function astFromSchema2(schema, pathToDirectivesInExtensions) {
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema.astNode != null) {
    nodes.push(schema.astNode);
  }
  if (schema.extensionASTNodes != null) {
    for (const extensionASTNode of schema.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap3(schema);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType2(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: import_graphql37.Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome2);
  const directives = getDirectiveNodes2(schema, schema, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? import_graphql37.Kind.SCHEMA_DEFINITION : import_graphql37.Kind.SCHEMA_EXTENSION,
    operationTypes,
    directives
  };
  schemaNode.description = schema.astNode?.description ?? schema.description != null ? {
    kind: import_graphql37.Kind.STRING,
    value: schema.description,
    block: true
  } : void 0;
  return schemaNode;
}
function astFromDirective2(directive, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.DIRECTIVE_DEFINITION,
    description: directive.astNode?.description ?? (directive.description ? {
      kind: import_graphql37.Kind.STRING,
      value: directive.description
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: directive.name
    },
    arguments: directive.args?.map((arg) => astFromArg2(arg, schema, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: directive.locations?.map((location) => ({
      kind: import_graphql37.Kind.NAME,
      value: location
    })) || []
  };
}
function getDirectiveNodes2(entity, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions2(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes2(schema, directivesInExtensions);
  } else {
    directives = [];
    for (const node of nodes) {
      if (node.directives) {
        directives.push(...node.directives);
      }
    }
  }
  return directives;
}
function getDeprecatableDirectiveNodes2(entity, schema, pathToDirectivesInExtensions) {
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions2(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes2(schema, directivesInExtensions);
  } else {
    directives = entity.astNode?.directives;
  }
  if (directives != null) {
    directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = directives.filter((directive) => directive.name.value === "deprecated")?.[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective2(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
function astFromArg2(arg, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.INPUT_VALUE_DEFINITION,
    description: arg.astNode?.description ?? (arg.description ? {
      kind: import_graphql37.Kind.STRING,
      value: arg.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: arg.name
    },
    type: astFromType2(arg.type),
    defaultValue: arg.defaultValue !== void 0 ? astFromValue2(arg.defaultValue, arg.type) ?? void 0 : void 0,
    directives: getDeprecatableDirectiveNodes2(arg, schema, pathToDirectivesInExtensions)
  };
}
function astFromObjectType2(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.OBJECT_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql37.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField2(field, schema, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType2(iFace)),
    directives: getDirectiveNodes2(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType2(type, schema, pathToDirectivesInExtensions) {
  const node = {
    kind: import_graphql37.Kind.INTERFACE_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql37.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField2(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes2(type, schema, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType2(iFace));
  }
  return node;
}
function astFromUnionType2(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.UNION_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql37.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: type.name
    },
    directives: getDirectiveNodes2(type, schema, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType2(type2))
  };
}
function astFromInputObjectType2(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql37.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField2(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes2(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromEnumType2(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.ENUM_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql37.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue2(value, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes2(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromScalarType2(type, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions2(type, pathToDirectivesInExtensions);
  const directives = directivesInExtensions ? makeDirectiveNodes2(schema, directivesInExtensions) : type.astNode?.directives || [];
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode2("specifiedBy", specifiedByArgs));
  }
  return {
    kind: import_graphql37.Kind.SCALAR_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql37.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: type.name
    },
    directives
  };
}
function astFromField2(field, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.FIELD_DEFINITION,
    description: field.astNode?.description ?? (field.description ? {
      kind: import_graphql37.Kind.STRING,
      value: field.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg2(arg, schema, pathToDirectivesInExtensions)),
    type: astFromType2(field.type),
    directives: getDeprecatableDirectiveNodes2(field, schema, pathToDirectivesInExtensions)
  };
}
function astFromInputField2(field, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.INPUT_VALUE_DEFINITION,
    description: field.astNode?.description ?? (field.description ? {
      kind: import_graphql37.Kind.STRING,
      value: field.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: field.name
    },
    type: astFromType2(field.type),
    directives: getDeprecatableDirectiveNodes2(field, schema, pathToDirectivesInExtensions),
    defaultValue: astFromValue2(field.defaultValue, field.type) ?? void 0
  };
}
function astFromEnumValue2(value, schema, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql37.Kind.ENUM_VALUE_DEFINITION,
    description: value.astNode?.description ?? (value.description ? {
      kind: import_graphql37.Kind.STRING,
      value: value.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql37.Kind.NAME,
      value: value.name
    },
    directives: getDeprecatableDirectiveNodes2(value, schema, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective2(deprecationReason) {
  return makeDirectiveNode2("deprecated", { reason: deprecationReason }, import_graphql37.GraphQLDeprecatedDirective);
}
function makeDirectiveNode2(name, args, directive) {
  const directiveArguments = [];
  if (directive != null) {
    for (const arg of directive.args) {
      const argName = arg.name;
      const argValue = args[argName];
      if (argValue !== void 0) {
        const value = astFromValue2(argValue, arg.type);
        if (value) {
          directiveArguments.push({
            kind: import_graphql37.Kind.ARGUMENT,
            name: {
              kind: import_graphql37.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
  } else {
    for (const argName in args) {
      const argValue = args[argName];
      const value = astFromValueUntyped2(argValue);
      if (value) {
        directiveArguments.push({
          kind: import_graphql37.Kind.ARGUMENT,
          name: {
            kind: import_graphql37.Kind.NAME,
            value: argName
          },
          value
        });
      }
    }
  }
  return {
    kind: import_graphql37.Kind.DIRECTIVE,
    name: {
      kind: import_graphql37.Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes2(schema, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive = schema?.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode2(directiveName, value, directive));
      }
    } else {
      directiveNodes.push(makeDirectiveNode2(directiveName, arrayOrSingleValue, directive));
    }
  }
  return directiveNodes;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/comments.js
var import_graphql38 = require("graphql");
var MAX_LINE_LENGTH2 = 80;
var commentsRegistry2 = {};
function resetComments2() {
  commentsRegistry2 = {};
}
function collectComment2(node) {
  const entityName = node.name?.value;
  if (entityName == null) {
    return;
  }
  pushComment2(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment2(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment2(field, entityName, field.name.value);
          if (isFieldDefinitionNode2(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment2(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment2(node, entity, field, argument) {
  const comment = getComment2(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys2 = [entity];
  if (field) {
    keys2.push(field);
    if (argument) {
      keys2.push(argument);
    }
  }
  const path3 = keys2.join(".");
  if (!commentsRegistry2[path3]) {
    commentsRegistry2[path3] = [];
  }
  commentsRegistry2[path3].push(comment);
}
function printComment2(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
function join3(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x3) => x3).join(separator || "") : "";
}
function hasMultilineItems2(maybeArray) {
  return maybeArray?.some((str) => str.includes("\n")) ?? false;
}
function addDescription2(cb) {
  return (node, _key, _parent, path3, ancestors) => {
    const keys2 = [];
    const parent2 = path3.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys2.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys2, parent2?.name?.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry2[key]) {
      items.push(...commentsRegistry2[key]);
    }
    return join3([...items.map(printComment2), node.description, cb(node, _key, _parent, path3, ancestors)], "\n");
  };
}
function indent2(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block2(array) {
  return array && array.length !== 0 ? `{
${indent2(join3(array, "\n"))}
}` : "";
}
function wrap2(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function printBlockString2(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent2(escaped)}
"""`;
}
var printDocASTReducer2 = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join3(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap2("(", join3(node.variableDefinitions, ", "), ")");
      const prefix = join3([node.operation, join3([node.name, varDefs]), join3(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join3(directives, " "))
  },
  SelectionSet: { leave: ({ selections }) => block2(selections) },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap2("", alias, ": ") + name;
      let argsLine = prefix + wrap2("(", join3(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH2) {
        argsLine = prefix + wrap2("(\n", indent2(join3(args, "\n")), "\n)");
      }
      return join3([argsLine, join3(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value }) => name + ": " + value },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap2(" ", join3(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join3(["...", wrap2("on ", typeCondition), join3(directives, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap2("(", join3(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join3(directives, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString2(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values }) => "[" + join3(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join3(fields, ", ") + "}" },
  ObjectField: { leave: ({ name, value }) => name + ": " + value },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join3(args, ", "), ")")
  },
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type }) => "[" + type + "]" },
  NonNullType: { leave: ({ type }) => type + "!" },
  SchemaDefinition: {
    leave: ({ directives, operationTypes }) => join3(["schema", join3(directives, " "), block2(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives }) => join3(["scalar", name, join3(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join3([
      "type",
      name,
      wrap2("implements ", join3(interfaces, " & ")),
      join3(directives, " "),
      block2(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join3(args, "\n")), "\n)") : wrap2("(", join3(args, ", "), ")")) + ": " + type + wrap2(" ", join3(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type, defaultValue, directives }) => join3([name + ": " + type, wrap2("= ", defaultValue), join3(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join3([
      "interface",
      name,
      wrap2("implements ", join3(interfaces, " & ")),
      join3(directives, " "),
      block2(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives, types: types17 }) => join3(["union", name, join3(directives, " "), wrap2("= ", join3(types17, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives, values }) => join3(["enum", name, join3(directives, " "), block2(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives }) => join3([name, join3(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives, fields }) => join3(["input", name, join3(directives, " "), block2(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join3(args, "\n")), "\n)") : wrap2("(", join3(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join3(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join3(["extend schema", join3(directives, " "), block2(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join3(["extend scalar", name, join3(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join3([
      "extend type",
      name,
      wrap2("implements ", join3(interfaces, " & ")),
      join3(directives, " "),
      block2(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join3([
      "extend interface",
      name,
      wrap2("implements ", join3(interfaces, " & ")),
      join3(directives, " "),
      block2(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types: types17 }) => join3(["extend union", name, join3(directives, " "), wrap2("= ", join3(types17, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join3(["extend enum", name, join3(directives, " "), block2(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join3(["extend input", name, join3(directives, " "), block2(fields)], " ")
  }
};
var printDocASTReducerWithComments2 = Object.keys(printDocASTReducer2).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription2(printDocASTReducer2[key].leave)
  }
}), {});
function printWithComments2(ast) {
  return (0, import_graphql38.visit)(ast, printDocASTReducerWithComments2);
}
function isFieldDefinitionNode2(node) {
  return node.kind === "FieldDefinition";
}
function getComment2(node) {
  const rawValue = getLeadingCommentBlock2(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue2(`
${rawValue}`);
  }
}
function getLeadingCommentBlock2(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === import_graphql38.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue2(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation2(lines);
  if (commonIndent !== 0) {
    for (let i2 = 1; i2 < lines.length; i2++) {
      lines[i2] = lines[i2].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank2(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank2(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation2(lines) {
  let commonIndent = null;
  for (let i2 = 1; i2 < lines.length; i2++) {
    const line = lines[i2];
    const indent3 = leadingWhitespace2(line);
    if (indent3 === line.length) {
      continue;
    }
    if (commonIndent === null || indent3 < commonIndent) {
      commonIndent = indent3;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace2(str) {
  let i2 = 0;
  while (i2 < str.length && (str[i2] === " " || str[i2] === "	")) {
    i2++;
  }
  return i2;
}
function isBlank2(str) {
  return leadingWhitespace2(str) === str.length;
}

// ../../node_modules/.pnpm/@graphql-tools+utils@10.0.6_graphql@15.5.0/node_modules/@graphql-tools/utils/esm/isDocumentNode.js
var import_graphql39 = require("graphql");
function isDocumentNode2(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === import_graphql39.Kind.DOCUMENT;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
function mergeArguments3(args1, args2, config) {
  const result = deduplicateArguments2([...args2, ...args1].filter(isSome2), config);
  if (config && config.sort) {
    result.sort(compareNodes2);
  }
  return result;
}
function deduplicateArguments2(args, config) {
  return args.reduce((acc, current) => {
    const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
    if (dupIndex === -1) {
      return acc.concat([current]);
    } else if (!config?.reverseArguments) {
      acc[dupIndex] = current;
    }
    return acc;
  }, []);
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
var import_graphql40 = require("graphql");
function directiveAlreadyExists2(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
}
function isRepeatableDirective(directive, directives) {
  return !!directives?.[directive.name.value]?.repeatable;
}
function nameAlreadyExists2(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
}
function mergeArguments4(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a3) => a3.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists2(source, target, (targetVal, source2) => {
          const value = targetVal.value;
          return !value || !source2.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
}
function deduplicateDirectives2(directives, definitions) {
  return directives.map((directive, i2, all) => {
    const firstAt = all.findIndex((d3) => d3.name.value === directive.name.value);
    if (firstAt !== i2 && !isRepeatableDirective(directive, definitions)) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments4(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome2);
}
function mergeDirectives2(d1 = [], d22 = [], config, directives) {
  const reverseOrder = config && config.reverseDirectives;
  const asNext = reverseOrder ? d1 : d22;
  const asFirst = reverseOrder ? d22 : d1;
  const result = deduplicateDirectives2([...asNext], directives);
  for (const directive of asFirst) {
    if (directiveAlreadyExists2(result, directive) && !isRepeatableDirective(directive, directives)) {
      const existingDirectiveIndex = result.findIndex((d3) => d3.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments4(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
function validateInputs2(node, existingNode) {
  const printedNode = (0, import_graphql40.print)({
    ...node,
    description: void 0
  });
  const printedExistingNode = (0, import_graphql40.print)({
    ...existingNode,
    description: void 0
  });
  const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
  const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
  if (!sameArguments) {
    throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
  }
}
function mergeDirective2(node, existingNode) {
  if (existingNode) {
    validateInputs2(node, existingNode);
    return {
      ...node,
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists2(name, existingNode.locations))
      ]
    };
  }
  return node;
}
function deduplicateLists2(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
function mergeEnumValues2(first, second, config, directives) {
  if (config?.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives2(secondValue.directives, firstValue.directives, directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config && config.sort) {
    result.sort(compareNodes2);
  }
  return result;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
var import_graphql41 = require("graphql");
function mergeEnum2(e1, e22, config, directives) {
  if (e22) {
    return {
      name: e1.name,
      description: e1["description"] || e22["description"],
      kind: config?.convertExtensions || e1.kind === "EnumTypeDefinition" || e22.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives2(e1.directives, e22.directives, config, directives),
      values: mergeEnumValues2(e1.values, e22.values, config)
    };
  }
  return config?.convertExtensions ? {
    ...e1,
    kind: import_graphql41.Kind.ENUM_TYPE_DEFINITION
  } : e1;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
var import_graphql42 = require("graphql");
function isStringTypes2(types17) {
  return typeof types17 === "string";
}
function isSourceTypes2(types17) {
  return types17 instanceof import_graphql42.Source;
}
function extractType2(type) {
  let visitedType = type;
  while (visitedType.kind === import_graphql42.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode2(type) {
  return type.kind !== import_graphql42.Kind.NAMED_TYPE;
}
function isListTypeNode2(type) {
  return type.kind === import_graphql42.Kind.LIST_TYPE;
}
function isNonNullTypeNode2(type) {
  return type.kind === import_graphql42.Kind.NON_NULL_TYPE;
}
function printTypeNode2(type) {
  if (isListTypeNode2(type)) {
    return `[${printTypeNode2(type.type)}]`;
  }
  if (isNonNullTypeNode2(type)) {
    return `${printTypeNode2(type.type)}!`;
  }
  return type.name.value;
}
var CompareVal2;
(function(CompareVal3) {
  CompareVal3[CompareVal3["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal3[CompareVal3["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal3[CompareVal3["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal2 || (CompareVal2 = {}));
function defaultStringComparator2(a2, b2) {
  if (a2 == null && b2 == null) {
    return CompareVal2.A_EQUALS_B;
  }
  if (a2 == null) {
    return CompareVal2.A_SMALLER_THAN_B;
  }
  if (b2 == null) {
    return CompareVal2.A_GREATER_THAN_B;
  }
  if (a2 < b2)
    return CompareVal2.A_SMALLER_THAN_B;
  if (a2 > b2)
    return CompareVal2.A_GREATER_THAN_B;
  return CompareVal2.A_EQUALS_B;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
function fieldAlreadyExists2(fieldsArr, otherField) {
  const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
  return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
}
function mergeFields2(type, f1, f22, config, directives) {
  const result = [];
  if (f22 != null) {
    result.push(...f22);
  }
  if (f1 != null) {
    for (const field of f1) {
      const [existing, existingIndex] = fieldAlreadyExists2(result, field);
      if (existing && !config?.ignoreFieldConflicts) {
        const newField = config?.onFieldTypeConflict && config.onFieldTypeConflict(existing, field, type, config?.throwOnConflict) || preventConflicts2(type, existing, field, config?.throwOnConflict);
        newField.arguments = mergeArguments3(field["arguments"] || [], existing["arguments"] || [], config);
        newField.directives = mergeDirectives2(field.directives, existing.directives, config, directives);
        newField.description = field.description || existing.description;
        result[existingIndex] = newField;
      } else {
        result.push(field);
      }
    }
  }
  if (config && config.sort) {
    result.sort(compareNodes2);
  }
  if (config && config.exclusions) {
    const exclusions = config.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
function preventConflicts2(type, a2, b2, ignoreNullability = false) {
  const aType = printTypeNode2(a2.type);
  const bType = printTypeNode2(b2.type);
  if (aType !== bType) {
    const t1 = extractType2(a2.type);
    const t22 = extractType2(b2.type);
    if (t1.name.value !== t22.name.value) {
      throw new Error(`Field "${b2.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t22.name.value}"`);
    }
    if (!safeChangeForFieldType2(a2.type, b2.type, !ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a2.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  if (isNonNullTypeNode2(b2.type) && !isNonNullTypeNode2(a2.type)) {
    a2.type = b2.type;
  }
  return a2;
}
function safeChangeForFieldType2(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode2(oldType) && !isWrappingTypeNode2(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode2(newType)) {
    const ofType = isNonNullTypeNode2(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType2(ofType, newType.type);
  }
  if (isNonNullTypeNode2(oldType)) {
    return safeChangeForFieldType2(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode2(oldType)) {
    return isListTypeNode2(newType) && safeChangeForFieldType2(oldType.type, newType.type) || isNonNullTypeNode2(newType) && safeChangeForFieldType2(oldType, newType["type"]);
  }
  return false;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
var import_graphql43 = require("graphql");
function mergeInputType2(node, existingNode, config, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields2(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives2(node.directives, existingNode.directives, config, directives)
      };
    } catch (e3) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e3.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql43.Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
var import_graphql44 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
function alreadyExists2(arr, other) {
  return !!arr.find((i2) => i2.name.value === other.name.value);
}
function mergeNamedTypeArray2(first = [], second = [], config = {}) {
  const result = [...second, ...first.filter((d3) => !alreadyExists2(second, d3))];
  if (config && config.sort) {
    result.sort(compareNodes2);
  }
  return result;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
function mergeInterface2(node, existingNode, config, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields2(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives2(node.directives, existingNode.directives, config, directives),
        interfaces: node["interfaces"] ? mergeNamedTypeArray2(node["interfaces"], existingNode["interfaces"], config) : void 0
      };
    } catch (e3) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e3.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql44.Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var import_graphql49 = require("graphql");

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
var import_graphql45 = require("graphql");
function mergeType2(node, existingNode, config, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields2(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives2(node.directives, existingNode.directives, config, directives),
        interfaces: mergeNamedTypeArray2(node.interfaces, existingNode.interfaces, config)
      };
    } catch (e3) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e3.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql45.Kind.OBJECT_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
var import_graphql46 = require("graphql");
function mergeScalar2(node, existingNode, config, directives) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: config?.convertExtensions || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives2(node.directives, existingNode.directives, config, directives)
    };
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql46.Kind.SCALAR_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
var import_graphql47 = require("graphql");
function mergeUnion2(first, second, config, directives) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      directives: mergeDirectives2(first.directives, second.directives, config, directives),
      kind: config?.convertExtensions || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? import_graphql47.Kind.UNION_TYPE_DEFINITION : import_graphql47.Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray2(first.types, second.types, config)
    };
  }
  return config?.convertExtensions ? {
    ...first,
    kind: import_graphql47.Kind.UNION_TYPE_DEFINITION
  } : first;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
var import_graphql48 = require("graphql");
var DEFAULT_OPERATION_TYPE_NAME_MAP2 = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};
function mergeOperationTypes2(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP2) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
function mergeSchemaDefs2(node, existingNode, config, directives) {
  if (existingNode) {
    return {
      kind: node.kind === import_graphql48.Kind.SCHEMA_DEFINITION || existingNode.kind === import_graphql48.Kind.SCHEMA_DEFINITION ? import_graphql48.Kind.SCHEMA_DEFINITION : import_graphql48.Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives2(node.directives, existingNode.directives, config, directives),
      operationTypes: mergeOperationTypes2(node.operationTypes, existingNode.operationTypes)
    };
  }
  return config?.convertExtensions ? {
    ...node,
    kind: import_graphql48.Kind.SCHEMA_DEFINITION
  } : node;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var schemaDefSymbol2 = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode2(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes2(nodes, config, directives = {}) {
  const mergedResultMap = directives;
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode2(nodeDefinition)) {
      const name = nodeDefinition.name?.value;
      if (config?.commentDescriptions) {
        collectComment2(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (config?.exclusions?.includes(name + ".*") || config?.exclusions?.includes(name)) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case import_graphql49.Kind.OBJECT_TYPE_DEFINITION:
          case import_graphql49.Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType2(nodeDefinition, mergedResultMap[name], config, directives);
            break;
          case import_graphql49.Kind.ENUM_TYPE_DEFINITION:
          case import_graphql49.Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum2(nodeDefinition, mergedResultMap[name], config, directives);
            break;
          case import_graphql49.Kind.UNION_TYPE_DEFINITION:
          case import_graphql49.Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion2(nodeDefinition, mergedResultMap[name], config, directives);
            break;
          case import_graphql49.Kind.SCALAR_TYPE_DEFINITION:
          case import_graphql49.Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar2(nodeDefinition, mergedResultMap[name], config, directives);
            break;
          case import_graphql49.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case import_graphql49.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType2(nodeDefinition, mergedResultMap[name], config, directives);
            break;
          case import_graphql49.Kind.INTERFACE_TYPE_DEFINITION:
          case import_graphql49.Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface2(nodeDefinition, mergedResultMap[name], config, directives);
            break;
          case import_graphql49.Kind.DIRECTIVE_DEFINITION:
            mergedResultMap[name] = mergeDirective2(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === import_graphql49.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === import_graphql49.Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol2] = mergeSchemaDefs2(nodeDefinition, mergedResultMap[schemaDefSymbol2], config);
    }
  }
  return mergedResultMap;
}

// ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@15.5.0/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
var import_graphql50 = require("graphql");
function mergeTypeDefs2(typeSource, config) {
  resetComments2();
  const doc = {
    kind: import_graphql50.Kind.DOCUMENT,
    definitions: mergeGraphQLTypes2(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config
    })
  };
  let result;
  if (config?.commentDescriptions) {
    result = printWithComments2(doc);
  } else {
    result = doc;
  }
  resetComments2();
  return result;
}
function visitTypeSources2(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources2(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type of typeSource) {
        visitTypeSources2(type, options, allDirectives, allNodes, visitedTypeSources);
      }
    } else if ((0, import_graphql50.isSchema)(typeSource)) {
      const documentNode = getDocumentNodeFromSchema2(typeSource, options);
      visitTypeSources2(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (isStringTypes2(typeSource) || isSourceTypes2(typeSource)) {
      const documentNode = (0, import_graphql50.parse)(typeSource, options);
      visitTypeSources2(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && (0, import_graphql50.isDefinitionNode)(typeSource)) {
      if (typeSource.kind === import_graphql50.Kind.DIRECTIVE_DEFINITION) {
        allDirectives.push(typeSource);
      } else {
        allNodes.push(typeSource);
      }
    } else if (isDocumentNode2(typeSource)) {
      visitTypeSources2(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return { allDirectives, allNodes };
}
function mergeGraphQLTypes2(typeSource, config) {
  resetComments2();
  const { allDirectives, allNodes } = visitTypeSources2(typeSource, config);
  const mergedDirectives = mergeGraphQLNodes2(allDirectives, config);
  const mergedNodes = mergeGraphQLNodes2(allNodes, config, mergedDirectives);
  if (config?.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol2] || {
      kind: import_graphql50.Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP2) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP2[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: import_graphql50.Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: import_graphql50.Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol2] = schemaDef;
    }
  }
  if (config?.forceSchemaDefinition && !mergedNodes[schemaDefSymbol2]?.operationTypes?.length) {
    mergedNodes[schemaDefSymbol2] = {
      kind: import_graphql50.Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: import_graphql50.Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: import_graphql50.Kind.NAMED_TYPE,
            name: {
              kind: import_graphql50.Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config?.sort) {
    const sortFn = typeof config.sort === "function" ? config.sort : defaultStringComparator2;
    mergedNodeDefinitions.sort((a2, b2) => sortFn(a2.name?.value, b2.name?.value));
  }
  return mergedNodeDefinitions;
}

// src/codegen/transforms/schema.ts
var graphql25 = __toESM(require("graphql"), 1);
async function graphqlExtensions(config, documents) {
  let internalSchema = `
enum CachePolicy {
	${CachePolicy.CacheAndNetwork}
	${CachePolicy.CacheOnly}
	${CachePolicy.CacheOrNetwork}
	${CachePolicy.NetworkOnly}
}

"""
	The ${config.componentScalar} scalar is only defined if the user has any component fields
"""
${Object.keys(config.componentFields).length > 0 ? `scalar ${config.componentScalar}` : ""}

enum PaginateMode {
	${PaginateMode.Infinite}
	${PaginateMode.SinglePage}
}

"""
	@${config.listDirective} is used to mark a field for the runtime as a place to add or remove
	entities in mutations
"""
directive @${config.listDirective}(${config.listOrPaginateNameArg}: String!, connection: Boolean) on FIELD

"""
	@${config.paginateDirective} is used to to mark a field for pagination.
	More info in the [doc](${siteURL}/guides/pagination).
"""
directive @${config.paginateDirective}(${config.listOrPaginateNameArg}: String, ${config.paginateModeArg}: PaginateMode) on FIELD

"""
	@${config.listPrependDirective} is used to tell the runtime to add the result to the end of the list
"""
directive @${config.listPrependDirective} on FRAGMENT_SPREAD

"""
	@${config.listAppendDirective} is used to tell the runtime to add the result to the start of the list
"""
directive @${config.listAppendDirective} on FRAGMENT_SPREAD

"""
	@${config.listAllListsDirective} is used to tell the runtime to add the result to all list
"""
directive @${config.listAllListsDirective} on FRAGMENT_SPREAD

"""
	@${config.listParentDirective} is used to provide a parentID without specifying position or in situations
	where it doesn't make sense (eg when deleting a node.)
"""
directive @${config.listParentDirective}(value: ID!) on FRAGMENT_SPREAD


"""
	@${config.whenDirective} is used to provide a conditional or in situations where it doesn't make sense (eg when removing or deleting a node.)
"""
directive @${config.whenDirective} on FRAGMENT_SPREAD

"""
	@${config.whenNotDirective} is used to provide a conditional or in situations where it doesn't make sense (eg when removing or deleting a node.)
"""
directive @${config.whenNotDirective} on FRAGMENT_SPREAD

"""
	@${config.argumentsDirective} is used to define the arguments of a fragment
"""
directive @${config.argumentsDirective} on FRAGMENT_DEFINITION

"""
	@${config.withDirective} is used to provide arguments to fragments that have been marked with @${config.argumentsDirective}
"""
directive @${config.withDirective} on FRAGMENT_SPREAD

"""
	@${config.cacheDirective} is used to specify cache rules for a query
"""
directive @${config.cacheDirective}(${config.cachePolicyArg}: CachePolicy, ${config.cachePartialArg}: Boolean) on QUERY

"""
	@${config.maskEnableDirective} to enable masking on fragment (overwriting the global conf)
"""
directive @${config.maskEnableDirective} on FRAGMENT_SPREAD

"""
	@${config.maskDisableDirective} to disable masking on fragment (overwriting the global conf)
"""
directive @${config.maskDisableDirective} on FRAGMENT_SPREAD

"""
	@${config.loadingDirective} is used to shape the value of your documents while they are loading
"""
directive @${config.loadingDirective}(count: Int, cascade: Boolean) on QUERY | FRAGMENT_DEFINITION | FIELD | FRAGMENT_SPREAD

"""
	@${config.requiredDirective} makes a nullable field always non-null by making the parent null when the field is
"""
directive @${config.requiredDirective} on FIELD

${config.configFile.features?.componentFields ? `
"""
@${config.componentFieldDirective} marks an inline fragment as the selection for a component field
"""
directive @${config.componentFieldDirective}(field: String!, prop: String, export: String, raw: String) on FRAGMENT_DEFINITION | INLINE_FRAGMENT

` : ""}

`;
  for (const plugin2 of config.plugins) {
    if (!plugin2.schema) {
      continue;
    }
    internalSchema += plugin2.schema({ config });
  }
  const extensions = Object.entries(config.componentFields).map(([parent2, fields]) => {
    return `
		extend type ${parent2} {
			${Object.entries(fields).map(([fieldName, field]) => {
      let argString = "";
      const args = fragmentArguments(config, "", field.parent);
      if (args.length > 0) {
        argString = "(" + args.map((arg) => {
          const typeName = graphql25.print(arg.type);
          return `${arg.name}:${typeName}${arg.required ? "!" : ""}`;
        }).join("\n") + ")";
      }
      return `${fieldName}${argString}: ${config.componentScalar}!`;
    }).join("\n")}
		}
	`;
  }).join("\n");
  config.newSchema = graphql25.print(mergeTypeDefs2([internalSchema, config.newSchema]));
  config.schemaString += extensions;
  config.schema = graphql25.buildSchema(
    graphql25.print(
      mergeTypeDefs2([graphql25.printSchema(config.schema), internalSchema, extensions])
    )
  );
}

// src/codegen/transforms/typename.ts
var graphql26 = __toESM(require("graphql"), 1);
async function addTypename(config, documents) {
  for (const doc of documents) {
    doc.document = graphql26.visit(doc.document, {
      Field(node, key, parent2, path3, ancestors) {
        if (!node.selectionSet) {
          return;
        }
        const type = parentTypeFromAncestors(
          config.schema,
          doc.filename,
          ancestors.slice(0, -1)
        );
        const field = type.getFields()[node.name.value];
        const fieldType = unwrapType(config, field.type).type;
        if (graphql26.isInterfaceType(fieldType) || graphql26.isUnionType(fieldType)) {
          return {
            ...node,
            selectionSet: {
              ...node.selectionSet,
              selections: [
                ...node.selectionSet.selections,
                {
                  kind: graphql26.Kind.FIELD,
                  name: {
                    kind: graphql26.Kind.NAME,
                    value: "__typename"
                  }
                }
              ]
            }
          };
        }
      },
      FragmentDefinition(node) {
        return {
          ...node,
          selectionSet: {
            ...node.selectionSet,
            selections: [
              ...node.selectionSet.selections,
              {
                kind: graphql26.Kind.FIELD,
                name: {
                  kind: graphql26.Kind.NAME,
                  value: "__typename"
                }
              }
            ]
          }
        };
      }
    });
  }
}

// src/codegen/transforms/addID.ts
var graphql27 = __toESM(require("graphql"), 1);
async function addID(config, documents) {
  for (const doc of documents) {
    doc.document = graphql27.visit(doc.document, {
      Field(node, key, parent2, path3, ancestors) {
        if (!node.selectionSet) {
          return;
        }
        const type = parentTypeFromAncestors(
          config.schema,
          doc.filename,
          ancestors.slice(0, -1)
        );
        const field = type.getFields()[node.name.value];
        const fieldType = unwrapType(config, field.type).type;
        return addKeysToSelection(config, node, fieldType);
      },
      InlineFragment(node) {
        if (!node.selectionSet || !node.typeCondition) {
          return;
        }
        const fragmentType = config.schema.getType(node.typeCondition.name.value);
        if (!fragmentType) {
          return;
        }
        return addKeysToSelection(config, node, fragmentType);
      },
      FragmentDefinition(node) {
        const fragmentType = config.schema.getType(node.typeCondition.name.value);
        if (!fragmentType) {
          return;
        }
        return addKeysToSelection(config, node, fragmentType);
      }
    });
  }
}
function addKeysToSelection(config, node, fieldType) {
  if (!node.selectionSet || node.selectionSet.selections.length == 0) {
    return;
  }
  if (!graphql27.isObjectType(fieldType) && !graphql27.isInterfaceType(fieldType)) {
    return;
  }
  const keyFields = config.keyFieldsForType(fieldType.name);
  if (keyFields.find((key) => !fieldType.getFields()[key])) {
    return;
  }
  const selections = [...node.selectionSet.selections];
  for (const keyField of keyFields) {
    if (node.selectionSet.selections.find(
      (selection) => selection.kind === "Field" && !selection.alias && selection.name.value === keyField
    )) {
      continue;
    }
    selections.push({
      kind: graphql27.Kind.FIELD,
      name: {
        kind: graphql27.Kind.NAME,
        value: keyField
      }
    });
  }
  return {
    ...node,
    selectionSet: {
      ...node.selectionSet,
      selections
    }
  };
}

// src/codegen/transforms/componentFields.ts
var graphql28 = __toESM(require("graphql"), 1);
async function componentFields(config, documents) {
  for (const document of documents) {
    const typeInfo = new graphql28.TypeInfo(config.schema);
    document.document = graphql28.visit(
      document.document,
      graphql28.visitWithTypeInfo(typeInfo, {
        Field(node) {
          const parentType = typeInfo.getParentType();
          if (!parentType) {
            return;
          }
          const fieldName = node.name.value;
          const { fragment: fragment2, directive } = config.componentFields[parentType.name]?.[fieldName] ?? {};
          if (!fragment2) {
            return;
          }
          const directives = [...node.directives ?? []];
          directives.push(directive);
          const args = [];
          for (const arg of node.arguments ?? []) {
            args.push({
              kind: "Argument",
              name: {
                kind: "Name",
                value: arg.name.value
              },
              value: arg.value
            });
          }
          if (args.length > 0) {
            directives.push({
              kind: "Directive",
              name: {
                kind: "Name",
                value: config.withDirective
              },
              arguments: args
            });
          }
          return {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: fragment2
            },
            directives
          };
        }
      })
    );
  }
}

// src/codegen/validators/typeCheck.ts
var graphql29 = __toESM(require("graphql"), 1);
async function typeCheck(config, docs) {
  const errors = [];
  const freeLists = [];
  const lists = [];
  const listTypes = [];
  const fragments = {};
  for (const { document: parsed, originalString, filename } of docs) {
    graphql29.visit(parsed, {
      FragmentDefinition(definition) {
        fragments[definition.name.value] = definition;
      },
      Directive(directive, _3, parent2, __, ancestors) {
        if (![config.listDirective, config.paginateDirective].includes(directive.name.value)) {
          return;
        }
        const { parents, definition } = definitionFromAncestors(ancestors);
        let needsParent = false;
        if (definition.kind !== "OperationDefinition" && definition.kind !== "FragmentDefinition" || definition.kind === "OperationDefinition" && definition.operation !== "query") {
          errors.push(
            new Error(
              `@${directive.name.value} can only appear in queries or fragments`
            )
          );
          return;
        }
        let rootType = definition.kind === "OperationDefinition" ? config.schema.getQueryType() : config.schema.getType(definition.typeCondition.name.value);
        if (!rootType) {
          errors.push(
            new HoudiniError({
              filepath: filename,
              message: "Could not find root type"
            })
          );
          return;
        }
        for (const parent3 of parents) {
          if (Array.isArray(parent3) || parent3.kind === "SelectionSet") {
            continue;
          }
          if (parent3.kind === "InlineFragment" && parent3.typeCondition) {
            rootType = config.schema.getType(parent3.typeCondition.name.value);
            continue;
          }
          if (parent3.kind !== "Field") {
            errors.push(
              new HoudiniError({
                filepath: filename,
                message: "Shouldn't get here"
              })
            );
            return;
          }
          if (graphql29.isListType(rootType) || graphql29.isNonNullType(rootType) && graphql29.isListType(rootType.ofType)) {
            needsParent = true;
            break;
          }
          if (graphql29.isNonNullType(rootType) && "ofType" in rootType) {
            rootType = rootType.ofType;
          }
          if (graphql29.isScalarType(rootType)) {
            break;
          }
          rootType = rootType?.getFields()[parent3.name.value]?.type;
        }
        if (directive.name.value === config.paginateDirective) {
          if (needsParent) {
            errors.push(
              new HoudiniError({
                filepath: filename,
                message: `@${config.paginateDirective} cannot be below a list`
              })
            );
          }
        }
        needsParent = needsParent || definition.kind === "FragmentDefinition";
        const nameArg = directive.arguments?.find(
          ({ name }) => name.value === config.listOrPaginateNameArg
        );
        if (!nameArg) {
          if (directive.name.value === config.listDirective) {
            errors.push(
              new HoudiniError({
                filepath: filename,
                message: "Could not find name arg"
              })
            );
          }
          return;
        }
        if (nameArg.value.kind !== "StringValue") {
          errors.push(
            new HoudiniError({
              filepath: filename,
              message: "Name arg must be a static string, it cannot be set to a variable."
            })
          );
          return;
        }
        const listName = nameArg.value.value;
        if (lists.includes(listName)) {
          errors.push(
            new HoudiniError({
              filepath: filename,
              message: "List names must be unique"
            })
          );
          return;
        }
        const pType = parentTypeFromAncestors(
          config.schema,
          filename,
          ancestors.slice(0, -1)
        );
        const targetField = ancestors[ancestors.length - 1];
        const targetFieldDefinition = pType.getFields()[targetField.name.value];
        const { type, error: errorConnectionSelection } = connectionSelection(
          config,
          targetFieldDefinition,
          parentTypeFromAncestors(
            config.schema,
            filename,
            ancestors
          ),
          targetField.selectionSet
        );
        if (errorConnectionSelection && directive.name.value === config.paginateDirective) {
          errors.push(
            new HoudiniError({
              filepath: filename,
              message: errorConnectionSelection,
              description: errorConnectionSelection
            })
          );
        }
        let targetTypes = [type];
        if (graphql29.isUnionType(type)) {
          targetTypes = config.schema.getPossibleTypes(type);
        } else if (graphql29.isInterfaceType(type)) {
          try {
            for (const key of config.keyFieldsForType(type.name)) {
              if (!type.getFields()[key]) {
                throw new Error("continue");
              }
            }
          } catch {
            targetTypes = config.schema.getPossibleTypes(type);
          }
        }
        for (const targetType of targetTypes) {
          const missingIDFields = config.keyFieldsForType(targetType.name).filter((fieldName) => !targetType.getFields()[fieldName]);
          if (missingIDFields.length > 0) {
            errors.push(
              new HoudiniError({
                filepath: filename,
                message: `@${config.listDirective} on ${green2(
                  targetType.name
                )} has a configuration issue: ${targetType} dos not have a valid key. Please check this link for more information: https://houdinigraphql.com/guides/caching-data#custom-ids`
              })
            );
            return;
          }
        }
        lists.push(listName);
        listTypes.push(type.name);
        if (!needsParent) {
          freeLists.push(listName);
        }
      }
    });
  }
  if (errors.length > 0) {
    throw errors;
  }
  const rules = (filepath) => [...graphql29.specifiedRules].filter(
    (rule) => ![
      graphql29.NoUnusedFragmentsRule,
      graphql29.KnownFragmentNamesRule,
      graphql29.ExecutableDefinitionsRule,
      graphql29.KnownDirectivesRule,
      graphql29.KnownArgumentNamesRule
    ].includes(rule)
  ).concat(
    validateLists({
      config,
      freeLists,
      lists,
      listTypes,
      fragments
    }),
    validateRequiredDirective(config, filepath),
    checkMutationOperation(config),
    checkMaskDirectives(config),
    nodeDirectives(config, [config.paginateDirective]),
    knownArguments(config),
    validateFragmentArguments(config, filepath, fragments),
    paginateArgs(config, filepath),
    noUnusedFragmentArguments(config),
    validateLoadingDirective(config)
  );
  for (const { filename, document: parsed, originalString } of docs) {
    for (const error of graphql29.validate(config.schema, parsed, rules(filename))) {
      errors.push(
        new HoudiniError({
          filepath: filename,
          message: error.message
        })
      );
    }
  }
  if (errors.length > 0) {
    throw errors;
  }
  return;
}
function validateRequiredDirective(config, filepath) {
  function isClientNullable(node, ignoreCurrent) {
    const hasRequiredDirective = node.directives?.some(
      ({ name }) => name.value === config.requiredDirective
    );
    return !ignoreCurrent && hasRequiredDirective || node.selectionSet?.selections.some(
      (node2) => node2.kind == "Field" && isClientNullable(node2, false)
    ) == true;
  }
  return function(ctx) {
    return {
      Field(node, _3, __, ___, ancestors) {
        if (!node.directives?.some(({ name }) => name.value === config.requiredDirective))
          return;
        const parentType = parentTypeFromAncestors(config.schema, filepath, ancestors);
        if (!graphql29.isObjectType(parentType)) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `@${config.requiredDirective} may only be used on objects, not arguments`
            )
          );
          return;
        }
        const type = parentType.getFields()[node.name.value].type;
        const isServerNullable = !graphql29.isNonNullType(type);
        const isAlreadyClientNullable = isClientNullable(node, true);
        if (!isServerNullable && !isAlreadyClientNullable) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `@${config.requiredDirective} may only be used on nullable fields`
            )
          );
          return;
        }
      }
    };
  };
}
var validateLists = ({
  config,
  freeLists,
  lists,
  listTypes,
  fragments
}) => function verifyListArtifacts(ctx) {
  return {
    FragmentSpread(node) {
      if (!config.isListFragment(node.name.value)) {
        if (!fragments[node.name.value]) {
          ctx.reportError(
            new graphql29.GraphQLError(
              "Encountered unknown fragment: " + node.name.value
            )
          );
        }
        return;
      }
      const listName = config.listNameFromFragment(node.name.value);
      if (!lists.includes(listName)) {
        ctx.reportError(
          new graphql29.GraphQLError(
            "Encountered fragment referencing unknown list: " + listName
          )
        );
        return;
      }
      if (freeLists.includes(listName)) {
        return;
      }
      let directive = node.directives?.find(
        ({ name }) => name.value === config.listParentDirective
      );
      if (directive) {
        return;
      }
      let parentIdFound = false;
      directive = node.directives?.find(({ name }) => [
        [config.listPrependDirective, config.listAppendDirective].includes(name.value)
      ]);
      if (directive) {
        let parentArg = directive.arguments?.find(
          (arg) => arg.name.value === config.deprecatedlistDirectiveParentIDArg
        );
        if (parentArg) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `@${config.deprecatedlistDirectiveParentIDArg} should be defined only in it's own directive now`
            )
          );
        }
      }
      if (parentIdFound) {
        return;
      }
      const allLists = node.directives?.find(
        ({ name }) => config.listAllListsDirective === name.value
      );
      if (allLists || config.defaultListTarget === "all") {
        return;
      }
      ctx.reportError(
        new graphql29.GraphQLError(
          `For this list fragment, you need to add or @${config.listParentDirective} or @${config.listAllListsDirective} directive to specify the behavior`
        )
      );
      return;
    },
    Directive(node) {
      const directiveName = node.name.value;
      if (directiveName === "connection") {
        ctx.reportError(
          new graphql29.GraphQLError(
            "@connection was renamed to @list. Please change your components. If you were using `cache.connection` in your components, you will need to update that to `cache.list` too."
          )
        );
        return;
      }
      if (!config.isInternalDirective(node.name.value)) {
        if (!config.schema.getDirective(directiveName)) {
          ctx.reportError(
            new graphql29.GraphQLError(
              "Encountered unknown directive: " + directiveName
            )
          );
        }
        return;
      }
      if (config.isListOperationDirective(directiveName) && !listTypes.includes(config.listNameFromDirective(directiveName))) {
        ctx.reportError(
          new graphql29.GraphQLError(
            "Encountered directive referencing unknown list: " + directiveName
          )
        );
        return;
      }
    }
  };
};
function knownArguments(config) {
  return function(ctx) {
    const nativeValidator = graphql29.KnownArgumentNamesRule(ctx);
    return {
      ...nativeValidator,
      Directive(directiveNode) {
        const directiveName = directiveNode.name.value;
        if ([
          config.argumentsDirective,
          config.withDirective,
          config.whenDirective,
          config.whenNotDirective,
          config.listAppendDirective,
          config.listPrependDirective,
          config.blockingDirective,
          config.blockingDisableDirective
        ].includes(directiveName)) {
          return false;
        }
        return nativeValidator.Directive(directiveNode);
      }
    };
  };
}
function validateFragmentArguments(config, filepath, fragments) {
  const requiredArgs = {};
  const fragmentArgumentNames = {};
  const fragmentArguments2 = {};
  return function(ctx) {
    return {
      Directive(node) {
        if (node.name.value !== config.argumentsDirective) {
          return;
        }
        for (const arg of node.arguments || []) {
          if (arg.value.kind !== "ObjectValue") {
            ctx.reportError(
              new graphql29.GraphQLError("values in @arguments must be an object")
            );
            return;
          }
          const typeArg = arg.value.fields.find((field) => field.name.value === "type");
          const defaultValue = arg.value.fields.find(
            (field) => field.name.value === "default"
          );
          if (!typeArg) {
            ctx.reportError(
              new graphql29.GraphQLError("missing type field for @arguments directive")
            );
            return;
          }
          if (typeArg.value.kind !== graphql29.Kind.STRING) {
            ctx.reportError(
              new graphql29.GraphQLError("type field to @arguments must be a string")
            );
            return;
          }
          if (!defaultValue) {
            return;
          }
          const defaultValueType = defaultValue.value.kind.substring(
            0,
            defaultValue.value.kind.length - "Value".length
          );
          if (typeArg.value.value !== defaultValueType) {
            ctx.reportError(
              new graphql29.GraphQLError(
                `Invalid default value provided for ${arg.name.value}. Expected ${typeArg.value.value}, found ${defaultValueType}`
              )
            );
            return;
          }
        }
      },
      FragmentSpread(targetFragment, _3, __, ___, ancestors) {
        if (!fragments[targetFragment.name.value]) {
          return;
        }
        const fragmentName = targetFragment.name.value;
        if (!requiredArgs[fragmentName]) {
          let args;
          try {
            args = fragmentArguments(config, filepath, fragments[fragmentName]);
          } catch (e3) {
            ctx.reportError(new graphql29.GraphQLError(e3.message));
            return;
          }
          fragmentArguments2[fragmentName] = args;
          requiredArgs[fragmentName] = args.filter((arg) => arg && arg.required).map((arg) => arg.name);
          fragmentArgumentNames[fragmentName] = args.map((arg) => arg.name);
        }
        const appliedArguments = withArguments(
          config,
          targetFragment
        ).reduce(
          (map, arg) => ({
            ...map,
            [arg.name.value]: arg
          }),
          {}
        );
        const appliedArgumentNames = Object.keys(appliedArguments);
        const missing = requiredArgs[fragmentName].filter(
          (arg) => !appliedArgumentNames.includes(arg)
        );
        if (missing.length > 0) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `The following arguments are missing from the "${fragmentName}" fragment: ` + JSON.stringify(missing)
            )
          );
          return;
        }
        const unknown = appliedArgumentNames.filter(
          (arg) => !fragmentArgumentNames[fragmentName].includes(arg)
        );
        if (unknown.length > 0) {
          ctx.reportError(
            new graphql29.GraphQLError(
              "Encountered unknown arguments: " + JSON.stringify(unknown)
            )
          );
        } else {
          const zipped = appliedArgumentNames.map((name) => [
            appliedArguments[name],
            fragmentArguments2[fragmentName].find((arg) => arg.name === name).type
          ]);
          for (const [applied, target] of zipped) {
            if (!valueIsType(config, applied.value, target)) {
              ctx.reportError(
                new graphql29.GraphQLError(
                  `Invalid argument type. Expected ${target}, found ${applied.value.kind}`
                )
              );
            }
          }
        }
      }
    };
  };
}
function valueIsType(config, value, targetType) {
  if (value.kind === "NullValue") {
    return targetType.kind !== "NonNullType";
  }
  if (targetType.kind === "NonNullType") {
    targetType = targetType.type;
  }
  if (value.kind === "ListValue") {
    if (targetType.kind !== "ListType") {
      return false;
    }
    const listType = targetType.type;
    return value.values.every((value2) => valueIsType(config, value2, listType));
  }
  if (value.kind === "BooleanValue") {
    return targetType.kind === "NamedType" && targetType.name.value === "Boolean";
  }
  if (value.kind === "StringValue") {
    return targetType.kind === "NamedType" && targetType.name.value === "String";
  }
  if (value.kind === "IntValue") {
    return targetType.kind === "NamedType" && targetType.name.value === "Int";
  }
  if (value.kind === "FloatValue") {
    return targetType.kind === "NamedType" && targetType.name.value === "Float";
  }
  if (value.kind === "ObjectValue" && targetType.kind === "NamedType") {
    return true;
  }
  if (value.kind === "EnumValue" && targetType.kind === "NamedType") {
    const enumType = config.schema.getType(targetType.name.value);
    if (!graphql29.isEnumType(enumType)) {
      return false;
    }
    return enumType.getValues().some((enumValue) => enumValue.value === value.value);
  }
  if (value.kind === "Variable") {
    return true;
  }
  return false;
}
function paginateArgs(config, filepath) {
  return function(ctx) {
    let alreadyPaginated = false;
    return {
      Directive(node, _3, __, ___, ancestors) {
        if (node.name.value !== config.paginateDirective) {
          return;
        }
        if (alreadyPaginated) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `@${config.paginateDirective} can only appear in a document once.`
            )
          );
        }
        alreadyPaginated = true;
        const { definition } = definitionFromAncestors(ancestors);
        const definitionArgs = fragmentArguments(
          config,
          filepath,
          definition
        );
        const hasRequiredArgs = definitionArgs.find((arg) => arg.required);
        if (hasRequiredArgs) {
          ctx.reportError(
            new graphql29.GraphQLError(
              "@paginate cannot appear on a document with required args"
            )
          );
          return;
        }
        const targetFieldType = parentTypeFromAncestors(
          config.schema,
          filepath,
          ancestors.slice(0, -1)
        );
        const targetField = ancestors.slice(-1)[0];
        const type = targetFieldType.getFields()[targetField.name.value];
        if (!type) {
          return;
        }
        const fieldArgs = type.args.reduce(
          (args, arg) => ({
            ...args,
            [arg.name]: unwrapType(config, arg.type).type.name
          }),
          {}
        );
        const forwardPagination = fieldArgs["first"] === "Int" && fieldArgs["after"] === "String";
        const backwardsPagination = fieldArgs["last"] === "Int" && fieldArgs["before"] === "String";
        const cursorPagination = forwardPagination || backwardsPagination;
        const appliedArgs = new Set(targetField.arguments?.map((arg) => arg.name.value));
        if (cursorPagination) {
          const forward = appliedArgs.has("first");
          const backwards = appliedArgs.has("last");
          if (!forward && !backwards) {
            ctx.reportError(
              new graphql29.GraphQLError(
                "A field with cursor-based pagination must have a first or last argument"
              )
            );
          }
          const paginateModeArg = node?.arguments?.find(
            (arg) => arg.name.value === config.paginateModeArg
          );
          let paginateMode = config.defaultPaginateMode;
          if (paginateModeArg && paginateModeArg.value.kind === "EnumValue") {
            paginateMode = paginateModeArg.value.value;
          }
          if (forward && backwards && paginateMode === "Infinite") {
            ctx.reportError(
              new graphql29.GraphQLError(
                `A field with cursor pagination cannot go forwards an backwards simultaneously`
              )
            );
          }
          return;
        }
        const offsetPagination = fieldArgs["offset"] === "Int" && fieldArgs["limit"] === "Int";
        if (offsetPagination) {
          const appliedLimitArg = targetField.arguments?.find(
            (arg) => arg.name.value === "limit"
          );
          if (!appliedLimitArg) {
            ctx.reportError(
              new graphql29.GraphQLError(
                "A field with offset-based pagination must have a limit argument"
              )
            );
          }
          return;
        }
      }
    };
  };
}
function noUnusedFragmentArguments(config) {
  return function(ctx) {
    const args = /* @__PURE__ */ new Set();
    return {
      enter(node) {
        if (node.kind === graphql29.Kind.FRAGMENT_DEFINITION) {
          const definitionArguments = node.directives?.filter((directive) => directive.name.value === config.argumentsDirective).flatMap((directive) => directive.arguments);
          for (const arg of definitionArguments?.map((arg2) => arg2?.name.value) || []) {
            args.add(arg);
          }
        } else if (node.kind === graphql29.Kind.VARIABLE) {
          args.delete(node.name.value);
        }
      },
      leave(node) {
        if (node.kind === graphql29.Kind.FRAGMENT_DEFINITION) {
          if (args.size > 0) {
            ctx.reportError(
              new graphql29.GraphQLError(
                "Encountered unused fragment arguments: " + [...args].join(",")
              )
            );
          }
        }
      }
    };
  };
}
function nodeDirectives(config, directives) {
  const queryType = config.schema.getQueryType();
  let possibleNodes = [queryType?.name || ""];
  const customTypes = Object.keys(config.typeConfig || {});
  const nodeInterface = getAndVerifyNodeInterface(config);
  if (nodeInterface) {
    const { objects, interfaces } = config.schema.getImplementations(nodeInterface);
    possibleNodes.push(
      ...objects.map((object) => object.name),
      ...interfaces.map((object) => object.name)
    );
  }
  if (customTypes.length > 1) {
    possibleNodes.push(...customTypes);
  }
  return function(ctx) {
    return {
      Directive(node, _3, __, ___, ancestors) {
        if (!directives.includes(node.name.value)) {
          return;
        }
        let { definition } = definitionFromAncestors(ancestors);
        let definitionType = "";
        if (definition.kind === "OperationDefinition") {
          if (definition.operation !== "query") {
            ctx.reportError(
              new graphql29.GraphQLError(
                `@${node.name.value} must fall on a fragment or query document`
              )
            );
            return;
          }
          definitionType = config.schema.getQueryType()?.name || "";
        } else if (definition.kind === "FragmentDefinition") {
          definitionType = definition.typeCondition.name.value;
        }
        if (!possibleNodes.includes(definitionType)) {
          ctx.reportError(
            new graphql29.GraphQLError(paginateOnNonNodeMessage(node.name.value))
          );
        }
      }
    };
  };
}
function checkMutationOperation(config) {
  return function(ctx) {
    return {
      FragmentSpread(node, _3, __, ___, ancestors) {
        const append = node.directives?.find(
          (c2) => c2.name.value === config.listAppendDirective
        );
        const prepend = node.directives?.find(
          (c2) => c2.name.value === config.listPrependDirective
        );
        if (append && prepend) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `You can't apply both @${config.listPrependDirective} and @${config.listAppendDirective} at the same time`
            )
          );
          return;
        }
        const parentId = node.directives?.find(
          (c2) => c2.name.value === config.listParentDirective
        );
        const allLists = node.directives?.find(
          (c2) => c2.name.value === config.listAllListsDirective
        );
        if (parentId && allLists) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `You can't apply both @${config.listParentDirective} and @${config.listAllListsDirective} at the same time`
            )
          );
          return;
        }
      }
    };
  };
}
function checkMaskDirectives(config) {
  return function(ctx) {
    return {
      FragmentSpread(node, _3, __, ___, ancestors) {
        const maskEnableDirective = node.directives?.find(
          (c2) => c2.name.value === config.maskEnableDirective
        );
        const maskDisableDirective = node.directives?.find(
          (c2) => c2.name.value === config.maskDisableDirective
        );
        if (maskEnableDirective && maskDisableDirective) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `You can't apply both @${config.maskEnableDirective} and @${config.maskDisableDirective} at the same time`
            )
          );
          return;
        }
      }
    };
  };
}
function validateLoadingDirective(config) {
  return function(ctx) {
    let global2 = false;
    return {
      enter: {
        OperationDefinition(node) {
          if (node.directives?.find((d3) => d3.name.value === config.loadingDirective)) {
            global2 = true;
          }
        },
        FragmentDefinition(node) {
          if (node.directives?.find((d3) => d3.name.value === config.loadingDirective)) {
            global2 = true;
          }
        }
      },
      FragmentSpread(node, _3, __, ___, ancestors) {
        const loadingDirective = node.directives?.find(
          (d3) => d3.name.value === config.loadingDirective
        );
        if (!loadingDirective) {
          return;
        }
        const parent2 = parentField(ancestors);
        if (!parent2 || ["OperationDefinition", "FragmentDefinition"].includes(parent2.kind)) {
          return;
        }
        const parentLoading = parent2.directives?.find(
          (d3) => d3.name.value === config.loadingDirective
        );
        if (!parentLoading && !global2) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `@${config.loadingDirective} can only be applied on a field or fragment spread at the root of a document or on one whose parent also has @${config.loadingDirective}`
            )
          );
        }
      },
      Field(node, _3, __, ___, ancestors) {
        const loadingDirective = node.directives?.find(
          (d3) => d3.name.value === config.loadingDirective
        );
        if (!loadingDirective) {
          return;
        }
        const parent2 = parentField(ancestors);
        if (!parent2 || ["OperationDefinition", "FragmentDefinition"].includes(parent2.kind)) {
          return;
        }
        const parentLoading = parent2.directives?.find(
          (d3) => d3.name.value === config.loadingDirective
        );
        if (!parentLoading && !global2) {
          ctx.reportError(
            new graphql29.GraphQLError(
              `@${config.loadingDirective} can only be applied on a field or fragment spread at the root of a document or on one whose parent also has @${config.loadingDirective}`
            )
          );
        }
      }
    };
  };
}
function getAndVerifyNodeInterface(config) {
  const { schema } = config;
  const nodeInterface = schema.getType("Node");
  if (!nodeInterface) {
    return null;
  }
  if (!graphql29.isInterfaceType(nodeInterface)) {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  const queryType = schema.getQueryType();
  if (!queryType) {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  const nodeField = queryType.getFields()["node"];
  if (!nodeField) {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  const args = nodeField.args;
  if (args.length === 0) {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  const idArg = args.find((arg) => arg.name === config.defaultKeys[0]);
  if (!idArg) {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  const idType = unwrapType(config, idArg.type);
  if (idType.type.name !== "ID") {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  const fieldReturnType = unwrapType(config, nodeField.type);
  if (fieldReturnType.type.name !== "Node") {
    displayInvalidNodeFieldMessage(config);
    return null;
  }
  return nodeInterface;
}
var nbInvalidNodeFieldMessageDisplayed = 0;
function displayInvalidNodeFieldMessage(config) {
  if (nbInvalidNodeFieldMessageDisplayed === 0) {
    if (config.logLevel === LogLevel.Full) {
      console.warn(invalidNodeFieldMessage);
    } else {
      console.warn(invalidNodeFieldMessageLight);
    }
  }
  nbInvalidNodeFieldMessageDisplayed++;
}
var invalidNodeFieldMessageLight = `\u26A0\uFE0F  Your Node interface is not properly defined, please fix your schema to be able to use this interface. (For more info, add flag "-l full")`;
var invalidNodeFieldMessage = `\u26A0\uFE0F  Your project defines a Node interface but it does not conform to the Global Identification Spec.

If you are trying to provide the Node interface and its field, they must look like the following:

interface Node {
  id: ID!
}

extend type Query {
  node(id: ID!): Node
}

For more information, please visit these links:
- https://graphql.org/learn/global-object-identification/
- ${siteURL}/guides/caching-data#custom-ids
`;
var paginateOnNonNodeMessage = (directiveName) => `It looks like you are trying to use @${directiveName} on a document that does not have a valid type resolver.
If this is happening inside of a fragment, make sure that the fragment either implements the Node interface or you
have defined a resolver entry for the fragment type.

For more information, please visit these links:
- ${siteURL}/guides/pagination#paginated-fragments
- ${siteURL}/guides/caching-data#custom-ids
`;

// src/codegen/validators/uniqueNames.ts
async function uniqueDocumentNames(config, docs) {
  const nameMap = docs.reduce(
    (acc, { name, filename }) => ({
      ...acc,
      [name]: [...acc[name] || [], filename]
    }),
    {}
  );
  const errors = Object.entries(nameMap).filter(([_3, filenames]) => filenames.length > 1).map(
    ([docName, fileNames]) => new HoudiniError({
      message: fileNames.join(", "),
      description: `Operation names must be unique. Encountered duplicate definitions of ${docName} in these files:`
    })
  );
  if (errors.length > 0) {
    throw errors;
  }
  return;
}

// src/codegen/validators/noIDAlias.ts
var graphql30 = __toESM(require("graphql"), 1);
async function noIDAlias(config, docs) {
  const errors = [];
  for (const { filename, document } of docs) {
    graphql30.visit(document, {
      Field(node, _3, __, ___, ancestors) {
        const fieldType = parentTypeFromAncestors(config.schema, filename, ancestors).name;
        if (config.keyFieldsForType(fieldType).includes(node.alias?.value || "")) {
          errors.push(
            new HoudiniError({
              filepath: filename,
              message: "Encountered field with an alias that overwrites an id field"
            })
          );
        }
      }
    });
  }
  if (errors.length > 0) {
    throw errors;
  }
  return;
}

// src/codegen/validators/plugins.ts
async function validatePlugins(config, documents) {
  let errors = [];
  for (const plugin2 of config.plugins) {
    if (!plugin2.validate) {
      continue;
    }
    try {
      await plugin2.validate({ config, documents });
    } catch (err) {
      errors.push(err);
    }
  }
  if (errors.length > 0) {
    throw errors.flat();
  }
}

// src/codegen/validators/componentFields.ts
var graphql31 = __toESM(require("graphql"), 1);
async function componentFields2(config, docs) {
  const errors = [];
  for (const { filename: filepath, document } of docs) {
    graphql31.visit(document, {
      FragmentDefinition(node, _3, __, ___, ancestors) {
        const componentFieldDirective = node.directives?.find(
          (dir) => dir.name.value === config.componentFieldDirective
        );
        if (!componentFieldDirective) {
          return;
        }
        if (!config.configFile.features?.componentFields) {
          errors.push({
            filepath,
            message: `\u26A0\uFE0F  You must enable the componentFields feature flag to use the @${config.componentFieldDirective} directive`,
            description: "For more information, visit: https://houdinigraphql.com/api/react#component-fields"
          });
          return;
        }
        const parent2 = node.typeCondition.name.value;
        let fieldArg = null;
        let propArg = null;
        for (const arg of componentFieldDirective.arguments ?? []) {
          if (arg.name.value === "field") {
            fieldArg = arg;
          } else if (arg.name.value === "prop") {
            propArg = arg;
          }
        }
        if (!fieldArg) {
          errors.push({
            message: `Missing field argument on @${config.componentFieldDirective} directive`,
            filepath
          });
          return;
        }
        if (!propArg) {
          errors.push({
            message: `Missing prop argument on @${config.componentFieldDirective} directive`,
            filepath
          });
          return;
        }
        const fieldValue = fieldArg.value?.kind === "StringValue" ? fieldArg.value.value : void 0;
        const propValue = propArg.value?.kind === "StringValue" ? propArg.value.value : void 0;
        const parentType = config.schema.getType(parent2);
        if (parentType && fieldValue && (graphql31.isObjectType(parentType) && parentType.getFields()[fieldValue] || config.componentFields[parent2]?.[fieldValue])) {
          errors.push({
            message: `Duplicate component field definition for ${parent2}.${fieldValue}`,
            filepath
          });
        }
        if (parentType && graphql31.isAbstractType(parentType)) {
          errors.push({
            message: `Cannot add component field ${parent2}.${fieldValue} because ${parent2} is an abstract type`,
            filepath
          });
          return;
        }
        if (fieldValue && propValue) {
          config.componentFields[parent2] = {
            ...config.componentFields[parent2],
            [fieldValue]: {
              directive: componentFieldDirective,
              fragment: node.name.value,
              filepath,
              prop: propValue,
              parent: node
            }
          };
        }
      }
    });
  }
  if (errors.length > 0) {
    throw errors;
  }
  return;
}

// src/codegen/index.ts
async function compile(config) {
  const documents = await collectDocuments(config);
  await runPipeline2(config, documents);
}
async function runPipeline2(config, docs) {
  config.createDirectories();
  config.newSchema = "";
  config.newDocuments = "";
  config.componentFields = {};
  const artifactStats = {
    total: [],
    changed: [],
    new: [],
    deleted: [],
    hashSize: [],
    querySize: []
  };
  const generatePlugins = config.plugins.filter((plugin2) => plugin2.generate);
  const afterValidate = config.plugins.filter((plugin2) => plugin2.afterValidate).map((plugin2) => plugin2.afterValidate);
  const beforeValidate = config.plugins.filter((plugin2) => plugin2.beforeValidate).map((plugin2) => plugin2.beforeValidate);
  const beforeGenerate = config.plugins.filter((plugin2) => plugin2.beforeGenerate).map((plugin2) => plugin2.beforeGenerate);
  const wrapHook = (hooks) => hooks.map(
    (fn) => (config2, docs2) => fn({
      config: config2,
      documents: docs2
    })
  );
  if (!config.pluginMode && process.env.HOUDINI_TEST !== "true") {
    console.log("\u{1F3A9} Generating runtime...");
  }
  let error = null;
  try {
    await runPipeline(
      config,
      [
        componentFields2,
        graphqlExtensions,
        ...wrapHook(beforeValidate),
        typeCheck,
        uniqueDocumentNames,
        noIDAlias,
        validatePlugins,
        ...wrapHook(afterValidate),
        addID,
        addTypename,
        componentFields,
        addListFragments,
        paginate,
        fragmentVariables,
        includeFragmentDefinitions,
        ...wrapHook(beforeGenerate),
        artifactGenerator(artifactStats),
        runtimeGenerator,
        writeIndexFile2,
        typescriptGenerator,
        persistOutputGenerator,
        schemaGenerator,
        ...generatePlugins.map(
          (plugin2) => async (config2, docs2) => await plugin2.generate({
            config: config2,
            documents: docs2,
            pluginRoot: config2.pluginDirectory(plugin2.name)
          })
        )
      ],
      docs
    );
  } catch (e3) {
    error = e3;
  }
  const unchanged = artifactStats.total.length - artifactStats.changed.length - artifactStats.new.length - artifactStats.deleted.length;
  const printMessage = !config.pluginMode || unchanged !== artifactStats.total.length;
  if (!printMessage || config.logLevel === LogLevel.Quiet) {
    if (error) {
      throw error;
    }
    return;
  }
  if (error) {
    throw error;
  }
  if (artifactStats.total.length === 0) {
    console.log(`\u{1F4A1} No operation found. If that's unexpected, please check your config.`);
  } else if (config.logLevel == LogLevel.Summary || config.logLevel == LogLevel.ShortSummary) {
    if (unchanged > 0 && printMessage && !config.pluginMode) {
      console.log(`\u{1F4C3} Unchanged: ${unchanged}`);
    }
    logStyled("CREATED", artifactStats.new, config.logLevel, config.pluginMode);
    logStyled("UPDATED", artifactStats.changed, config.logLevel, config.pluginMode);
    logStyled("DELETED", artifactStats.deleted, config.logLevel, config.pluginMode);
  } else if (config.logLevel === LogLevel.Full) {
    for (const artifact of artifactStats.total) {
      let emoji = "\u{1F4C3}";
      if (artifactStats.changed.includes(artifact)) {
        emoji = "\u270F\uFE0F";
      } else if (artifactStats.new.includes(artifact)) {
        emoji = "\u2728";
      } else if (artifactStats.deleted.includes(artifact)) {
        emoji = "\u{1F9F9}";
      }
      console.log(`${emoji} ${artifact}`);
    }
    console.log(``);
    console.log(`\u{1FA84}  Total: ${artifactStats.total.length}`);
    const format = (val) => {
      return `${(val / 1024).toFixed(1)} kb`;
    };
    const hashSize = format(artifactStats.hashSize.reduce((acc, val) => acc + val, 0));
    const querySize = format(artifactStats.querySize.reduce((acc, val) => acc + val, 0));
    console.log(`\u{1FAB6}  Network request size: ${querySize} (pesisted: ${hashSize})`);
  }
}
async function collectDocuments(config) {
  let sourceFiles = await config.sourceFiles();
  const documents = [];
  const extractors = {
    ".graphql": [],
    ".gql": [],
    ".js": [],
    ".ts": []
  };
  for (const plugin2 of config.plugins) {
    if (plugin2.extensions && plugin2.extractDocuments) {
      for (const extension of plugin2.extensions) {
        extractors[extension] = [...extractors[extension] || [], plugin2.extractDocuments];
      }
    }
  }
  const graphql_extractor = ({
    content
  }) => [content];
  const javascript_extractor = ({
    content
  }) => processJSFile(config, content);
  extractors[".ts"].push(javascript_extractor);
  extractors[".js"].push(javascript_extractor);
  extractors[".graphql"].push(graphql_extractor);
  extractors[".gql"].push(graphql_extractor);
  await Promise.all(
    sourceFiles.map(async (filepath) => {
      const contents = await fs_exports.readFile(filepath);
      if (!contents) {
        return;
      }
      const extension = path_exports.extname(filepath);
      if (!extractors[extension]) {
        throw new HoudiniError({
          filepath,
          message: "Encountered a file extension that could not be processed: " + extension,
          description: "Please verify you are not missing a plugin."
        });
      }
      try {
        for (const extractor of extractors[extension]) {
          if (!extractor) {
            continue;
          }
          const found = await extractor({ config, filepath, content: contents });
          if (found && found.length > 0) {
            documents.push(...found.map((document) => ({ filepath, document })));
          }
        }
      } catch (err) {
        throw {
          message: err.message,
          filepath
        };
      }
    })
  );
  return await Promise.all(
    documents.map(async ({ document, filepath }) => {
      try {
        return await processGraphQLDocument(config, filepath, document);
      } catch (e3) {
        throw new HoudiniError({ filepath, message: e3.message });
      }
    })
  );
}
async function processJSFile(config, contents) {
  const documents = [];
  var script = await parseJS(contents);
  await find_graphql(config, script, {
    tag({ tagContent }) {
      documents.push(tagContent);
    }
  });
  return documents;
}
async function processGraphQLDocument(config, filepath, document) {
  const parsedDoc = graphql32.parse(document);
  const operations = parsedDoc.definitions.filter(
    ({ kind: kind2 }) => kind2 === graphql32.Kind.OPERATION_DEFINITION
  );
  const fragments = parsedDoc.definitions.filter(
    ({ kind: kind2 }) => kind2 === graphql32.Kind.FRAGMENT_DEFINITION
  );
  if (operations.length > 1) {
    throw new HoudiniError({
      filepath,
      message: "Operation documents can only have one operation"
    });
  }
  if (fragments.length > 1) {
    throw new HoudiniError({
      filepath,
      message: "Fragment documents can only have one fragment"
    });
  }
  if (operations.length + fragments.length > 1) {
    throw new HoudiniError({
      filepath,
      message: "Cannot mix operations and fragments in a single document"
    });
  }
  let kind = ArtifactKind.Fragment;
  if (operations.length === 1) {
    if (operations[0].kind === "OperationDefinition" && operations[0].operation === "query") {
      kind = ArtifactKind.Query;
    } else if (operations[0].kind === "OperationDefinition" && operations[0].operation === "mutation") {
      kind = ArtifactKind.Mutation;
    } else if (operations[0].kind === "OperationDefinition" && operations[0].operation === "subscription") {
      kind = ArtifactKind.Subscription;
    }
  }
  return {
    name: config.documentName(parsedDoc),
    kind,
    document: parsedDoc,
    filename: filepath,
    originalParsed: parsedDoc,
    generateArtifact: true,
    generateStore: true,
    originalString: document,
    artifact: null
  };
}
function logStyled(kind, stat3, logLevel, plugin2) {
  if (stat3.length > 0) {
    const msg = [];
    if (plugin2) {
      msg.push(`\u{1F3A9} `);
    }
    if (kind === "CREATED") {
      msg.push(`\u2728 `);
      if (!plugin2) {
        msg.push(`New: ${stat3.length}`);
      }
    } else if (kind === "UPDATED") {
      msg.push(`\u270F\uFE0F  `);
      if (!plugin2) {
        msg.push(`Changed: ${stat3.length}`);
      }
    } else if (kind === "DELETED") {
      msg.push(`\u{1F9F9} `);
      if (!plugin2) {
        msg.push(`Deleted: ${stat3.length}`);
      }
    }
    const nbToDisplay = 5;
    if (plugin2) {
      msg.push(`${stat3.slice(0, nbToDisplay).join(", ")}`);
      if (stat3.length > 5) {
        msg.push(`, ... ${stat3.length - nbToDisplay} more`);
      }
    }
    console.log(msg.join(""));
    if (!plugin2 && logLevel === LogLevel.Summary) {
      for (const artifact of stat3.slice(0, nbToDisplay)) {
        console.log(`    ${artifact}`);
      }
      if (stat3.length > nbToDisplay) {
        console.log(`    ... ${stat3.length - nbToDisplay} more`);
      }
    }
  }
}

// src/cmd/pullSchema.ts
async function pullSchema_default(args) {
  const config = await getConfig({ noSchema: true });
  const apiURL = await config.apiURL();
  if (!apiURL) {
    console.log(
      "\u274C Your project does not have a remote endpoint configured. Please provide one with the `apiUrl` value in your houdini.config.js file."
    );
    process.exit(1);
    return;
  }
  const targetPath = process.cwd();
  let headers = await config.pullHeaders();
  let headerStrings = [];
  if (args.headers) {
    headerStrings = args.headers;
  }
  if (headerStrings.length > 0) {
    headers = headerStrings.reduce((total, header) => {
      const [key, value] = header.split(/=(.*)/s);
      return {
        ...total,
        [key]: value
      };
    }, headers);
  }
  await pullSchema(apiURL, config.schemaPath ?? path_exports.resolve(targetPath, "schema.json"), headers);
}

// src/cmd/generate.ts
async function generate(args = {
  pullSchema: false,
  headers: [],
  verbose: false
}) {
  let config = null;
  const extraConfig = {};
  if (args.log) {
    extraConfig.logLevel = args.log;
  }
  try {
    config = await getConfig(extraConfig);
    if (args.output) {
      config.persistedQueriesPath = args.output;
    }
    if (config.localSchema) {
      config.schema = await loadLocalSchema(config);
    } else if (args.pullSchema && await config.apiURL()) {
      await pullSchema_default(args);
    }
    await compile(config);
  } catch (e3) {
    formatErrors(e3, function(error) {
      if (args.verbose && "stack" in error && error.stack) {
        console.error(error.stack.split("\n").slice(1).join("\n"));
      }
    });
  }
}

// ../../node_modules/.pnpm/@clack+core@0.3.2/node_modules/@clack/core/dist/index.mjs
var import_sisteransi = __toESM(require_src(), 1);
var import_node_process = require("node:process");
var f3 = __toESM(require("node:readline"), 1);
var import_node_readline = __toESM(require("node:readline"), 1);
var import_node_tty = require("node:tty");
var import_picocolors = __toESM(require_picocolors(), 1);
function z({ onlyFirst: t3 = false } = {}) {
  const u2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(u2, t3 ? void 0 : "g");
}
function $(t3) {
  if (typeof t3 != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof t3}\``);
  return t3.replace(z(), "");
}
var m2 = {};
var G2 = { get exports() {
  return m2;
}, set exports(t3) {
  m2 = t3;
} };
(function(t3) {
  var u2 = {};
  t3.exports = u2, u2.eastAsianWidth = function(e3) {
    var s2 = e3.charCodeAt(0), C2 = e3.length == 2 ? e3.charCodeAt(1) : 0, D2 = s2;
    return 55296 <= s2 && s2 <= 56319 && 56320 <= C2 && C2 <= 57343 && (s2 &= 1023, C2 &= 1023, D2 = s2 << 10 | C2, D2 += 65536), D2 == 12288 || 65281 <= D2 && D2 <= 65376 || 65504 <= D2 && D2 <= 65510 ? "F" : D2 == 8361 || 65377 <= D2 && D2 <= 65470 || 65474 <= D2 && D2 <= 65479 || 65482 <= D2 && D2 <= 65487 || 65490 <= D2 && D2 <= 65495 || 65498 <= D2 && D2 <= 65500 || 65512 <= D2 && D2 <= 65518 ? "H" : 4352 <= D2 && D2 <= 4447 || 4515 <= D2 && D2 <= 4519 || 4602 <= D2 && D2 <= 4607 || 9001 <= D2 && D2 <= 9002 || 11904 <= D2 && D2 <= 11929 || 11931 <= D2 && D2 <= 12019 || 12032 <= D2 && D2 <= 12245 || 12272 <= D2 && D2 <= 12283 || 12289 <= D2 && D2 <= 12350 || 12353 <= D2 && D2 <= 12438 || 12441 <= D2 && D2 <= 12543 || 12549 <= D2 && D2 <= 12589 || 12593 <= D2 && D2 <= 12686 || 12688 <= D2 && D2 <= 12730 || 12736 <= D2 && D2 <= 12771 || 12784 <= D2 && D2 <= 12830 || 12832 <= D2 && D2 <= 12871 || 12880 <= D2 && D2 <= 13054 || 13056 <= D2 && D2 <= 19903 || 19968 <= D2 && D2 <= 42124 || 42128 <= D2 && D2 <= 42182 || 43360 <= D2 && D2 <= 43388 || 44032 <= D2 && D2 <= 55203 || 55216 <= D2 && D2 <= 55238 || 55243 <= D2 && D2 <= 55291 || 63744 <= D2 && D2 <= 64255 || 65040 <= D2 && D2 <= 65049 || 65072 <= D2 && D2 <= 65106 || 65108 <= D2 && D2 <= 65126 || 65128 <= D2 && D2 <= 65131 || 110592 <= D2 && D2 <= 110593 || 127488 <= D2 && D2 <= 127490 || 127504 <= D2 && D2 <= 127546 || 127552 <= D2 && D2 <= 127560 || 127568 <= D2 && D2 <= 127569 || 131072 <= D2 && D2 <= 194367 || 177984 <= D2 && D2 <= 196605 || 196608 <= D2 && D2 <= 262141 ? "W" : 32 <= D2 && D2 <= 126 || 162 <= D2 && D2 <= 163 || 165 <= D2 && D2 <= 166 || D2 == 172 || D2 == 175 || 10214 <= D2 && D2 <= 10221 || 10629 <= D2 && D2 <= 10630 ? "Na" : D2 == 161 || D2 == 164 || 167 <= D2 && D2 <= 168 || D2 == 170 || 173 <= D2 && D2 <= 174 || 176 <= D2 && D2 <= 180 || 182 <= D2 && D2 <= 186 || 188 <= D2 && D2 <= 191 || D2 == 198 || D2 == 208 || 215 <= D2 && D2 <= 216 || 222 <= D2 && D2 <= 225 || D2 == 230 || 232 <= D2 && D2 <= 234 || 236 <= D2 && D2 <= 237 || D2 == 240 || 242 <= D2 && D2 <= 243 || 247 <= D2 && D2 <= 250 || D2 == 252 || D2 == 254 || D2 == 257 || D2 == 273 || D2 == 275 || D2 == 283 || 294 <= D2 && D2 <= 295 || D2 == 299 || 305 <= D2 && D2 <= 307 || D2 == 312 || 319 <= D2 && D2 <= 322 || D2 == 324 || 328 <= D2 && D2 <= 331 || D2 == 333 || 338 <= D2 && D2 <= 339 || 358 <= D2 && D2 <= 359 || D2 == 363 || D2 == 462 || D2 == 464 || D2 == 466 || D2 == 468 || D2 == 470 || D2 == 472 || D2 == 474 || D2 == 476 || D2 == 593 || D2 == 609 || D2 == 708 || D2 == 711 || 713 <= D2 && D2 <= 715 || D2 == 717 || D2 == 720 || 728 <= D2 && D2 <= 731 || D2 == 733 || D2 == 735 || 768 <= D2 && D2 <= 879 || 913 <= D2 && D2 <= 929 || 931 <= D2 && D2 <= 937 || 945 <= D2 && D2 <= 961 || 963 <= D2 && D2 <= 969 || D2 == 1025 || 1040 <= D2 && D2 <= 1103 || D2 == 1105 || D2 == 8208 || 8211 <= D2 && D2 <= 8214 || 8216 <= D2 && D2 <= 8217 || 8220 <= D2 && D2 <= 8221 || 8224 <= D2 && D2 <= 8226 || 8228 <= D2 && D2 <= 8231 || D2 == 8240 || 8242 <= D2 && D2 <= 8243 || D2 == 8245 || D2 == 8251 || D2 == 8254 || D2 == 8308 || D2 == 8319 || 8321 <= D2 && D2 <= 8324 || D2 == 8364 || D2 == 8451 || D2 == 8453 || D2 == 8457 || D2 == 8467 || D2 == 8470 || 8481 <= D2 && D2 <= 8482 || D2 == 8486 || D2 == 8491 || 8531 <= D2 && D2 <= 8532 || 8539 <= D2 && D2 <= 8542 || 8544 <= D2 && D2 <= 8555 || 8560 <= D2 && D2 <= 8569 || D2 == 8585 || 8592 <= D2 && D2 <= 8601 || 8632 <= D2 && D2 <= 8633 || D2 == 8658 || D2 == 8660 || D2 == 8679 || D2 == 8704 || 8706 <= D2 && D2 <= 8707 || 8711 <= D2 && D2 <= 8712 || D2 == 8715 || D2 == 8719 || D2 == 8721 || D2 == 8725 || D2 == 8730 || 8733 <= D2 && D2 <= 8736 || D2 == 8739 || D2 == 8741 || 8743 <= D2 && D2 <= 8748 || D2 == 8750 || 8756 <= D2 && D2 <= 8759 || 8764 <= D2 && D2 <= 8765 || D2 == 8776 || D2 == 8780 || D2 == 8786 || 8800 <= D2 && D2 <= 8801 || 8804 <= D2 && D2 <= 8807 || 8810 <= D2 && D2 <= 8811 || 8814 <= D2 && D2 <= 8815 || 8834 <= D2 && D2 <= 8835 || 8838 <= D2 && D2 <= 8839 || D2 == 8853 || D2 == 8857 || D2 == 8869 || D2 == 8895 || D2 == 8978 || 9312 <= D2 && D2 <= 9449 || 9451 <= D2 && D2 <= 9547 || 9552 <= D2 && D2 <= 9587 || 9600 <= D2 && D2 <= 9615 || 9618 <= D2 && D2 <= 9621 || 9632 <= D2 && D2 <= 9633 || 9635 <= D2 && D2 <= 9641 || 9650 <= D2 && D2 <= 9651 || 9654 <= D2 && D2 <= 9655 || 9660 <= D2 && D2 <= 9661 || 9664 <= D2 && D2 <= 9665 || 9670 <= D2 && D2 <= 9672 || D2 == 9675 || 9678 <= D2 && D2 <= 9681 || 9698 <= D2 && D2 <= 9701 || D2 == 9711 || 9733 <= D2 && D2 <= 9734 || D2 == 9737 || 9742 <= D2 && D2 <= 9743 || 9748 <= D2 && D2 <= 9749 || D2 == 9756 || D2 == 9758 || D2 == 9792 || D2 == 9794 || 9824 <= D2 && D2 <= 9825 || 9827 <= D2 && D2 <= 9829 || 9831 <= D2 && D2 <= 9834 || 9836 <= D2 && D2 <= 9837 || D2 == 9839 || 9886 <= D2 && D2 <= 9887 || 9918 <= D2 && D2 <= 9919 || 9924 <= D2 && D2 <= 9933 || 9935 <= D2 && D2 <= 9953 || D2 == 9955 || 9960 <= D2 && D2 <= 9983 || D2 == 10045 || D2 == 10071 || 10102 <= D2 && D2 <= 10111 || 11093 <= D2 && D2 <= 11097 || 12872 <= D2 && D2 <= 12879 || 57344 <= D2 && D2 <= 63743 || 65024 <= D2 && D2 <= 65039 || D2 == 65533 || 127232 <= D2 && D2 <= 127242 || 127248 <= D2 && D2 <= 127277 || 127280 <= D2 && D2 <= 127337 || 127344 <= D2 && D2 <= 127386 || 917760 <= D2 && D2 <= 917999 || 983040 <= D2 && D2 <= 1048573 || 1048576 <= D2 && D2 <= 1114109 ? "A" : "N";
  }, u2.characterLength = function(e3) {
    var s2 = this.eastAsianWidth(e3);
    return s2 == "F" || s2 == "W" || s2 == "A" ? 2 : 1;
  };
  function F3(e3) {
    return e3.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  u2.length = function(e3) {
    for (var s2 = F3(e3), C2 = 0, D2 = 0; D2 < s2.length; D2++)
      C2 = C2 + this.characterLength(s2[D2]);
    return C2;
  }, u2.slice = function(e3, s2, C2) {
    textLen = u2.length(e3), s2 = s2 || 0, C2 = C2 || 1, s2 < 0 && (s2 = textLen + s2), C2 < 0 && (C2 = textLen + C2);
    for (var D2 = "", i2 = 0, o2 = F3(e3), E2 = 0; E2 < o2.length; E2++) {
      var a2 = o2[E2], n = u2.length(a2);
      if (i2 >= s2 - (n == 2 ? 1 : 0))
        if (i2 + n <= C2)
          D2 += a2;
        else
          break;
      i2 += n;
    }
    return D2;
  };
})(G2);
var K = m2;
var Y = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
function c(t3, u2 = {}) {
  if (typeof t3 != "string" || t3.length === 0 || (u2 = { ambiguousIsNarrow: true, ...u2 }, t3 = $(t3), t3.length === 0))
    return 0;
  t3 = t3.replace(Y(), "  ");
  const F3 = u2.ambiguousIsNarrow ? 1 : 2;
  let e3 = 0;
  for (const s2 of t3) {
    const C2 = s2.codePointAt(0);
    if (C2 <= 31 || C2 >= 127 && C2 <= 159 || C2 >= 768 && C2 <= 879)
      continue;
    switch (K.eastAsianWidth(s2)) {
      case "F":
      case "W":
        e3 += 2;
        break;
      case "A":
        e3 += F3;
        break;
      default:
        e3 += 1;
    }
  }
  return e3;
}
var v = 10;
var L = (t3 = 0) => (u2) => `\x1B[${u2 + t3}m`;
var M = (t3 = 0) => (u2) => `\x1B[${38 + t3};5;${u2}m`;
var T = (t3 = 0) => (u2, F3, e3) => `\x1B[${38 + t3};2;${u2};${F3};${e3}m`;
var r2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
Object.keys(r2.modifier);
var Z2 = Object.keys(r2.color);
var H = Object.keys(r2.bgColor);
[...Z2, ...H];
function U() {
  const t3 = /* @__PURE__ */ new Map();
  for (const [u2, F3] of Object.entries(r2)) {
    for (const [e3, s2] of Object.entries(F3))
      r2[e3] = { open: `\x1B[${s2[0]}m`, close: `\x1B[${s2[1]}m` }, F3[e3] = r2[e3], t3.set(s2[0], s2[1]);
    Object.defineProperty(r2, u2, { value: F3, enumerable: false });
  }
  return Object.defineProperty(r2, "codes", { value: t3, enumerable: false }), r2.color.close = "\x1B[39m", r2.bgColor.close = "\x1B[49m", r2.color.ansi = L(), r2.color.ansi256 = M(), r2.color.ansi16m = T(), r2.bgColor.ansi = L(v), r2.bgColor.ansi256 = M(v), r2.bgColor.ansi16m = T(v), Object.defineProperties(r2, { rgbToAnsi256: { value: (u2, F3, e3) => u2 === F3 && F3 === e3 ? u2 < 8 ? 16 : u2 > 248 ? 231 : Math.round((u2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u2 / 255 * 5) + 6 * Math.round(F3 / 255 * 5) + Math.round(e3 / 255 * 5), enumerable: false }, hexToRgb: { value: (u2) => {
    const F3 = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u2.toString(16));
    if (!F3)
      return [0, 0, 0];
    let [e3] = F3;
    e3.length === 3 && (e3 = [...e3].map((C2) => C2 + C2).join(""));
    const s2 = Number.parseInt(e3, 16);
    return [s2 >> 16 & 255, s2 >> 8 & 255, s2 & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u2) => r2.rgbToAnsi256(...r2.hexToRgb(u2)), enumerable: false }, ansi256ToAnsi: { value: (u2) => {
    if (u2 < 8)
      return 30 + u2;
    if (u2 < 16)
      return 90 + (u2 - 8);
    let F3, e3, s2;
    if (u2 >= 232)
      F3 = ((u2 - 232) * 10 + 8) / 255, e3 = F3, s2 = F3;
    else {
      u2 -= 16;
      const i2 = u2 % 36;
      F3 = Math.floor(u2 / 36) / 5, e3 = Math.floor(i2 / 6) / 5, s2 = i2 % 6 / 5;
    }
    const C2 = Math.max(F3, e3, s2) * 2;
    if (C2 === 0)
      return 30;
    let D2 = 30 + (Math.round(s2) << 2 | Math.round(e3) << 1 | Math.round(F3));
    return C2 === 2 && (D2 += 60), D2;
  }, enumerable: false }, rgbToAnsi: { value: (u2, F3, e3) => r2.ansi256ToAnsi(r2.rgbToAnsi256(u2, F3, e3)), enumerable: false }, hexToAnsi: { value: (u2) => r2.ansi256ToAnsi(r2.hexToAnsi256(u2)), enumerable: false } }), r2;
}
var q = U();
var p = /* @__PURE__ */ new Set(["\x1B", "\x9B"]);
var J = 39;
var b = "\x07";
var W = "[";
var Q = "]";
var I = "m";
var w = `${Q}8;;`;
var N = (t3) => `${p.values().next().value}${W}${t3}${I}`;
var j = (t3) => `${p.values().next().value}${w}${t3}${b}`;
var X = (t3) => t3.split(" ").map((u2) => c(u2));
var _ = (t3, u2, F3) => {
  const e3 = [...u2];
  let s2 = false, C2 = false, D2 = c($(t3[t3.length - 1]));
  for (const [i2, o2] of e3.entries()) {
    const E2 = c(o2);
    if (D2 + E2 <= F3 ? t3[t3.length - 1] += o2 : (t3.push(o2), D2 = 0), p.has(o2) && (s2 = true, C2 = e3.slice(i2 + 1).join("").startsWith(w)), s2) {
      C2 ? o2 === b && (s2 = false, C2 = false) : o2 === I && (s2 = false);
      continue;
    }
    D2 += E2, D2 === F3 && i2 < e3.length - 1 && (t3.push(""), D2 = 0);
  }
  !D2 && t3[t3.length - 1].length > 0 && t3.length > 1 && (t3[t3.length - 2] += t3.pop());
};
var DD = (t3) => {
  const u2 = t3.split(" ");
  let F3 = u2.length;
  for (; F3 > 0 && !(c(u2[F3 - 1]) > 0); )
    F3--;
  return F3 === u2.length ? t3 : u2.slice(0, F3).join(" ") + u2.slice(F3).join("");
};
var uD = (t3, u2, F3 = {}) => {
  if (F3.trim !== false && t3.trim() === "")
    return "";
  let e3 = "", s2, C2;
  const D2 = X(t3);
  let i2 = [""];
  for (const [E2, a2] of t3.split(" ").entries()) {
    F3.trim !== false && (i2[i2.length - 1] = i2[i2.length - 1].trimStart());
    let n = c(i2[i2.length - 1]);
    if (E2 !== 0 && (n >= u2 && (F3.wordWrap === false || F3.trim === false) && (i2.push(""), n = 0), (n > 0 || F3.trim === false) && (i2[i2.length - 1] += " ", n++)), F3.hard && D2[E2] > u2) {
      const B = u2 - n, A3 = 1 + Math.floor((D2[E2] - B - 1) / u2);
      Math.floor((D2[E2] - 1) / u2) < A3 && i2.push(""), _(i2, a2, u2);
      continue;
    }
    if (n + D2[E2] > u2 && n > 0 && D2[E2] > 0) {
      if (F3.wordWrap === false && n < u2) {
        _(i2, a2, u2);
        continue;
      }
      i2.push("");
    }
    if (n + D2[E2] > u2 && F3.wordWrap === false) {
      _(i2, a2, u2);
      continue;
    }
    i2[i2.length - 1] += a2;
  }
  F3.trim !== false && (i2 = i2.map((E2) => DD(E2)));
  const o2 = [...i2.join(`
`)];
  for (const [E2, a2] of o2.entries()) {
    if (e3 += a2, p.has(a2)) {
      const { groups: B } = new RegExp(`(?:\\${W}(?<code>\\d+)m|\\${w}(?<uri>.*)${b})`).exec(o2.slice(E2).join("")) || { groups: {} };
      if (B.code !== void 0) {
        const A3 = Number.parseFloat(B.code);
        s2 = A3 === J ? void 0 : A3;
      } else
        B.uri !== void 0 && (C2 = B.uri.length === 0 ? void 0 : B.uri);
    }
    const n = q.codes.get(Number(s2));
    o2[E2 + 1] === `
` ? (C2 && (e3 += j("")), s2 && n && (e3 += N(n))) : a2 === `
` && (s2 && n && (e3 += N(s2)), C2 && (e3 += j(C2)));
  }
  return e3;
};
function P(t3, u2, F3) {
  return String(t3).normalize().replace(/\r\n/g, `
`).split(`
`).map((e3) => uD(e3, u2, F3)).join(`
`);
}
function FD(t3, u2) {
  if (t3 === u2)
    return;
  const F3 = t3.split(`
`), e3 = u2.split(`
`), s2 = [];
  for (let C2 = 0; C2 < Math.max(F3.length, e3.length); C2++)
    F3[C2] !== e3[C2] && s2.push(C2);
  return s2;
}
var R = Symbol("clack:cancel");
function eD(t3) {
  return t3 === R;
}
function g(t3, u2) {
  t3.isTTY && t3.setRawMode(u2);
}
var V = /* @__PURE__ */ new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"]]);
var tD = /* @__PURE__ */ new Set(["up", "down", "left", "right", "space", "enter"]);
var h2 = class {
  constructor({ render: u2, input: F3 = import_node_process.stdin, output: e3 = import_node_process.stdout, ...s2 }, C2 = true) {
    this._track = false, this._cursor = 0, this.state = "initial", this.error = "", this.subscribers = /* @__PURE__ */ new Map(), this._prevFrame = "", this.opts = s2, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = u2.bind(this), this._track = C2, this.input = F3, this.output = e3;
  }
  prompt() {
    const u2 = new import_node_tty.WriteStream(0);
    return u2._write = (F3, e3, s2) => {
      this._track && (this.value = this.rl.line.replace(/\t/g, ""), this._cursor = this.rl.cursor, this.emit("value", this.value)), s2();
    }, this.input.pipe(u2), this.rl = import_node_readline.default.createInterface({ input: this.input, output: u2, tabSize: 2, prompt: "", escapeCodeTimeout: 50 }), import_node_readline.default.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== void 0 && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), g(this.input, true), this.output.on("resize", this.render), this.render(), new Promise((F3, e3) => {
      this.once("submit", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), g(this.input, false), F3(this.value);
      }), this.once("cancel", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), g(this.input, false), F3(R);
      });
    });
  }
  on(u2, F3) {
    const e3 = this.subscribers.get(u2) ?? [];
    e3.push({ cb: F3 }), this.subscribers.set(u2, e3);
  }
  once(u2, F3) {
    const e3 = this.subscribers.get(u2) ?? [];
    e3.push({ cb: F3, once: true }), this.subscribers.set(u2, e3);
  }
  emit(u2, ...F3) {
    const e3 = this.subscribers.get(u2) ?? [], s2 = [];
    for (const C2 of e3)
      C2.cb(...F3), C2.once && s2.push(() => e3.splice(e3.indexOf(C2), 1));
    for (const C2 of s2)
      C2();
  }
  unsubscribe() {
    this.subscribers.clear();
  }
  onKeypress(u2, F3) {
    if (this.state === "error" && (this.state = "active"), F3?.name && !this._track && V.has(F3.name) && this.emit("cursor", V.get(F3.name)), F3?.name && tD.has(F3.name) && this.emit("cursor", F3.name), u2 && (u2.toLowerCase() === "y" || u2.toLowerCase() === "n") && this.emit("confirm", u2.toLowerCase() === "y"), u2 && this.emit("key", u2.toLowerCase()), F3?.name === "return") {
      if (this.opts.validate) {
        const e3 = this.opts.validate(this.value);
        e3 && (this.error = e3, this.state = "error", this.rl.write(this.value));
      }
      this.state !== "error" && (this.state = "submit");
    }
    u2 === "" && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), g(this.input, false), this.rl.close(), this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    const u2 = P(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
    this.output.write(import_sisteransi.cursor.move(-999, u2 * -1));
  }
  render() {
    const u2 = P(this._render(this) ?? "", process.stdout.columns, { hard: true });
    if (u2 !== this._prevFrame) {
      if (this.state === "initial")
        this.output.write(import_sisteransi.cursor.hide);
      else {
        const F3 = FD(this._prevFrame, u2);
        if (this.restoreCursor(), F3 && F3?.length === 1) {
          const e3 = F3[0];
          this.output.write(import_sisteransi.cursor.move(0, e3)), this.output.write(import_sisteransi.erase.lines(1));
          const s2 = u2.split(`
`);
          this.output.write(s2[e3]), this._prevFrame = u2, this.output.write(import_sisteransi.cursor.move(0, s2.length - e3 - 1));
          return;
        } else if (F3 && F3?.length > 1) {
          const e3 = F3[0];
          this.output.write(import_sisteransi.cursor.move(0, e3)), this.output.write(import_sisteransi.erase.down());
          const C2 = u2.split(`
`).slice(e3);
          this.output.write(C2.join(`
`)), this._prevFrame = u2;
          return;
        }
        this.output.write(import_sisteransi.erase.down());
      }
      this.output.write(u2), this.state === "initial" && (this.state = "active"), this._prevFrame = u2;
    }
  }
};
var sD = class extends h2 {
  get cursor() {
    return this.value ? 0 : 1;
  }
  get _value() {
    return this.cursor === 0;
  }
  constructor(u2) {
    super(u2, false), this.value = !!u2.initialValue, this.on("value", () => {
      this.value = this._value;
    }), this.on("confirm", (F3) => {
      this.output.write(import_sisteransi.cursor.move(0, -1)), this.value = F3, this.state = "submit", this.close();
    }), this.on("cursor", () => {
      this.value = !this.value;
    });
  }
};
var oD = class extends h2 {
  constructor(u2) {
    super(u2), this.valueWithCursor = "", this.on("finalize", () => {
      this.value || (this.value = u2.defaultValue), this.valueWithCursor = this.value;
    }), this.on("value", () => {
      if (this.cursor >= this.value.length)
        this.valueWithCursor = `${this.value}${import_picocolors.default.inverse(import_picocolors.default.hidden("_"))}`;
      else {
        const F3 = this.value.slice(0, this.cursor), e3 = this.value.slice(this.cursor);
        this.valueWithCursor = `${F3}${import_picocolors.default.inverse(e3[0])}${e3.slice(1)}`;
      }
    });
  }
  get cursor() {
    return this._cursor;
  }
};
function aD({ input: t3 = import_node_process.stdin, output: u2 = import_node_process.stdout, overwrite: F3 = true, hideCursor: e3 = true } = {}) {
  const s2 = f3.createInterface({ input: t3, output: u2, prompt: "", tabSize: 1 });
  f3.emitKeypressEvents(t3, s2), t3.isTTY && t3.setRawMode(true);
  const C2 = (D2, { name: i2 }) => {
    if (String(D2) === "" && process.exit(0), !F3)
      return;
    let E2 = i2 === "return" ? 0 : -1, a2 = i2 === "return" ? -1 : 0;
    f3.moveCursor(u2, E2, a2, () => {
      f3.clearLine(u2, 1, () => {
        t3.once("keypress", C2);
      });
    });
  };
  return e3 && process.stdout.write(import_sisteransi.cursor.hide), t3.once("keypress", C2), () => {
    t3.off("keypress", C2), e3 && process.stdout.write(import_sisteransi.cursor.show), s2.terminal = false, s2.close();
  };
}

// ../../node_modules/.pnpm/@clack+prompts@0.6.3/node_modules/@clack/prompts/dist/index.mjs
var import_node_process2 = __toESM(require("node:process"), 1);
var import_picocolors2 = __toESM(require_picocolors(), 1);
var import_sisteransi2 = __toESM(require_src(), 1);
function N2() {
  return import_node_process2.default.platform !== "win32" ? import_node_process2.default.env.TERM !== "linux" : Boolean(import_node_process2.default.env.CI) || Boolean(import_node_process2.default.env.WT_SESSION) || Boolean(import_node_process2.default.env.TERMINUS_SUBLIME) || import_node_process2.default.env.ConEmuTask === "{cmd::Cmder}" || import_node_process2.default.env.TERM_PROGRAM === "Terminus-Sublime" || import_node_process2.default.env.TERM_PROGRAM === "vscode" || import_node_process2.default.env.TERM === "xterm-256color" || import_node_process2.default.env.TERM === "alacritty" || import_node_process2.default.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var p2 = N2();
var u = (r3, n) => p2 ? r3 : n;
var W2 = u("\u25C6", "*");
var D = u("\u25A0", "x");
var F2 = u("\u25B2", "x");
var f4 = u("\u25C7", "o");
var L2 = u("\u250C", "T");
var a = u("\u2502", "|");
var o = u("\u2514", "\u2014");
var w2 = u("\u25CF", ">");
var S3 = u("\u25CB", " ");
var _2 = u("\u25FB", "[\u2022]");
var y2 = u("\u25FC", "[+]");
var A2 = u("\u25FB", "[ ]");
var q2 = u("\u25AA", "\u2022");
var R2 = u("\u2500", "-");
var G3 = u("\u256E", "+");
var H2 = u("\u251C", "+");
var K2 = u("\u256F", "+");
var U2 = u("\u25CF", "\u2022");
var Z3 = u("\u25C6", "*");
var z2 = u("\u25B2", "!");
var X2 = u("\u25A0", "x");
var h3 = (r3) => {
  switch (r3) {
    case "initial":
    case "active":
      return import_picocolors2.default.cyan(W2);
    case "cancel":
      return import_picocolors2.default.red(D);
    case "error":
      return import_picocolors2.default.yellow(F2);
    case "submit":
      return import_picocolors2.default.green(f4);
  }
};
var J2 = (r3) => new oD({ validate: r3.validate, placeholder: r3.placeholder, defaultValue: r3.defaultValue, initialValue: r3.initialValue, render() {
  const n = `${import_picocolors2.default.gray(a)}
${h3(this.state)}  ${r3.message}
`, s2 = r3.placeholder ? import_picocolors2.default.inverse(r3.placeholder[0]) + import_picocolors2.default.dim(r3.placeholder.slice(1)) : import_picocolors2.default.inverse(import_picocolors2.default.hidden("_")), t3 = this.value ? this.valueWithCursor : s2;
  switch (this.state) {
    case "error":
      return `${n.trim()}
${import_picocolors2.default.yellow(a)}  ${t3}
${import_picocolors2.default.yellow(o)}  ${import_picocolors2.default.yellow(this.error)}
`;
    case "submit":
      return `${n}${import_picocolors2.default.gray(a)}  ${import_picocolors2.default.dim(this.value || r3.placeholder)}`;
    case "cancel":
      return `${n}${import_picocolors2.default.gray(a)}  ${import_picocolors2.default.strikethrough(import_picocolors2.default.dim(this.value ?? ""))}${this.value?.trim() ? `
` + import_picocolors2.default.gray(a) : ""}`;
    default:
      return `${n}${import_picocolors2.default.cyan(a)}  ${t3}
${import_picocolors2.default.cyan(o)}
`;
  }
} }).prompt();
var Q2 = (r3) => {
  const n = r3.active ?? "Yes", s2 = r3.inactive ?? "No";
  return new sD({ active: n, inactive: s2, initialValue: r3.initialValue ?? true, render() {
    const t3 = `${import_picocolors2.default.gray(a)}
${h3(this.state)}  ${r3.message}
`, i2 = this.value ? n : s2;
    switch (this.state) {
      case "submit":
        return `${t3}${import_picocolors2.default.gray(a)}  ${import_picocolors2.default.dim(i2)}`;
      case "cancel":
        return `${t3}${import_picocolors2.default.gray(a)}  ${import_picocolors2.default.strikethrough(import_picocolors2.default.dim(i2))}
${import_picocolors2.default.gray(a)}`;
      default:
        return `${t3}${import_picocolors2.default.cyan(a)}  ${this.value ? `${import_picocolors2.default.green(w2)} ${n}` : `${import_picocolors2.default.dim(S3)} ${import_picocolors2.default.dim(n)}`} ${import_picocolors2.default.dim("/")} ${this.value ? `${import_picocolors2.default.dim(S3)} ${import_picocolors2.default.dim(s2)}` : `${import_picocolors2.default.green(w2)} ${s2}`}
${import_picocolors2.default.cyan(o)}
`;
    }
  } }).prompt();
};
var ne = (r3 = "") => {
  process.stdout.write(`${import_picocolors2.default.gray(o)}  ${import_picocolors2.default.red(r3)}

`);
};
var ae = (r3 = "") => {
  process.stdout.write(`${import_picocolors2.default.gray(L2)}  ${r3}
`);
};
var ce = (r3 = "") => {
  process.stdout.write(`${import_picocolors2.default.gray(a)}
${import_picocolors2.default.gray(o)}  ${r3}

`);
};
var g2 = { message: (r3 = "", { symbol: n = import_picocolors2.default.gray(a) } = {}) => {
  const s2 = [`${import_picocolors2.default.gray(a)}`];
  if (r3) {
    const [t3, ...i2] = r3.split(`
`);
    s2.push(`${n}  ${t3}`, ...i2.map((c2) => `${import_picocolors2.default.gray(a)}  ${c2}`));
  }
  process.stdout.write(`${s2.join(`
`)}
`);
}, info: (r3) => {
  g2.message(r3, { symbol: import_picocolors2.default.blue(U2) });
}, success: (r3) => {
  g2.message(r3, { symbol: import_picocolors2.default.green(Z3) });
}, step: (r3) => {
  g2.message(r3, { symbol: import_picocolors2.default.green(f4) });
}, warn: (r3) => {
  g2.message(r3, { symbol: import_picocolors2.default.yellow(z2) });
}, warning: (r3) => {
  g2.warn(r3);
}, error: (r3) => {
  g2.message(r3, { symbol: import_picocolors2.default.red(X2) });
} };
var C = p2 ? ["\u25D2", "\u25D0", "\u25D3", "\u25D1"] : ["\u2022", "o", "O", "0"];
var le = () => {
  let r3, n;
  const s2 = p2 ? 80 : 120;
  return { start(t3 = "") {
    t3 = t3.replace(/\.?\.?\.$/, ""), r3 = aD(), process.stdout.write(`${import_picocolors2.default.gray(a)}
${import_picocolors2.default.magenta("\u25CB")}  ${t3}
`);
    let i2 = 0, c2 = 0;
    n = setInterval(() => {
      let l2 = C[i2];
      process.stdout.write(import_sisteransi2.cursor.move(-999, -1)), process.stdout.write(`${import_picocolors2.default.magenta(l2)}  ${t3}${Math.floor(c2) >= 1 ? ".".repeat(Math.floor(c2)).slice(0, 3) : ""}   
`), i2 = i2 === C.length - 1 ? 0 : i2 + 1, c2 = c2 === C.length ? 0 : c2 + 0.125;
    }, s2);
  }, stop(t3 = "") {
    process.stdout.write(import_sisteransi2.cursor.move(-999, -2)), process.stdout.write(import_sisteransi2.erase.down(2)), clearInterval(n), process.stdout.write(`${import_picocolors2.default.gray(a)}
${import_picocolors2.default.green(f4)}  ${t3}
`), r3();
  } };
};
var $e = async (r3, n) => {
  const s2 = {}, t3 = Object.keys(r3);
  for (const i2 of t3) {
    const c2 = r3[i2], l2 = await c2({ results: s2 })?.catch(($3) => {
      throw $3;
    });
    if (typeof n?.onCancel == "function" && eD(l2)) {
      s2[i2] = "canceled", n.onCancel({ results: s2 });
      continue;
    }
    s2[i2] = l2;
  }
  return s2;
};

// ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/colors.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $2 = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x3, y3) {
  let rgx = new RegExp(`\\x1b\\[${y3}m`, "g");
  let open = `\x1B[${x3}m`, close = `\x1B[${y3}m`;
  return function(txt) {
    if (!$2.enabled || txt == null)
      return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset3 = init(0, 0);
var bold3 = init(1, 22);
var dim3 = init(2, 22);
var italic3 = init(3, 23);
var underline3 = init(4, 24);
var inverse3 = init(7, 27);
var hidden3 = init(8, 28);
var strikethrough3 = init(9, 29);
var black3 = init(30, 39);
var red3 = init(31, 39);
var green3 = init(32, 39);
var yellow3 = init(33, 39);
var blue3 = init(34, 39);
var magenta3 = init(35, 39);
var cyan3 = init(36, 39);
var white3 = init(37, 39);
var gray3 = init(90, 39);
var grey = init(90, 39);
var bgBlack3 = init(40, 49);
var bgRed3 = init(41, 49);
var bgGreen3 = init(42, 49);
var bgYellow3 = init(43, 49);
var bgBlue3 = init(44, 49);
var bgMagenta3 = init(45, 49);
var bgCyan3 = init(46, 49);
var bgWhite3 = init(47, 49);

// src/cmd/init.ts
var import_node_child_process = require("node:child_process");
function pCancel(cancelText = "Operation cancelled.") {
  ne(cancelText);
  process.exit(1);
}
async function init2(_path, args) {
  ae("\u{1F3A9} Welcome to Houdini!");
  try {
    await fs_exports.stat(path_exports.resolve("./src"));
  } catch {
    throw new Error(
      "Please initialize your project first before running init. For svelte projects, you should follow the instructions here: https://kit.svelte.dev/"
    );
  }
  let headers = extractHeaders(args.headers);
  const targetPath = _path ? path_exports.resolve(_path) : process.cwd();
  let use_git = false;
  let dir = targetPath;
  do {
    if (fs_exports.existsSync(path_exports.join(dir, ".git"))) {
      use_git = true;
      break;
    }
  } while (dir !== (dir = path_exports.dirname(dir)));
  if (use_git) {
    const status = (0, import_node_child_process.execSync)("git status --porcelain", { stdio: "pipe" }).toString();
    if (status) {
      const { confirm } = await $e(
        {
          confirm: () => {
            g2.warning(
              `Your git working directory is dirty \u2014 we recommend committing your changes before running this migration.`
            );
            return Q2({
              message: `Continue anyway?`,
              initialValue: false
            });
          }
        },
        {
          onCancel: () => pCancel()
        }
      );
      if (confirm !== true) {
        pCancel();
      }
    }
  }
  let url = "http://localhost:5173/api/graphql";
  let is_remote_endpoint = true;
  if (!args.yes) {
    is_remote_endpoint = (await $e(
      {
        is_remote_endpoint: () => Q2({
          message: "Will you use a remote GraphQL API?",
          initialValue: true
        })
      },
      {
        onCancel: () => pCancel()
      }
    )).is_remote_endpoint;
  }
  let schemaPath = is_remote_endpoint ? "./schema.graphql" : "path/to/src/lib/**/*.graphql";
  let pullSchema_content = null;
  if (is_remote_endpoint && !args.yes) {
    let number_of_round = 0;
    let url_and_headers = "";
    while (pullSchema_content === null && number_of_round < 10) {
      number_of_round++;
      const answer = await $e(
        {
          url_and_headers: async () => J2({
            message: `What's the URL for your api? ${number_of_round === 1 ? "" : `(attempt ${number_of_round})`}`,
            placeholder: `http://localhost:4000/graphql ${number_of_round === 1 ? "" : "Authorization=Bearer MyToken"}`,
            validate: (value) => {
              if (value === "") {
                return;
              }
              if (!value.startsWith("http")) {
                return "Please enter a valid URL";
              }
            }
          })
        },
        {
          onCancel: () => pCancel()
        }
      );
      url_and_headers = answer.url_and_headers;
      const value_splited = url_and_headers.split(" ");
      const local_url = value_splited[0];
      const local_headers = value_splited.length > 1 ? extractHeadersStr(value_splited.slice(1).join(" ")) : headers;
      pullSchema_content = await pullSchema(local_url, schemaPath, local_headers, true);
      if (pullSchema_content === null) {
        const msg = `If you need to pass headers, add them after the URL (eg: '${green3(
          `http://myurl.com/graphql Authorization=Bearer MyToken`
        )}')`;
        g2.error(msg);
      }
      url = url_and_headers === "" ? "http://localhost:4000/graphql" : local_url;
    }
    if (pullSchema_content === null) {
      pCancel("We couldn't pull the schema. Please check your URL/headers and try again.");
    }
  } else if (!args.yes) {
    const answers = await $e(
      {
        schema_path: () => J2({
          message: "Where is your schema located?",
          placeholder: schemaPath,
          validate: (value) => {
            if (value === "") {
              return "Please enter a valid schemaPath";
            }
          }
        })
      },
      {
        onCancel: () => pCancel()
      }
    );
    schemaPath = answers.schema_path;
  }
  if (is_remote_endpoint && pullSchema_content) {
    await fs_exports.writeFile(path_exports.join(targetPath, schemaPath), pullSchema_content);
  }
  const { frameworkInfo, typescript, module: module2, package_manager } = await detectTools(targetPath);
  const found_to_log = [];
  if (frameworkInfo.framework === "svelte") {
    found_to_log.push("\u2728 Svelte");
  } else if (frameworkInfo.framework === "kit") {
    found_to_log.push("\u2728 SvelteKit");
  } else {
    throw new Error(`Unmanaged framework: "${JSON.stringify(frameworkInfo)}"`);
  }
  if (module2 === "esm") {
    found_to_log.push("\u{1F4E6} ES Modules");
  } else {
    found_to_log.push("\u{1F4E6} CommonJS");
  }
  if (typescript) {
    found_to_log.push("\u{1F7E6} TypeScript");
  } else {
    found_to_log.push("\u{1F7E8} JavaScript");
  }
  g2.info(`Here's what we found: ${found_to_log.join(", ")}`);
  const sourceDir = path_exports.join(targetPath, "src");
  const configPath = path_exports.join(targetPath, "houdini.config.js");
  const s2 = le();
  s2.start(`\u{1F6A7} Generating houdini's files...`);
  await houdiniConfig(
    configPath,
    schemaPath,
    module2,
    frameworkInfo,
    is_remote_endpoint ? url : null
  );
  await houdiniClient(sourceDir, typescript, frameworkInfo, url);
  if (frameworkInfo.framework === "svelte") {
    await svelteKitConfig(targetPath, typescript);
  } else if (frameworkInfo.framework === "kit") {
    await svelteConfig(targetPath, typescript);
  }
  await gitIgnore(targetPath);
  await graphqlRC(targetPath);
  await viteConfig(targetPath, frameworkInfo, typescript);
  await tjsConfig(targetPath, frameworkInfo);
  await packageJSON(targetPath, frameworkInfo);
  s2.stop(`Houdini's files generated ${green3("\u2713")}`);
  ce("\u{1F389} Everything is ready!");
  finale_logs(package_manager);
}
function finale_logs(package_manager) {
  let cmd_install = "npm i";
  let cmd_run = "npm run dev";
  if (package_manager === "pnpm") {
    cmd_install = "pnpm i";
    cmd_run = "pnpm dev";
  } else if (package_manager === "yarn") {
    cmd_install = "yarn";
    cmd_run = "yarn dev";
  }
  console.log(`\u{1F449} Next Steps`);
  console.log(`1\uFE0F\u20E3  Finalize your installation: ${green3(cmd_install)}
2\uFE0F\u20E3  Start your application:     ${green3(cmd_run)}
`);
  console.log(
    gray3(
      italic3(
        `${bold3("\u2754 More help")} at ${cyan3(
          "https://houdinigraphql.com"
        )} (\u{1F4C4} Docs, \u2B50 Github, \u{1F4E3} Discord, ...)
`
      )
    )
  );
}
async function houdiniConfig(configPath, schemaPath, module2, frameworkInfo, url) {
  const config = {};
  if (url !== null) {
    config.watchSchema = {
      url
    };
  }
  if (schemaPath !== "./schema.graphql") {
    config.schemaPath = schemaPath;
  }
  if (module2 !== "esm") {
    config.module = module2;
  }
  if (frameworkInfo.framework === "svelte") {
    config.plugins = {
      "houdini-svelte": {
        framework: "svelte"
      }
    };
  } else if (frameworkInfo.framework === "kit") {
    config.plugins = {
      "houdini-svelte": {}
    };
  }
  const configObj = JSON.stringify(config, null, 4);
  const content_base = `/// <references types="houdini-svelte">

/** @type {import('houdini').ConfigFile} */
const config = ${configObj}`;
  const content = module2 === "esm" ? `${content_base}

export default config
` : `${content_base}}

module.exports = config
`;
  await fs_exports.writeFile(configPath, content);
  return false;
}
async function houdiniClient(targetPath, typescript, frameworkInfo, url) {
  const houdiniClientExt = typescript ? `ts` : `js`;
  const houdiniClientPath = path_exports.join(targetPath, `client.${houdiniClientExt}`);
  const content = `import { HoudiniClient } from '$houdini';

export default new HoudiniClient({
    url: '${url}'

    // uncomment this to configure the network call (for things like authentication)
    // for more information, please visit here: https://www.houdinigraphql.com/guides/authentication
    // fetchParams({ session }) {
    //     return {
    //         headers: {
    //             Authentication: \`Bearer \${session.token}\`,
    //         }
    //     }
    // }
})
`;
  await fs_exports.writeFile(houdiniClientPath, content);
}
async function svelteKitConfig(targetPath, typescript) {
  const svelteMainJsPath = path_exports.join(targetPath, "src", typescript ? "main.ts" : "main.js");
  const newContent = `import client from "./client";
import './app.css'
import App from './App.svelte'

const app = new App({
	target: document.getElementById('app')
})

export default app
`;
  await fs_exports.writeFile(svelteMainJsPath, newContent);
}
async function svelteConfig(targetPath, typescript) {
  const svelteConfigPath = path_exports.join(targetPath, "svelte.config.js");
  const newContentTs = `import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/kit/vite';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://kit.svelte.dev/docs/integrations#preprocessors
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		adapter: adapter(),
		alias: {
			$houdini: './$houdini',
		}
	}
};

export default config;
`;
  const newContentJs = `import adapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	kit: {
		adapter: adapter(),
		alias: {
			$houdini: './$houdini',
		}
	}
};

export default config;
`;
  await fs_exports.writeFile(svelteConfigPath, typescript ? newContentTs : newContentJs);
}
async function gitIgnore(targetPath) {
  const filepath = path_exports.join(targetPath, ".gitignore");
  const existing = await fs_exports.readFile(filepath) || "";
  if (!existing.includes("\n$houdini\n")) {
    await fs_exports.writeFile(filepath, existing + "\n$houdini\n");
  }
}
async function graphqlRC(targetPath) {
  const target = path_exports.join(targetPath, ".graphqlrc.yaml");
  const content = `projects:
  default:
    schema:
      - ./schema.graphql
      - ./$houdini/graphql/schema.graphql
    documents:
      - '**/*.gql'
      - '**/*.svelte'
      - ./$houdini/graphql/documents.gql
`;
  await fs_exports.writeFile(target, content);
}
async function viteConfig(targetPath, frameworkInfo, typescript) {
  const viteConfigPath = path_exports.join(targetPath, typescript ? "vite.config.ts" : "vite.config.js");
  let content = "NO_CONTENT_THIS_SHOULD_NEVER_BE_SEEN";
  if (frameworkInfo.framework === "svelte") {
    content = `import { svelte } from '@sveltejs/vite-plugin-svelte'
import houdini from 'houdini/vite'
import * as path from 'path'
import { defineConfig } from 'vite'

export default defineConfig({
	plugins: [houdini(), svelte()],

	resolve: {
		alias: {
			$houdini: path.resolve('$houdini'),
		},
	},
})
	`;
  } else if (frameworkInfo.framework === "kit") {
    content = `import { sveltekit } from '@sveltejs/kit/vite'
import houdini from 'houdini/vite'
import { defineConfig } from 'vite'

export default defineConfig({
	plugins: [houdini(), sveltekit()]
});
`;
  } else {
    throw new Error(`Unmanaged framework: "${JSON.stringify(frameworkInfo)}"`);
  }
  await fs_exports.writeFile(viteConfigPath, content);
}
async function tjsConfig(targetPath, frameworkInfo) {
  let configFile = path_exports.join(targetPath, "tsconfig.json");
  try {
    await fs_exports.stat(configFile);
  } catch {
    configFile = path_exports.join(targetPath, "jsconfig.json");
    try {
      await fs_exports.stat(configFile);
    } catch {
      return false;
    }
  }
  try {
    let tjsConfigFile = await fs_exports.readFile(configFile);
    if (tjsConfigFile) {
      var tjsConfig2 = parseJSON(tjsConfigFile);
    }
    if (frameworkInfo.framework === "svelte") {
      tjsConfig2.compilerOptions.rootDirs = [".", "./$houdini/types"];
    } else if (frameworkInfo.framework === "kit") {
      tjsConfig2.compilerOptions.rootDirs = [".", "./.svelte-kit/types", "./$houdini/types"];
    }
    if (frameworkInfo.framework === "svelte") {
      tjsConfig2.compilerOptions.paths = {
        ...tjsConfig2.compilerOptions.paths,
        $houdini: ["./$houdini"],
        "$houdini/*": ["./$houdini/*"]
      };
    }
    await fs_exports.writeFile(configFile, JSON.stringify(tjsConfig2, null, 4));
  } catch {
  }
  return false;
}
async function packageJSON(targetPath, frameworkInfo) {
  let packageJSON2 = {};
  const packagePath = path_exports.join(targetPath, "package.json");
  const packageFile = await fs_exports.readFile(packagePath);
  if (packageFile) {
    packageJSON2 = JSON.parse(packageFile);
  }
  packageJSON2.devDependencies = {
    ...packageJSON2.devDependencies,
    houdini: "^1.2.33"
  };
  if (frameworkInfo.framework === "svelte" || frameworkInfo.framework === "kit") {
    packageJSON2.devDependencies = {
      ...packageJSON2.devDependencies,
      "houdini-svelte": "^1.2.33"
    };
  } else {
    throw new Error(`Unmanaged framework: "${JSON.stringify(frameworkInfo)}"`);
  }
  await fs_exports.writeFile(packagePath, JSON.stringify(packageJSON2, null, 4));
}

// src/cmd/index.ts
var program2 = new Command();
program2.command("generate").description("generate the application runtime").option("-p, --pull-schema", "pull the latest schema before generating").option("-o, --output [outputPath]", "persist queries to a queryMap file").option(
  "-h, --headers <headers...>",
  "headers to use when pulling your schema. Should be passed as KEY=VALUE"
).option("-v, --verbose", "verbose error messages").option(
  "-l, --log [level]",
  `the log level for the generate command. One of ${JSON.stringify(Object.values(LogLevel))}`
).action(generate);
program2.command("init").arguments("[path]").usage("[path] [options]").description("initialize a new houdini project").option(
  "-h, --headers <headers...>",
  "header to use when pulling your schema. Should be passed as KEY=VALUE"
).option("-y, --yes", "dont prompt for input. uses default values or empty strings").action(init2);
program2.command("pull-schema").usage("[options]").description("pull the latest schema from your api").option(
  "-h, --headers <headers...>",
  "headers to use when pulling your schema. Should be passed as KEY=VALUE"
).action(pullSchema_default);
program2.parse();
process.on("unhandledRejection", (error) => {
  if ("description" in error) {
  } else {
    console.log(error);
  }
});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/**
 * Based on implementations by Gary Court and Austin Appleby, 2011, MIT. Copied from https://github.com/facebook/relay
 * @preserve-header
 */
